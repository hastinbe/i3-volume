#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications.
#
#  Dependencies: awk bc jq WirePlumber
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume
#  Wiki: https://github.com/hastinbe/i3-volume/wiki/

define_helpers() {
    empty() { [[ -z $1 ]]; }
    not_empty() { [[ -n $1 ]]; }
    isset() { [[ -v $1 ]]; }
    command_exists() { command -v "$1" &>/dev/null; }
    error() { echo "$COLOR_RED$*$COLOR_RESET"; }
    has_color() { [ "$(tput colors)" -ge 8 ] &>/dev/null && [ -t 1 ]; }
    ms_to_secs() { echo "scale=0; (${1} + 999) / 1000" | bc; }
    is_command_hookable() { ! [[ ${POST_HOOK_EXEMPT_COMMANDS[*]} =~ $1 ]]; }
    has_capability() { [[ "${NOTIFY_CAPS[*]}" =~ $1 ]]; }
    max() { echo $(( $1 > $2 ? $1 : $2 )); }
}

define_notify() {
    notify_volume() {
        local -r vol=$(get_volume)
        local icon summary body=""

        if is_muted; then
            summary="Volume muted"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Volume %3s%%" "$vol"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "$body" ;;
        esac
    }

    notify_mic() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            return 1
        fi

        local -r vol=$(get_mic_volume)
        local icon summary body=""

        if is_mic_muted; then
            summary="Microphone muted"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Microphone %3s%%" "$vol"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "$body" ;;
        esac
    }

    list_notification_methods() {
        local source="${BASH_SOURCE[0]}"
        awk -v source="$source" 'match($0, / +notify_volume_([[:alnum:]]+)\(\)/) { print substr($0, RSTART + 18, RLENGTH - 20) }' "$source" || EXITCODE=$EX_USAGE
    }

    setup_notification_icons() { not_empty "$SYMBOLIC_ICON_SUFFIX" && apply_symbolic_icon_suffix; }

    show_volume_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_volume
    }

    load_notify_server_info() {
        command_exists dbus-send || return
        IFS=$'\t' read -r NOTIFY_SERVER _ _ _ < <(dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.GetServerInformation | awk 'BEGIN { ORS="\t" }; match($0, /^   string ".*"/) {print substr($0, RSTART+11, RLENGTH-12)}')
    }

    load_notify_server_caps() {
        command_exists dbus-send || return
        IFS= read -r -d '' -a NOTIFY_CAPS < <(dbus-send --print-reply=literal --dest="${DBUS_NAME}" "${DBUS_PATH}" "${DBUS_IFAC_FDN}.GetCapabilities" | awk 'RS="      " { if (NR > 2) print $1 }')
    }

    notify_volume_libnotify() {
        local vol=$1 icon=$2 summary=$3 body=${*:4}
        local args=('-t' "$EXPIRES")
        local hints=(
            'string:synchronous:volume'                     # Replace previous notification in some notification servers
            'string:x-canonical-private-synchronous:volume' # Replace previous notification in NotifyOSD
        )
        local executable

        # Add progress hint if we're not drawing our own (if supported)
        $SHOW_VOLUME_PROGRESS || hints+=( "int:value:$vol" )

        # Load notification server capabilities if not already loaded
        [[ ${#NOTIFY_CAPS[@]} -lt 1 ]] && load_notify_server_caps

        # Add icon hints if supported
        if has_capability icon-static || has_capability icon-multi; then
            args+=( '-i' "$icon" )
            hints+=( "string:image-path:$icon" ) # For linux_notification_center, supports string:image-path instead of -i|--icon
        fi

        # Add sound hint if sound is enabled and supported
        $PLAY_SOUND && has_capability sound && hints+=( "string:sound-name:audio-volume-change" )

        # Dunst-specific options
        if [[ $NOTIFICATION_METHOD == "dunst" ]]; then
            hints+=( "string:x-dunst-stack-tag:volume" )
            if ! isset NO_NOTIFY_COLOR; then
                local color
                if is_muted; then color=$COLOR_MUTED; else color=$(volume_color "$vol"); fi
                hints+=( "string:fgcolor:$color" )
            fi
        fi

        # Determine executable and additional arguments
        if $USE_DUNSTIFY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}dunstify"
            args+=( '-r' 1000 )

            # Transient notifications will bypass the idle_threshold setting.
            # Should be boolean, but Notify-OSD doesn't support boolean yet. Dunst checks
            # for int and bool with transient so use what works with both servers.
            hints+=( "int:transient:1" )
        elif isset USE_NOTIFY_SEND_PY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send.py"
            args+=( --replaces-process volume ) # Replaces previous notification, but leaves itself running in the bg to work
            hints+=( "boolean:transient:true" ) # By-pass the server's persistence capability, if it should exist
            hints=( "${hints[@]/#/--hint }" ) # Prefix all hints with --hint to work with notify-send.py
        else
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send"
        fi

        command_exists "$executable" || { error "$executable not found. Please install it or set NOTIFY_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        read -ra hints <<< "${hints[@]/#/-h }"
        "$executable" "${hints[@]}" "${args[@]}" "$summary" "$body" &
    }

    notify_volume_xosd() {
        local vol=$1 text=${*:2}
        local executable="${XOSD_PATH:+${XOSD_PATH%/}/}osd_cat"
        local percentage
        local color

        if is_muted; then percentage=0; color=$COLOR_MUTED
        else percentage=$vol; color=$(volume_color "$vol"); fi

        command_exists "$executable" || { error "$executable not found. Please install it or set XOSD_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        "$executable" --align center -b percentage -P "$percentage" -d "$(ms_to_secs "$EXPIRES")" -p top -A center -c "$color" -T "$text" -O 2 -u "$COLOR_XOSD_OUTLINE" & disown
    }

    # Note: a patch with a notify-send script for herbe, not in the current version at this
    #       time but would make this irrelevant. See https://github.com/dudik/herbe/pull/10
    notify_volume_herbe() {
        local -r text=$*
        local executable="${HERBE_PATH:+${HERBE_PATH%/}/}herbe"

        command_exists "$executable" || { error "$executable not found. Please install it or set HERBE_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        pkill -SIGUSR1 herbe # Dismiss existing/pending notifications to prevent queuing
        "$executable" "$text" & disown
    }

    notify_volume_volnoti() {
        local -r vol=$1
        local executable="${VOLNOTI_PATH:+${VOLNOTI_PATH%/}/}volnoti-show"

        command_exists "$executable" || { error "$executable not found. Please install it or set VOLNOTI_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        if is_muted; then "$executable" -m "$vol"
        else "$executable" "$vol"; fi
    }

    notify_volume_kosd() {
        local -r vol=$1
        local muted
        if is_muted; then muted=1; else muted=0; fi
        qdbus org.kde.kded /modules/kosd showVolume "$vol" "$muted"
    }
}

define_output_formats() {
    output_volume_default() { if is_muted; then echo MUTE; else echo "$(get_volume)%"; fi }

    # Format options:
    #   %v = volume percentage or "MUTE" when muted
    #   %n = node display name/alias
    #   %d = node id
    #   %p = volume progress bar
    #   %i = volume icon
    output_volume_custom() {
        local -r vol=$(get_volume)
        local -r format=${1//\%v/$vol%}
        local string=${format//\%n/$(get_node_display_name)}
        string=${string//\%d/$NODE_ID}
        string=${string//\%p/$(progress_bar "$vol")}
        string=${string//\%i/$(get_volume_emoji "$vol")}

        # Replace %m with microphone volume
        if [[ $string == *%m* ]]; then
            local mic_vol
            if is_mic_muted 2>/dev/null; then
                mic_vol="MUTED"
            else
                mic_vol=$(get_mic_volume 2>/dev/null || echo "N/A")
                mic_vol="${mic_vol}%"
            fi
            string=${string//%m/$mic_vol}
        fi

        if is_muted; then echo -ne "${string//\%v/MUTED}"
        else echo -ne "$string"; fi
    }

    output_volume_i3blocks() {
        local -r name=$(get_node_display_name)
        local short_text

        if is_muted; then
            short_text="<span color=\"$COLOR_MUTED\">MUTED</span>\n"
        else
            local -r vol=$(get_volume)
            short_text="<span color=\"$(volume_color "$vol")\">${vol}%</span>\n"
            isset MAX_VOL && (( vol > MAX_VOL )) && EXITCODE=$EX_URGENT
        fi

        local full_text=${short_text}
        not_empty "$name" && full_text="<span color=\"$COLOR_TEXT\">$name</span> $short_text"

        echo -ne "$full_text$short_text"
    }

    output_volume_xob() { echo "$(get_volume)$(is_muted && echo "!")"; }
}

define_commands() {
    set_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        if not_empty "$MAX_VOL"; then
            case "$op" in
                +)  # Increase volume
                    local -r curr_vol=$(get_volume)
                    if (( curr_vol + vol > MAX_VOL )); then
                        # Instead of doing nothing, step to max_volume
                        local -r step=$( max "0" "$(( MAX_VOL - curr_vol ))" )
                        wpctl set-volume "$NODE_ID" "$step%+"
                        return
                    fi
                    ;;
                *)  # Set absolute volume
                    if (( vol > MAX_VOL )); then
                        return
                    fi
                    ;;
            esac
        fi

        invalidate_cache

        case "$op" in
            +) wpctl set-volume "$NODE_ID" "${vol}%+" ;;
            -) wpctl set-volume "$NODE_ID" "${vol}%-" ;;
            *) wpctl set-volume "$NODE_ID" "${vol}%" ;;
        esac
    }

    increase_volume() { set_volume "${1:?$(error 'Step is required')}" "+"; }
    decrease_volume() { set_volume "${1:?$(error 'Step is required')}" "-"; }
    toggle_mute() { invalidate_cache; wpctl set-mute "$NODE_ID" toggle; }

    set_mic_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error "No audio source available."
            return 1
        fi

        invalidate_cache

        case "$op" in
            +) wpctl set-volume "$SOURCE_ID" "${vol}%+" ;;
            -) wpctl set-volume "$SOURCE_ID" "${vol}%-" ;;
            *) wpctl set-volume "$SOURCE_ID" "${vol}%" ;;
        esac
    }

    increase_mic_volume() { set_mic_volume "${1:?$(error 'Step is required')}" "+"; }
    decrease_mic_volume() { set_mic_volume "${1:?$(error 'Step is required')}" "-"; }
    toggle_mic_mute() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error "No audio source available."
            return 1
        fi

        invalidate_cache
        wpctl set-mute "$SOURCE_ID" toggle
    }

    show_mic_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_mic
    }

    output_volume() {
        local -r for=${1:?$(error 'Output method is required')}

        case "$for" in
            i3blocks ) output_volume_i3blocks ;;
            xob      ) output_volume_xob ;;
            default  ) output_volume_default ;;
            *        ) output_volume_custom "$*" ;;
        esac
    }

    list_output_formats() { awk 'match($0,/ +output_volume_([[:alnum:]]+)\(\)/) {print substr($0, RSTART + 18, RLENGTH - 20)}' "${BASH_SOURCE[0]}" || EXITCODE=$EX_USAGE; }

    list_sinks() {
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sinks[@]} -eq 0 ]]; then
            error "No audio sinks found."
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sinks:${COLOR_RESET}"
        echo

        local sink_id sink_name sink_nick vol muted is_default
        for sink in "${sinks[@]}"; do
            IFS='|' read -r sink_id sink_name sink_nick <<< "$sink"

            # Get volume and mute status
            vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default sink
            if [[ "$sink_name" == "$default_sink_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$sink_nick"
            if isset NODE_ALIASES["$sink_id"]; then
                display_name="${NODE_ALIASES[$sink_id]}"
            elif isset NODE_ALIASES["$sink_name"]; then
                display_name="${NODE_ALIASES[$sink_name]}"
            elif isset NODE_ALIASES["$sink_nick"]; then
                display_name="${NODE_ALIASES[$sink_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$sink_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($sink_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default sink"
    }

    list_sources() {
        local default_source_name
        default_source_name=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sources
        readarray -t sources < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Source") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sources[@]} -eq 0 ]]; then
            error "No audio sources found."
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sources:${COLOR_RESET}"
        echo

        local source_id source_name source_nick vol muted is_default
        for source in "${sources[@]}"; do
            IFS='|' read -r source_id source_name source_nick <<< "$source"

            # Get volume and mute status
            vol=$(wpctl get-volume "$source_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$source_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default source
            if [[ "$source_name" == "$default_source_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$source_nick"
            if isset NODE_ALIASES["$source_id"]; then
                display_name="${NODE_ALIASES[$source_id]}"
            elif isset NODE_ALIASES["$source_name"]; then
                display_name="${NODE_ALIASES[$source_name]}"
            elif isset NODE_ALIASES["$source_nick"]; then
                display_name="${NODE_ALIASES[$source_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$source_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($source_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default source"
    }

    list_ports() {
        if empty "$NODE_ID"; then
            error "No sink specified. Use -s <sink> or ensure default sink is available."
            return 1
        fi

        local sink_display_name
        sink_display_name=$(get_node_display_name)

        echo "${COLOR_YELLOW}Ports for sink: ${COLOR_GREEN}$sink_display_name${COLOR_RESET} (ID: ${COLOR_CYAN}$NODE_ID${COLOR_RESET})"
        echo

        # Try to get ports from PropInfo first
        local ports
        readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | "\(.id)|\(.name)|\(.description // "N/A")"' 2>/dev/null)

        # If no ports found via PropInfo, try alternative method using node properties
        if [[ ${#ports[@]} -eq 0 ]]; then
            readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props | to_entries[] | select(.key | test("port\\..*")) | "\(.key)|\(.value)"' 2>/dev/null)
        fi

        if [[ ${#ports[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No ports found for this sink.${COLOR_RESET}"
            echo "This sink may not support port switching, or port information is not available."
            echo "Try using ${COLOR_GREEN}wpctl status${COLOR_RESET} for more information."
            return 0
        fi

        # Get active port
        local active_port
        active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        # If no active port from PropInfo, try node properties
        if empty "$active_port"; then
            active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
        fi

        local port_id port_name port_desc is_active
        for port in "${ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc <<< "$port"

            # Handle different port formats
            if [[ -z "$port_desc" || "$port_desc" == "N/A" ]]; then
                port_desc="$port_name"
            fi

            if [[ "$port_id" == "$active_port" || "$port_name" == "$active_port" ]]; then
                is_active="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_active="  "
            fi

            printf "%s${COLOR_CYAN}%s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_active" "$port_id" "$port_desc"
            if [[ -n "$port_name" && "$port_name" != "$port_desc" ]]; then
                echo "  ${COLOR_MAGENTA}($port_name)${COLOR_RESET}"
            else
                echo
            fi
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = active port"
    }

    list() {
        local -r type=${1:-}

        case "$type" in
            sinks|sink)
                list_sinks
                ;;
            sources|source)
                list_sources
                ;;
            ports|port)
                list_ports
                ;;
            "")
                error "List type required. Use: list sinks|sources|ports"
                echo "  ${COLOR_GREEN}list sinks${COLOR_RESET}    - list all audio output sinks"
                echo "  ${COLOR_GREEN}list sources${COLOR_RESET} - list all audio input sources"
                echo "  ${COLOR_GREEN}list ports${COLOR_RESET}    - list ports for current sink"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                error "Unknown list type: $type"
                echo "Valid types: sinks, sources, ports"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_all_sinks() {
        # Returns array of sink IDs
        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | .id' 2>/dev/null)
        echo "${sinks[@]}"
    }

    get_default_sink_id() {
        # Returns the ID of the current default sink
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
        pw_dump | jq -r --arg name "$default_sink_name" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == $name) | .id' 2>/dev/null
    }

    get_sink_display_name_by_id() {
        local -r sink_id=$1
        local sink_name sink_nick display_name

        sink_name=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
        sink_nick=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.nick" // "N/A"' 2>/dev/null)

        # Apply alias if available
        display_name="$sink_nick"
        if isset NODE_ALIASES["$sink_id"]; then
            display_name="${NODE_ALIASES[$sink_id]}"
        elif isset NODE_ALIASES["$sink_name"]; then
            display_name="${NODE_ALIASES[$sink_name]}"
        elif isset NODE_ALIASES["$sink_nick"]; then
            display_name="${NODE_ALIASES[$sink_nick]}"
        fi

        echo "$display_name"
    }

    find_sink_by_name_or_id() {
        # Find sink by ID, name, nick, or alias
        local -r search=$1
        local sink_id sink_name sink_nick

        # Try as ID first
        sink_id=$(pw_dump | jq -r --argjson id "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .id == ($id | tonumber? // empty)) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as name
        sink_id=$(pw_dump | jq -r --arg name "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.name" == $name) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as nick
        sink_id=$(pw_dump | jq -r --arg nick "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.nick" == $nick) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as alias
        local alias_key
        for alias_key in "${!NODE_ALIASES[@]}"; do
            if [[ "${NODE_ALIASES[$alias_key]}" == "$search" ]]; then
                # Found alias, now find the sink
                sink_id=$(pw_dump | jq -r --arg key "$alias_key" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and (.id == ($key | tonumber? // empty) or .info.props."node.name" == $key or .info.props."node.nick" == $key)) | .id' 2>/dev/null)
                if not_empty "$sink_id"; then
                    echo "$sink_id"
                    return 0
                fi
            fi
        done

        return 1
    }

    switch_sink() {
        local target_sink_id target_sink_name
        local -r target=${1:-}

        # Get all available sinks
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error "No audio sinks found."
            return 1
        fi

        if [[ ${#all_sinks[@]} -eq 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        # If no target specified, cycle to next sink
        if empty "$target"; then
            local current_sink_id
            current_sink_id=$(get_default_sink_id)

            if empty "$current_sink_id"; then
                error "Could not determine current default sink."
                return 1
            fi

            # Find current sink index
            local idx=0
            local found=false
            for sink in "${all_sinks[@]}"; do
                if [[ "$sink" == "$current_sink_id" ]]; then
                    found=true
                    break
                fi
                ((idx++))
            done

            if ! $found; then
                error "Current sink not found in available sinks."
                return 1
            fi

            # Move to next sink (wrap around)
            idx=$(( (idx + 1) % ${#all_sinks[@]} ))
            target_sink_id="${all_sinks[$idx]}"
        else
            # Find sink by name, ID, or alias
            target_sink_id=$(find_sink_by_name_or_id "$target")

            if empty "$target_sink_id"; then
                error "Sink not found: $target"
                echo "Use 'volume list sinks' to see available sinks."
                return 1
            fi

            # Check if it's already the default
            local current_sink_id
            current_sink_id=$(get_default_sink_id)
            if [[ "$target_sink_id" == "$current_sink_id" ]]; then
                echo "Sink is already the default."
                return 0
            fi
        fi

        # Switch to the target sink
        if ! wpctl set-default "$target_sink_id" &>/dev/null; then
            error "Failed to switch to sink ID $target_sink_id"
            return 1
        fi

        # Get display name and volume for notification
        target_sink_name=$(get_sink_display_name_by_id "$target_sink_id")
        local target_vol target_muted
        target_vol=$(wpctl get-volume "$target_sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
        target_muted=$(wpctl get-volume "$target_sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)

        # Invalidate cache and reinitialize audio
        invalidate_cache

        # Update NODE_ID and NODE_NAME to the new sink for potential future use
        NODE_ID="$target_sink_id"
        NODE_NAME=$(pw_dump | jq -r --argjson id "$target_sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)

        # Show notification if enabled
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            if $target_muted; then
                icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
                summary="Switched to: $target_sink_name (MUTED)"
            else
                icon=$(get_volume_icon "$target_vol")
                printf -v summary "Switched to: %s (%s%%)" "$target_sink_name" "$target_vol"
            fi

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd "$target_vol" "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti "$target_vol" ;;
                kosd    ) notify_volume_kosd "$target_vol" ;;
                *       ) notify_volume_libnotify "$target_vol" "$icon" "$summary" "" ;;
            esac
        else
            if $target_muted; then
                echo "Switched to: $target_sink_name (MUTED, ${target_vol}%)"
            else
                echo "Switched to: $target_sink_name (${target_vol}%)"
            fi
        fi

        # Update statusbar if configured
        update_statusbar || true
    }

    next_sink() { switch_sink; }
    prev_sink() {
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -le 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        local current_sink_id
        current_sink_id=$(get_default_sink_id)

        if empty "$current_sink_id"; then
            error "Could not determine current default sink."
            return 1
        fi

        # Find current sink index
        local idx=0
        local found=false
        for sink in "${all_sinks[@]}"; do
            if [[ "$sink" == "$current_sink_id" ]]; then
                found=true
                break
            fi
            ((idx++))
        done

        if ! $found; then
            error "Current sink not found in available sinks."
            return 1
        fi

        # Move to previous sink (wrap around)
        idx=$(( (idx - 1 + ${#all_sinks[@]}) % ${#all_sinks[@]} ))
        local target_sink_id="${all_sinks[$idx]}"

        # Switch using the main function
        switch_sink "$target_sink_id"
    }

    usage() {
        cat <<- EOF 1>&2
${COLOR_YELLOW}Usage:${COLOR_RESET} $0 [<options>] <command> [<args>]
Control volume and related notifications.

${COLOR_YELLOW}Commands:${COLOR_RESET}
  ${COLOR_GREEN}up <value>${COLOR_RESET}                  increase volume
  ${COLOR_GREEN}down <value>${COLOR_RESET}                decrease volume
  ${COLOR_GREEN}set <value>${COLOR_RESET}                 set volume
  ${COLOR_GREEN}mute${COLOR_RESET}                        toggle mute
  ${COLOR_GREEN}mic <cmd> [value]${COLOR_RESET}           control microphone
                              commands:
                                  up <value>    - increase microphone volume
                                  down <value>  - decrease microphone volume
                                  set <value>   - set microphone volume
                                  mute          - toggle microphone mute
  ${COLOR_GREEN}listen${COLOR_RESET}                      monitor volume changes on a sink
  ${COLOR_GREEN}list <type>${COLOR_RESET}                 list sinks, sources, or ports
                              types:
                                  sinks   - list all audio output sinks
                                  sources - list all audio input sources
                                  ports   - list ports for current sink
  ${COLOR_GREEN}switch [sink]${COLOR_RESET}               switch to next sink or specified sink
  ${COLOR_GREEN}next${COLOR_RESET}                        switch to next sink
  ${COLOR_GREEN}prev${COLOR_RESET}                        switch to previous sink
  ${COLOR_GREEN}output <format>${COLOR_RESET}             display volume in a custom format
                              format placeholders:
                                  %v = volume
                                  %s = sink name
                                  %p = volume progress bar
                                  %i = volume icon/emoji
                                  %P = active port description
                                  %m = microphone volume

                                  examples:
                                      "Volume is %v" = Volume is 50%
                                      "%i %v %p \n"  = 奔 50% ██████████
  ${COLOR_GREEN}outputs${COLOR_RESET}                     show supported output formats
  ${COLOR_GREEN}notifications${COLOR_RESET}               list notification methods
  ${COLOR_GREEN}help${COLOR_RESET}                        show help

${COLOR_YELLOW}Options:${COLOR_RESET}
  ${COLOR_GREEN}-n${COLOR_RESET}                          enable notifications
  ${COLOR_GREEN}-C${COLOR_RESET}                          play event sounds using libcanberra
  ${COLOR_GREEN}-P${COLOR_RESET}                          play sound for volume changes
  ${COLOR_GREEN}-j <muted,high,low,medium>${COLOR_RESET}  custom volume emojis
  ${COLOR_GREEN}-s <sink>${COLOR_RESET}                   specify sink (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SINK@${COLOR_RESET})
  ${COLOR_GREEN}-I <source>${COLOR_RESET}                 specify input source (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SOURCE@${COLOR_RESET})
  ${COLOR_GREEN}-t <process_name>${COLOR_RESET}           status bar process name (${COLOR_MAGENTA}requires -u${COLOR_RESET})
  ${COLOR_GREEN}-A <node.nick:alias>${COLOR_RESET}        alias a node nick (e.g., -A "ALC287 Analog:Speakers")
  ${COLOR_GREEN}-u <signal>${COLOR_RESET}                 signal to update status bar (${COLOR_MAGENTA}requires -t${COLOR_RESET})
  ${COLOR_GREEN}-x <value>${COLOR_RESET}                  set maximum volume
  ${COLOR_GREEN}-h${COLOR_RESET}                          show help

${COLOR_YELLOW}Notification Options:${COLOR_RESET}
  ${COLOR_GREEN}-N <method>${COLOR_RESET}                 notification method (${COLOR_MAGENTA}default: libnotify${COLOR_RESET})
  ${COLOR_GREEN}-p${COLOR_RESET}                          enable progress bar in notifications
  ${COLOR_GREEN}-L <placement>${COLOR_RESET}              progress bar placement (${COLOR_MAGENTA}default: summary${COLOR_RESET}; ${COLOR_MAGENTA}requires -p${COLOR_RESET})
                              placements:
                                  body
                                  summary
  ${COLOR_GREEN}-e <ms>${COLOR_RESET}                     notification expiration time
  ${COLOR_GREEN}-l${COLOR_RESET}                          use full-color icons
  ${COLOR_GREEN}-S <suffix>${COLOR_RESET}                 add suffix to symbolic icon names
  ${COLOR_GREEN}-y${COLOR_RESET}                          use dunstify (${COLOR_MAGENTA}default: notify-send${COLOR_RESET})

${COLOR_YELLOW}Environment Variables:${COLOR_RESET}
  ${COLOR_CYAN}XOSD_PATH${COLOR_RESET}                   path to osd_cat
  ${COLOR_CYAN}HERBE_PATH${COLOR_RESET}                  path to herbe
  ${COLOR_CYAN}VOLNOTI_PATH${COLOR_RESET}                path to volnoti-show
  ${COLOR_CYAN}CANBERRA_PATH${COLOR_RESET}               path to canberra-gtk-play
  ${COLOR_CYAN}NOTIFY_PATH${COLOR_RESET}                 path to command that sends notifications
  ${COLOR_CYAN}NO_NOTIFY_COLOR${COLOR_RESET}             flag to disable colors in notifications
  ${COLOR_CYAN}USE_NOTIFY_SEND_PY${COLOR_RESET}          flag to use notify-send.py instead of notify-send
EOF
        exit "$EX_USAGE"
    }
}

get_volume() { wpctl get-volume "$NODE_ID" | awk '{print $2 * 100}'; }
is_muted() { wpctl get-volume "$NODE_ID" | grep -q '\[MUTED\]'; }

get_mic_volume() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | awk '{print $2 * 100}'
}

is_mic_muted() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | grep -q '\[MUTED\]'
}

get_volume_icon() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if $USE_FULLCOLOR_ICONS; then
        if (( vol >= 70 )); then icon=${ICONS[1]}
        elif (( vol >= 40 )); then icon=${ICONS[3]}
        elif (( vol > 0 )); then icon=${ICONS[2]}
        else icon=${ICONS[2]}
        fi
    else
        # Get overamplified icon if available, otherwise default to high volume icon
        if (( vol > 100 )); then icon=${ICONS_SYMBOLIC[4]:-${ICONS_SYMBOLIC[1]}}
        elif (( vol >= 70 )); then icon=${ICONS_SYMBOLIC[1]}
        elif (( vol >= 40 )); then icon=${ICONS_SYMBOLIC[3]}
        elif (( vol > 0 )); then icon=${ICONS_SYMBOLIC[2]}
        else icon=${ICONS_SYMBOLIC[2]}
        fi
    fi

    echo "$icon"
}

get_volume_emoji() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if is_muted; then icon=${ICONS_EMOJI[0]}
    else
        if (( vol >= 70 )); then icon=${ICONS_EMOJI[1]}
        elif (( vol >= 40 )); then icon=${ICONS_EMOJI[3]}
        elif (( vol > 0 )); then icon=${ICONS_EMOJI[2]}
        else icon=${ICONS_EMOJI[2]}
        fi
    fi
    echo "$icon"
}

update_statusline() {
    local signal=${1:?$(error 'Signal is required')}
    local proc=${2:?$(error 'Process name is required')}
    pkill "-$signal" "$proc"
}

progress_bar() {
    local percent=${1:?$(error 'Percentage is required')}
    local -i max_percent=${2:-100}
    local -i bar_length=${3:-20}

    # Clamp the percentage to be within 0 and max_percent
    (( percent = percent < 0 ? 0 : (percent > max_percent ? max_percent : percent) ))

    local filled_blocks=$(( percent * bar_length / max_percent ))
    local empty_blocks=$(( bar_length - filled_blocks ))
    local bar; printf -v bar "%${filled_blocks}s" ''
    local empty; printf -v empty "%${empty_blocks}s" ''

    echo "${bar// /█}${empty// /░}"
}

apply_symbolic_icon_suffix() { for i in "${!ICONS_SYMBOLIC[@]}"; do ICONS_SYMBOLIC[i]="${ICONS_SYMBOLIC[i]}${SYMBOLIC_ICON_SUFFIX}"; done; }

volume_color() {
    local -ir vol=${1:?$(error 'A volume is required')}
    if (( vol >= MIN_VOL && vol < DEFAULT_VOL )); then echo "$COLOR_MIN_TO_DEFAULT";
    elif (( vol == 100 )); then echo "$COLOR_FULL";
    elif (( vol > 100 && vol <= MAX_VOL )); then echo "$COLOR_FULL_TO_MAX";
    else echo "$COLOR_OTHER";
    fi
}

# Returns
#   0 when both signal and statusline are set
#   1 when one of signal or statusline are set but not both
update_statusbar() {
    if not_empty "$SIGNAL" && empty "$STATUSLINE"; then return 1; fi
    if not_empty "$SIGNAL"; then update_statusline "$SIGNAL" "$STATUSLINE";
    elif not_empty "$STATUSLINE"; then return 1; fi
    return 0
}

init_audio() {
    if empty "$NODE_NAME"; then
        NODE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SINK@ | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    NODE_ID=$(get_node_id)
    NODE_NICK=$(get_node_nick)
    DEFAULT_VOL=$(get_default_volume)
    MIN_VOL=$(get_min_volume)
    MAX_VOL=$(get_max_volume)
}

init_source() {
    if empty "$SOURCE_NAME"; then
        SOURCE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    SOURCE_ID=$(get_source_id)
    # shellcheck disable=SC2034  # SOURCE_NICK may be used in future features
    SOURCE_NICK=$(get_source_nick)
}

get_node_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$NODE_NAME"'") | .id'; }
get_node_nick() { pw_dump | jq -r '.[] | select(.id == '"$NODE_ID"') | .info.props."node.nick"'; }

get_source_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$SOURCE_NAME"'") | .id'; }
get_source_nick() { pw_dump | jq -r '.[] | select(.id == '"$SOURCE_ID"') | .info.props."node.nick"'; }

get_node_display_name() {
    if isset NODE_ALIASES["$NODE_ID"]; then echo "${NODE_ALIASES[$NODE_ID]}"
    elif isset NODE_ALIASES["$NODE_NAME"]; then echo "${NODE_ALIASES[$NODE_NAME]}"
    elif isset NODE_ALIASES["$NODE_NICK"]; then echo "${NODE_ALIASES[$NODE_NICK]}"
    else get_node_nick
    fi
}

# get_node_name_by_id() {
#     local -r id=${1:?$(error 'Node ID is required')}
#     wpctl inspect "$id" | jq -r '.info.props."node.name"'
# }

# dump_node() {
#     local -r name=${1:?$(error 'Node name is required')}
#     pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$name"'")'
# }

pw_dump() {
    if [[ $COMMAND == "listen" ]] || empty "$PW_DUMP"; then PW_DUMP=$(pw-dump); fi
    echo "$PW_DUMP"
}

invalidate_cache() { PW_DUMP=""; }

# Listens for PipeWire events
#
# Arguments:
#   Output    (optional) (string) An output mode. When set, outputs volume in the output mode format.
listen() {
    local -r output=$*

    # Output volume so status bars have something to display before any event occurs
    not_empty "$output" && output_volume "$output"

    # Monitor events and filter for the sink ID
    pw-cli subscribe | stdbuf -oL grep -F "object.id = $NODE_ID" | while IFS= read -r; do
        show_volume_notification
        update_statusbar
        play_volume_changed
        not_empty "$output" && output_volume "$output"
    done
}

pw_play() {
    command_exists pw-play || { error "pw-play is not installed or not in \$PATH"; return 1; }
    pw-play --target "$NODE_ID" "$1" &
}

get_volume_info() {
    local -r type=${1:?$(error 'Volume type (default/min/max) is required')}
    local vol
    vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "volume") | .type.'"$type"'' 2>/dev/null)

    empty "$vol" && { echo "Error: $type volume information not found for NODE_ID=$NODE_ID" >&2; return 1; }
    echo "$vol" | awk '{print $1 * 100}'
}

get_default_volume() { get_volume_info "default"; }
get_min_volume() { get_volume_info "min"; }
get_max_volume() { get_volume_info "max"; }

init_color() {
    has_color && {
        COLOR_RESET=$'\033[0m'
        COLOR_RED=$'\033[0;31m'
        COLOR_GREEN=$'\033[0;32m'
        COLOR_YELLOW=$'\033[0;33m'
        COLOR_MAGENTA=$'\033[0;35m'
        COLOR_CYAN=$'\033[0;36m'
    }
}

load_config() {
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    # shellcheck source=/dev/null
    [[ -f $config ]] && source "$config"

    # Set defaults if not defined in config
    : "${NOTIFICATION_METHOD:=libnotify}"
}

# Rearrange all options to place flags first
# Author: greycat
# URL: https://mywiki.wooledge.org/ComplexOptionParsing
arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=:A:Ce:hj:lL:nN:pPs:S:t:u:yI:

    arrange_opts "$optstring" "$@"
    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            A    ) IFS=: read -r node alias <<< "$OPTARG"
                   NODE_ALIASES[$node]=$alias ;;
            C    ) USE_CANBERRA=true ;;
            e    ) EXPIRES=$OPTARG ;;
            j    ) IFS=, read -ra ICONS_EMOJI <<< "$OPTARG" ;;
            l    ) USE_FULLCOLOR_ICONS=true ;;
            L    ) PROGRESS_PLACEMENT=$OPTARG ;;
            n    ) DISPLAY_NOTIFICATIONS=true ;;
            N    ) NOTIFICATION_METHOD=$OPTARG ;;
            p    ) SHOW_VOLUME_PROGRESS=true ;;
            P    ) PLAY_SOUND=true ;;
            s    ) NODE_NAME=$OPTARG ;;
            S    ) SYMBOLIC_ICON_SUFFIX=$OPTARG ;;
            t    ) STATUSLINE=$OPTARG ;;
            u    ) SIGNAL=$OPTARG ;;
            I    ) SOURCE_NAME=$OPTARG ;;
            y    ) USE_DUNSTIFY=true ;;
            h | *) usage ;;
        esac
    done

    read -ra CMDARGS <<< "${OPTARR[@]:$((OPTIND-1))}"
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    case "$COMMAND" in
        up|raise|increase)
            case "$#" in 1) ;; *) usage ;; esac
            increase_volume "$1"
            ;;
        down|lower|decrease)
            case "$#" in 1) ;; *) usage ;; esac
            decrease_volume "$1"
            ;;
        set)
            case "$#" in 1) ;; *) usage ;; esac
            case "$1" in
                +*) increase_volume "${1:1}" ;;
                -*) decrease_volume "${1:1}" ;;
                *) set_volume "$1" ;;
            esac
            ;;
        mute) toggle_mute ;;
        mic)
            case "$#" in
                0) usage ;;
                1)
                    case "$1" in
                        mute) toggle_mic_mute ;;
                        *) usage ;;
                    esac
                    ;;
                2)
                    case "$1" in
                        up|raise|increase) increase_mic_volume "$2" ;;
                        down|lower|decrease) decrease_mic_volume "$2" ;;
                        set)
                            case "$2" in
                                +*) increase_mic_volume "${2:1}" ;;
                                -*) decrease_mic_volume "${2:1}" ;;
                                *) set_mic_volume "$2" ;;
                            esac
                            ;;
                        *) usage ;;
                    esac
                    ;;
                *) usage ;;
            esac
            ;;
        listen) listen "$*" ;;
        list)
            case "$#" in
                0) list "" ;;
                1) list "$1" ;;
                *) usage ;;
            esac
            ;;
        switch)
            case "$#" in
                0) switch_sink ;;
                1) switch_sink "$1" ;;
                *) usage ;;
            esac
            ;;
        next) next_sink ;;
        prev|previous) prev_sink ;;
        output)
            case "$#" in 0) usage ;; esac
            output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        outputs) list_output_formats ;;
        notifications) list_notification_methods ;;
        *) usage ;;
    esac
}

play_volume_changed() {
    $PLAY_SOUND || return

    # Sound can be handled by the notification method
    if $DISPLAY_NOTIFICATIONS && has_capability sound; then return; fi

    if $USE_CANBERRA; then ca_play "$SOUND_VOLUME_CHANGED" "Volume Changed"
    else pw_play "$SOUND_VOLUME_CHANGED"; fi
}

ca_play() {
    local -r file=$1 desc=$2
    local executable="${CANBERRA_PATH:+${CANBERRA_PATH%/}/}canberra-gtk-play"

    command_exists "$executable" || { error "$executable not found. Please install it or set CANBERRA_PATH to the correct path."; return 1; }

    if [[ -f $file ]]; then "$executable" -f "$file" -d "$desc"
    else "$executable" -i "audio-volume-change" -d "$desc"
    fi
}

post_command_hook() {
    if is_command_hookable "$COMMAND"; then
        # Check if this was a mic command
        if [[ $COMMAND == "mic" ]]; then
            show_mic_notification
            play_volume_changed
            update_statusbar || usage
        else
            show_volume_notification
            play_volume_changed
            update_statusbar || usage
        fi
    fi
}

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Commands which will not use post_command_hook(), usually because
    # they handle notifications and/or statusbar updates manually
    declare -a POST_HOOK_EXEMPT_COMMANDS=(
        listen
        notifications
        outputs
        list
        switch
        next
        prev
    )

    # Exit codes
    declare -ir EX_OK=0 EX_URGENT=33 EX_USAGE=64 EX_UNAVAILABLE=69

    # Main program exit code
    declare -i EXITCODE=$EX_OK

    # Standard notification icons. Usually full color
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS=(
        audio-volume-muted
        audio-volume-high
        audio-volume-low
        audio-volume-medium
    )

    # Symbolic notification icons. Usually low color or monochrome
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS_SYMBOLIC=(
        audio-volume-muted-symbolic
        audio-volume-high-symbolic
        audio-volume-low-symbolic
        audio-volume-medium-symbolic
        ## Only exists in some icon sets
        # audio-volume-overamplified-symbolic
    )

    # Emoji-based icons.
    declare -a ICONS_EMOJI=( ﱝ 墳 奄 奔 )

    # Volume changed sound.
    declare SOUND_VOLUME_CHANGED=${SOUND_VOLUME_CHANGED:-/usr/share/sounds/freedesktop/stereo/audio-volume-change.oga}

    # DBUS constants
    declare -r \
        DBUS_NAME=org.freedesktop.Notifications \
        DBUS_PATH=/org/freedesktop/Notifications \
        DBUS_IFAC_FDN=org.freedesktop.Notifications

    # Notification server information
    declare \
        NOTIFY_SERVER
        # NOTIFY_VENDOR \
        # NOTIFY_VERSION \
        # NOTIFY_SPEC_VERSION

    # Notification capabilities
    declare -a NOTIFY_CAPS=()

    # PipeWire node aliases
    declare -gA NODE_ALIASES=()

    declare -i DEFAULT_VOL=100 MIN_VOL=0 MAX_VOL=100

    # Cached output of `pw-dump`; so we don't have to call it each time we need it
    declare PW_DUMP=""

    # Colors
    declare -r \
        COLOR_MUTED=${COLOR_MUTED:-#FFFF00} \
        COLOR_MIN_TO_DEFAULT=${COLOR_MIN_TO_DEFAULT:-#00FF00} \
        COLOR_FULL=${COLOR_FULL:-#FFFF00} \
        COLOR_FULL_TO_MAX=${COLOR_FULL_TO_MAX:-#FF0000} \
        COLOR_OTHER=${COLOR_OTHER:-#FFFFFF} \
        COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-#222222} \
        COLOR_TEXT=${COLOR_TEXT:-#FFFF00}

    declare COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_MAGENTA COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################
    declare NOTIFICATION_METHOD=""

    declare \
        COMMAND="" \
        DISPLAY_NOTIFICATIONS=false \
        SHOW_VOLUME_PROGRESS=false \
        USE_DUNSTIFY=false \
        USE_FULLCOLOR_ICONS=false \
        PROGRESS_PLACEMENT=summary \
        SIGNAL="" \
        NODE_NAME="" \
        NODE_ID="" \
        SOURCE_NAME="" \
        SOURCE_ID="" \
        STATUSLINE="" \
        SYMBOLIC_ICON_SUFFIX="" \
        PLAY_SOUND=false \
        USE_CANBERRA=false

    declare -i EXPIRES=1500

    define_helpers
    define_notify
    define_output_formats
    define_commands

    init_color

    load_config
    parse_opts "$@"

    # Requires options to be parsed first
    init_audio
    init_source

    exec_command "${CMDARGS[*]}" && post_command_hook

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
