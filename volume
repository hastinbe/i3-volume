#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications.
#
#  Dependencies: awk bc jq WirePlumber
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume
#  Wiki: https://github.com/hastinbe/i3-volume/wiki/

define_helpers() {
    empty() { [[ -z $1 ]]; }
    not_empty() { [[ -n $1 ]]; }
    isset() { [[ -v $1 ]]; }
    command_exists() { command -v "$1" &>/dev/null; }
    error() { echo "$COLOR_RED$*$COLOR_RESET"; }
    has_color() { [ "$(tput colors)" -ge 8 ] &>/dev/null && [ -t 1 ]; }
    ms_to_secs() { echo "scale=0; (${1} + 999) / 1000" | bc; }
    is_command_hookable() { ! [[ ${POST_HOOK_EXEMPT_COMMANDS[*]} =~ $1 ]]; }
    has_capability() { [[ "${NOTIFY_CAPS[*]}" =~ $1 ]]; }
    max() { echo $(( $1 > $2 ? $1 : $2 )); }
}

define_notify() {
    notify_volume() {
        local -r vol=$(get_volume)
        local icon summary body=""
        local boost_info=""

        # Check if boost is active
        if is_boost_active 2>/dev/null; then
            boost_info=" (+${BOOST_AMOUNT}% boost)"
        fi

        if is_muted; then
            summary="Volume muted"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Volume %3s%%%s" "$vol" "$boost_info"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "$body" ;;
        esac
    }

    notify_mic() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            return 1
        fi

        local -r vol=$(get_mic_volume)
        local icon summary body=""

        if is_mic_muted; then
            summary="Microphone muted"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Microphone %3s%%" "$vol"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "$body" ;;
        esac
    }

    list_notification_methods() {
        local source="${BASH_SOURCE[0]}"
        awk -v source="$source" 'match($0, / +notify_volume_([[:alnum:]]+)\(\)/) { print substr($0, RSTART + 18, RLENGTH - 20) }' "$source" || EXITCODE=$EX_USAGE
    }

    setup_notification_icons() { not_empty "$SYMBOLIC_ICON_SUFFIX" && apply_symbolic_icon_suffix; }

    show_volume_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_volume
    }

    load_notify_server_info() {
        command_exists dbus-send || return
        IFS=$'\t' read -r NOTIFY_SERVER _ _ _ < <(dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.GetServerInformation | awk 'BEGIN { ORS="\t" }; match($0, /^   string ".*"/) {print substr($0, RSTART+11, RLENGTH-12)}')
    }

    load_notify_server_caps() {
        command_exists dbus-send || return
        IFS= read -r -d '' -a NOTIFY_CAPS < <(dbus-send --print-reply=literal --dest="${DBUS_NAME}" "${DBUS_PATH}" "${DBUS_IFAC_FDN}.GetCapabilities" | awk 'RS="      " { if (NR > 2) print $1 }')
    }

    notify_volume_libnotify() {
        local vol=$1 icon=$2 summary=$3 body=${*:4}
        local args=('-t' "$EXPIRES")
        local hints=(
            'string:synchronous:volume'                     # Replace previous notification in some notification servers
            'string:x-canonical-private-synchronous:volume' # Replace previous notification in NotifyOSD
        )
        local executable

        # Add progress hint if we're not drawing our own (if supported)
        $SHOW_VOLUME_PROGRESS || hints+=( "int:value:$vol" )

        # Load notification server capabilities if not already loaded
        [[ ${#NOTIFY_CAPS[@]} -lt 1 ]] && load_notify_server_caps

        # Add icon hints if supported
        if has_capability icon-static || has_capability icon-multi; then
            args+=( '-i' "$icon" )
            hints+=( "string:image-path:$icon" ) # For linux_notification_center, supports string:image-path instead of -i|--icon
        fi

        # Add sound hint if sound is enabled and supported
        $PLAY_SOUND && has_capability sound && hints+=( "string:sound-name:audio-volume-change" )

        # Dunst-specific options
        if [[ $NOTIFICATION_METHOD == "dunst" ]]; then
            hints+=( "string:x-dunst-stack-tag:volume" )
            if ! isset NO_NOTIFY_COLOR; then
                local color
                if is_muted; then color=$COLOR_MUTED; else color=$(volume_color "$vol"); fi
                hints+=( "string:fgcolor:$color" )
            fi
        fi

        # Determine executable and additional arguments
        if $USE_DUNSTIFY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}dunstify"
            args+=( '-r' 1000 )

            # Transient notifications will bypass the idle_threshold setting.
            # Should be boolean, but Notify-OSD doesn't support boolean yet. Dunst checks
            # for int and bool with transient so use what works with both servers.
            hints+=( "int:transient:1" )
        elif isset USE_NOTIFY_SEND_PY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send.py"
            args+=( --replaces-process volume ) # Replaces previous notification, but leaves itself running in the bg to work
            hints+=( "boolean:transient:true" ) # By-pass the server's persistence capability, if it should exist
            hints=( "${hints[@]/#/--hint }" ) # Prefix all hints with --hint to work with notify-send.py
        else
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send"
        fi

        command_exists "$executable" || { error "$executable not found. Please install it or set NOTIFY_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        read -ra hints <<< "${hints[@]/#/-h }"
        "$executable" "${hints[@]}" "${args[@]}" "$summary" "$body" &
    }

    notify_volume_xosd() {
        local vol=$1 text=${*:2}
        local executable="${XOSD_PATH:+${XOSD_PATH%/}/}osd_cat"
        local percentage
        local color

        if is_muted; then percentage=0; color=$COLOR_MUTED
        else percentage=$vol; color=$(volume_color "$vol"); fi

        command_exists "$executable" || { error "$executable not found. Please install it or set XOSD_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        "$executable" --align center -b percentage -P "$percentage" -d "$(ms_to_secs "$EXPIRES")" -p top -A center -c "$color" -T "$text" -O 2 -u "$COLOR_XOSD_OUTLINE" & disown
    }

    # Note: a patch with a notify-send script for herbe, not in the current version at this
    #       time but would make this irrelevant. See https://github.com/dudik/herbe/pull/10
    notify_volume_herbe() {
        local -r text=$*
        local executable="${HERBE_PATH:+${HERBE_PATH%/}/}herbe"

        command_exists "$executable" || { error "$executable not found. Please install it or set HERBE_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        pkill -SIGUSR1 herbe # Dismiss existing/pending notifications to prevent queuing
        "$executable" "$text" & disown
    }

    notify_volume_volnoti() {
        local -r vol=$1
        local executable="${VOLNOTI_PATH:+${VOLNOTI_PATH%/}/}volnoti-show"

        command_exists "$executable" || { error "$executable not found. Please install it or set VOLNOTI_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        if is_muted; then "$executable" -m "$vol"
        else "$executable" "$vol"; fi
    }

    notify_volume_kosd() {
        local -r vol=$1
        local muted
        if is_muted; then muted=1; else muted=0; fi
        qdbus org.kde.kded /modules/kosd showVolume "$vol" "$muted"
    }
}

define_output_formats() {
    output_volume_default() { if is_muted; then echo MUTE; else echo "$(get_volume)%"; fi }

    # Format options:
    #   %v = volume percentage or "MUTE" when muted
    #   %n = node display name/alias
    #   %d = node id
    #   %p = volume progress bar
    #   %i = volume icon
    output_volume_custom() {
        local -r vol=$(get_volume)
        local -r format=${1//\%v/$vol%}
        local string=${format//\%n/$(get_node_display_name)}
        string=${string//\%d/$NODE_ID}
        string=${string//\%p/$(progress_bar "$vol")}
        string=${string//\%i/$(get_volume_emoji "$vol")}

        # Replace %m with microphone volume
        if [[ $string == *%m* ]]; then
            local mic_vol
            if is_mic_muted 2>/dev/null; then
                mic_vol="MUTED"
            else
                mic_vol=$(get_mic_volume 2>/dev/null || echo "N/A")
                mic_vol="${mic_vol}%"
            fi
            string=${string//%m/$mic_vol}
        fi

        # Replace %P with active port description
        if [[ $string == *%P* ]]; then
            local port_desc
            port_desc=$(get_active_port_description 2>/dev/null || echo "")
            string=${string//%P/$port_desc}
        fi

        if is_muted; then echo -ne "${string//\%v/MUTED}"
        else echo -ne "$string"; fi
    }

    output_volume_i3blocks() {
        local -r name=$(get_node_display_name)
        local short_text

        if is_muted; then
            short_text="<span color=\"$COLOR_MUTED\">MUTED</span>\n"
        else
            local -r vol=$(get_volume)
            short_text="<span color=\"$(volume_color "$vol")\">${vol}%</span>\n"
            isset MAX_VOL && (( vol > MAX_VOL )) && EXITCODE=$EX_URGENT
        fi

        local full_text=${short_text}
        not_empty "$name" && full_text="<span color=\"$COLOR_TEXT\">$name</span> $short_text"

        echo -ne "$full_text$short_text"
    }

    output_volume_xob() { echo "$(get_volume)$(is_muted && echo "!")"; }
}

define_commands() {
    fade_volume() {
        local -r target_vol=$1
        local -r duration_ms=$2
        local -r node_id=$3
        local -r start_vol=${4:-}  # Optional starting volume
        local current_vol target_vol_int
        local -i steps=50  # Number of steps for smooth fade
        local -i step_delay

        if not_empty "$start_vol"; then
            current_vol=${start_vol%.*}  # Use provided starting volume
        else
            current_vol=$(get_volume)
        fi
        target_vol_int=${target_vol%.*}  # Convert to integer

        # Calculate step delay in milliseconds
        if (( duration_ms > 0 && steps > 0 )); then
            step_delay=$(( duration_ms / steps ))
        else
            step_delay=10  # Default 10ms per step
        fi

        # Calculate volume difference
        local -i vol_diff=$(( target_vol_int - current_vol ))

        if (( vol_diff == 0 )); then
            return 0  # Already at target
        fi

        # Calculate step size
        local -i step_size
        if (( vol_diff > 0 )); then
            step_size=$(( (vol_diff + steps - 1) / steps ))  # Ceiling division
        else
            step_size=$(( (vol_diff - steps + 1) / steps ))  # Floor division
        fi

        # Perform fade
        local -i i
        for (( i = 0; i < steps; i++ )); do
            local -i new_vol=$(( current_vol + step_size * (i + 1) ))

            # Clamp to target
            if (( vol_diff > 0 && new_vol > target_vol_int )); then
                new_vol=$target_vol_int
            elif (( vol_diff < 0 && new_vol < target_vol_int )); then
                new_vol=$target_vol_int
            fi

            # Clamp to valid range
            if (( new_vol < 0 )); then
                new_vol=0
            elif not_empty "$MAX_VOL" && (( new_vol > MAX_VOL )); then
                new_vol=$MAX_VOL
            fi

            wpctl set-volume "$node_id" "${new_vol}%" &>/dev/null

            # Sleep between steps (convert ms to microseconds for usleep, or use sleep)
            if (( i < steps - 1 )); then
                if command -v usleep &>/dev/null; then
                    # usleep takes microseconds
                    usleep $(( step_delay * 1000 )) 2>/dev/null || sleep 0.01
                else
                    # sleep with decimal seconds (bash 4+ supports this)
                    local sleep_time
                    sleep_time=$(awk "BEGIN {printf \"%.3f\", $step_delay / 1000}" 2>/dev/null)
                    if [[ -n "$sleep_time" ]]; then
                        sleep "$sleep_time" 2>/dev/null || sleep 0.01
                    else
                        sleep 0.01
                    fi
                fi
            fi
        done

        # Ensure we end at exact target
        wpctl set-volume "$node_id" "${target_vol_int}%" &>/dev/null
        invalidate_cache
    }

    set_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}
        local target_vol current_vol

        if not_empty "$MAX_VOL"; then
            case "$op" in
                +)  # Increase volume
                    current_vol=$(get_volume)
                    if (( current_vol + vol > MAX_VOL )); then
                        # Instead of doing nothing, step to max_volume
                        local -r step=$( max "0" "$(( MAX_VOL - current_vol ))" )
                        if not_empty "$FADE_DURATION"; then
                            fade_volume "$MAX_VOL" "$FADE_DURATION" "$NODE_ID"
                        else
                            wpctl set-volume "$NODE_ID" "$step%+"
                        fi
                        return
                    fi
                    ;;
                *)  # Set absolute volume
                    if (( vol > MAX_VOL )); then
                        return
                    fi
                    ;;
            esac
        fi

        # Handle fade if requested
        if not_empty "$FADE_DURATION"; then
            case "$op" in
                +)
                    current_vol=$(get_volume)
                    target_vol=$(( current_vol + vol ))
                    fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
                -)
                    current_vol=$(get_volume)
                    target_vol=$(( current_vol - vol ))
                    fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
                *)
                    fade_volume "$vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
            esac
        else
            invalidate_cache
            case "$op" in
                +) wpctl set-volume "$NODE_ID" "${vol}%+" ;;
                -) wpctl set-volume "$NODE_ID" "${vol}%-" ;;
                *) wpctl set-volume "$NODE_ID" "${vol}%" ;;
            esac
        fi
    }

    increase_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_volume "$step" "+"
    }
    decrease_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_volume "$step" "-"
    }
    toggle_mute() {
        if not_empty "$FADE_DURATION"; then
            if is_muted; then
                # Fade in (unmute)
                wpctl set-mute "$NODE_ID" 0
                local current_vol saved_vol
                current_vol=$(get_volume)
                # Try to restore saved volume from before mute
                saved_vol=$(restore_volume_after_mute)
                if not_empty "$saved_vol"; then
                    # Restore to saved volume
                    wpctl set-volume "$NODE_ID" "0%"
                    fade_volume "$saved_vol" "$FADE_DURATION" "$NODE_ID"
                    clear_saved_volume
                elif (( current_vol == 0 )); then
                    # If volume is 0, fade from 0 to a reasonable level
                    fade_volume "${DEFAULT_VOL:-50}" "$FADE_DURATION" "$NODE_ID"
                else
                    # Fade from 0 to current volume
                    wpctl set-volume "$NODE_ID" "0%"
                    fade_volume "$current_vol" "$FADE_DURATION" "$NODE_ID"
                fi
            else
                # Fade out (mute)
                # Ensure device is not muted before starting fade
                wpctl set-mute "$NODE_ID" 0 &>/dev/null
                # Invalidate cache to ensure we get the current volume
                invalidate_cache
                local current_vol
                current_vol=$(get_volume)
                # Save the current volume before muting so we can restore it later
                save_volume_before_mute "$current_vol"
                # Fade down to 0 from current volume
                # Pass current_vol as starting volume to ensure we fade from the correct value
                fade_volume 0 "$FADE_DURATION" "$NODE_ID" "$current_vol"
                # Now that fade is complete, mute the device
                # Set volume to 0 one more time to ensure it's at 0, then mute
                wpctl set-volume "$NODE_ID" "0%" &>/dev/null
                wpctl set-mute "$NODE_ID" 1
                # Some systems restore volume when muting, so set it to 0 again after mute
                wpctl set-volume "$NODE_ID" "0%" &>/dev/null
                invalidate_cache
            fi
        else
            invalidate_cache
            wpctl set-mute "$NODE_ID" toggle
        fi
    }

    set_mic_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error "No audio source available."
            return 1
        fi

        invalidate_cache

        case "$op" in
            +) wpctl set-volume "$SOURCE_ID" "${vol}%+" ;;
            -) wpctl set-volume "$SOURCE_ID" "${vol}%-" ;;
            *) wpctl set-volume "$SOURCE_ID" "${vol}%" ;;
        esac
    }

    increase_mic_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_mic_volume "$step" "+"
    }
    decrease_mic_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_mic_volume "$step" "-"
    }
    toggle_mic_mute() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error "No audio source available."
            return 1
        fi

        invalidate_cache
        wpctl set-mute "$SOURCE_ID" toggle
    }

    show_mic_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_mic
    }

    output_volume() {
        local -r for=${1:?$(error 'Output method is required')}

        case "$for" in
            i3blocks ) output_volume_i3blocks ;;
            xob      ) output_volume_xob ;;
            default  ) output_volume_default ;;
            *        ) output_volume_custom "$*" ;;
        esac
    }

    list_output_formats() { awk 'match($0,/ +output_volume_([[:alnum:]]+)\(\)/) {print substr($0, RSTART + 18, RLENGTH - 20)}' "${BASH_SOURCE[0]}" || EXITCODE=$EX_USAGE; }

    list_sinks() {
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sinks[@]} -eq 0 ]]; then
            error "No audio sinks found."
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sinks:${COLOR_RESET}"
        echo

        local sink_id sink_name sink_nick vol muted is_default
        for sink in "${sinks[@]}"; do
            IFS='|' read -r sink_id sink_name sink_nick <<< "$sink"

            # Get volume and mute status
            vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default sink
            if [[ "$sink_name" == "$default_sink_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$sink_nick"
            if isset NODE_ALIASES["$sink_id"]; then
                display_name="${NODE_ALIASES[$sink_id]}"
            elif isset NODE_ALIASES["$sink_name"]; then
                display_name="${NODE_ALIASES[$sink_name]}"
            elif isset NODE_ALIASES["$sink_nick"]; then
                display_name="${NODE_ALIASES[$sink_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$sink_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($sink_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default sink"
    }

    list_sources() {
        local default_source_name
        default_source_name=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sources
        readarray -t sources < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Source") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sources[@]} -eq 0 ]]; then
            error "No audio sources found."
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sources:${COLOR_RESET}"
        echo

        local source_id source_name source_nick vol muted is_default
        for source in "${sources[@]}"; do
            IFS='|' read -r source_id source_name source_nick <<< "$source"

            # Get volume and mute status
            vol=$(wpctl get-volume "$source_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$source_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default source
            if [[ "$source_name" == "$default_source_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$source_nick"
            if isset NODE_ALIASES["$source_id"]; then
                display_name="${NODE_ALIASES[$source_id]}"
            elif isset NODE_ALIASES["$source_name"]; then
                display_name="${NODE_ALIASES[$source_name]}"
            elif isset NODE_ALIASES["$source_nick"]; then
                display_name="${NODE_ALIASES[$source_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$source_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($source_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default source"
    }

    list_ports() {
        if empty "$NODE_ID"; then
            error "No sink specified. Use -s <sink> or ensure default sink is available."
            return 1
        fi

        local sink_display_name
        sink_display_name=$(get_node_display_name)

        echo "${COLOR_YELLOW}Ports for sink: ${COLOR_GREEN}$sink_display_name${COLOR_RESET} (ID: ${COLOR_CYAN}$NODE_ID${COLOR_RESET})"
        echo

        # Try to get ports from PropInfo first
        local ports
        readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | "\(.id)|\(.name)|\(.description // "N/A")"' 2>/dev/null)

        # If no ports found via PropInfo, try alternative method using node properties
        if [[ ${#ports[@]} -eq 0 ]]; then
            readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props | to_entries[] | select(.key | test("port\\..*")) | "\(.key)|\(.value)"' 2>/dev/null)
        fi

        if [[ ${#ports[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No ports found for this sink.${COLOR_RESET}"
            echo "This sink may not support port switching, or port information is not available."
            echo "Try using ${COLOR_GREEN}wpctl status${COLOR_RESET} for more information."
            return 0
        fi

        # Get active port
        local active_port
        active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        # If no active port from PropInfo, try node properties
        if empty "$active_port"; then
            active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
        fi

        local port_id port_name port_desc is_active
        for port in "${ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc <<< "$port"

            # Handle different port formats
            if [[ -z "$port_desc" || "$port_desc" == "N/A" ]]; then
                port_desc="$port_name"
            fi

            if [[ "$port_id" == "$active_port" || "$port_name" == "$active_port" ]]; then
                is_active="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_active="  "
            fi

            printf "%s${COLOR_CYAN}%s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_active" "$port_id" "$port_desc"
            if [[ -n "$port_name" && "$port_name" != "$port_desc" ]]; then
                echo "  ${COLOR_MAGENTA}($port_name)${COLOR_RESET}"
            else
                echo
            fi
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = active port"
    }

    list() {
        local -r type=${1:-}

        case "$type" in
            sinks|sink)
                list_sinks
                ;;
            sources|source)
                list_sources
                ;;
            ports|port)
                list_ports
                ;;
            "")
                error "List type required. Use: list sinks|sources|ports"
                echo "  ${COLOR_GREEN}list sinks${COLOR_RESET}    - list all audio output sinks"
                echo "  ${COLOR_GREEN}list sources${COLOR_RESET} - list all audio input sources"
                echo "  ${COLOR_GREEN}list ports${COLOR_RESET}    - list ports for current sink"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                error "Unknown list type: $type"
                echo "Valid types: sinks, sources, ports"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_active_port_description() {
        if empty "$NODE_ID"; then
            return 1
        fi

        # Get active port ID
        local active_port_id
        active_port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        if empty "$active_port_id"; then
            return 1
        fi

        # Get port description
        pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$active_port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .description // .name' 2>/dev/null
    }

    get_all_ports() {
        if empty "$NODE_ID"; then
            return 1
        fi

        # Get all ports for the current sink
        local ports
        readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | "\(.id)|\(.name)|\(.description // "N/A")"' 2>/dev/null)

        if [[ ${#ports[@]} -eq 0 ]]; then
            return 1
        fi

        echo "${ports[@]}"
    }

    find_port_by_name_or_id() {
        local -r search=$1
        local port_id port_name port_desc

        if empty "$NODE_ID"; then
            return 1
        fi

        # Get all ports
        local -a all_ports
        readarray -t all_ports < <(get_all_ports)

        if [[ ${#all_ports[@]} -eq 0 ]]; then
            return 1
        fi

        # Search for port
        for port in "${all_ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc <<< "$port"

            # Try as ID
            if [[ "$port_id" == "$search" ]]; then
                echo "$port_id"
                return 0
            fi

            # Try as name
            if [[ "$port_name" == "$search" ]]; then
                echo "$port_id"
                return 0
            fi

            # Try as description (case-insensitive partial match)
            if [[ "${port_desc,,}" == *"${search,,}"* ]]; then
                echo "$port_id"
                return 0
            fi
        done

        return 1
    }

    set_port() {
        local -r port_target=${1:?$(error 'Port name or ID is required')}

        if empty "$NODE_ID"; then
            error "No sink specified. Use -s <sink> or ensure default sink is available."
            return 1
        fi

        # Find the port
        local port_id
        port_id=$(find_port_by_name_or_id "$port_target")

        if empty "$port_id"; then
            error "Port not found: $port_target"
            echo "Use 'volume port list' or 'volume list ports' to see available ports."
            return 1
        fi

        # Get current active port
        local current_port
        current_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        if [[ "$port_id" == "$current_port" ]]; then
            echo "Port is already active."
            return 0
        fi

        # Set the port using pw-cli set-param
        # Note: This requires the EnumPort param to be available on the node
        # The param format uses PipeWire's POD format for Props
        # To test port switching on a device with ports:
        #   1. Use 'volume port list' to see available ports
        #   2. Use 'volume port set <port_id>' to switch ports
        #   3. Verify with 'wpctl inspect <node_id>' that the port changed
        if ! pw-cli set-param "$NODE_ID" Props '{"EnumPort":"'"$port_id"'"}' &>/dev/null; then
            error "Failed to set port to $port_id"
            echo "Note: Port switching may not be supported on this device, or the port ID may be incorrect."
            echo "Verify ports are available with: volume port list"
            return 1
        fi

        # Get port description for notification
        local port_desc
        port_desc=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .description // .name' 2>/dev/null)

        # Invalidate cache
        invalidate_cache

        # Show notification if enabled
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")
            summary="Port switched to: $port_desc"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd 0 "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti 0 ;;
                kosd    ) notify_volume_kosd 0 ;;
                *       ) notify_volume_libnotify 0 "$icon" "$summary" "" ;;
            esac
        else
            echo "Port switched to: $port_desc"
        fi

        # Update statusbar if configured
        update_statusbar || true
    }

    port() {
        local -r subcommand=${1:-}
        local -r target=${2:-}

        case "$subcommand" in
            list)
                list_ports
                ;;
            set)
                if empty "$target"; then
                    error "Port name or ID required. Use: port set <port>"
                    echo "Use 'volume port list' to see available ports."
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                set_port "$target"
                ;;
            "")
                error "Port subcommand required. Use: port list|set"
                echo "  ${COLOR_GREEN}port list${COLOR_RESET}        - list available ports"
                echo "  ${COLOR_GREEN}port set <port>${COLOR_RESET}  - set active port"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                error "Unknown port subcommand: $subcommand"
                echo "Valid subcommands: list, set"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_profiles_dir() {
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/profiles"
    }

    get_config_dir() {
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume"
    }

    save_volume_before_mute() {
        local -r vol=$1
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"

        # Create config directory if it doesn't exist
        mkdir -p "$config_dir" || {
            error "Failed to create config directory: $config_dir"
            return 1
        }

        # Save the volume to file
        echo "$vol" > "$volume_file" || {
            error "Failed to save volume to: $volume_file"
            return 1
        }
    }

    restore_volume_after_mute() {
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"

        # Check if the file exists
        if [[ ! -f "$volume_file" ]]; then
            return 1
        fi

        # Read the saved volume
        local saved_vol
        saved_vol=$(cat "$volume_file" 2>/dev/null)

        # Validate the volume
        if empty "$saved_vol" || ! [[ "$saved_vol" =~ ^[0-9]+$ ]]; then
            rm -f "$volume_file"
            return 1
        fi

        # Return the saved volume
        echo "$saved_vol"
    }

    clear_saved_volume() {
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"
        rm -f "$volume_file"
    }

    get_boost_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.volume_boost"
    }

    get_boost_pid_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.volume_boost_pid"
    }

    save_boost_state() {
        local -r original_vol=$1
        local -r boost_amount=$2
        local -r timeout_sec=$3
        local boost_file
        boost_file=$(get_boost_file)

        # Create config directory if it doesn't exist
        local config_dir
        config_dir=$(get_config_dir)
        mkdir -p "$config_dir" || {
            error "Failed to create config directory: $config_dir"
            return 1
        }

        # Save boost state: original_vol|boost_amount|timeout_sec|timestamp
        echo "${original_vol}|${boost_amount}|${timeout_sec}|$(date +%s)" > "$boost_file" || {
            error "Failed to save boost state"
            return 1
        }
    }

    get_boost_state() {
        local boost_file
        boost_file=$(get_boost_file)

        if [[ ! -f "$boost_file" ]]; then
            return 1
        fi

        # Read boost state
        local boost_data
        boost_data=$(cat "$boost_file" 2>/dev/null)

        if empty "$boost_data"; then
            return 1
        fi

        # Parse: original_vol|boost_amount|timeout_sec|timestamp
        IFS='|' read -r BOOST_ORIGINAL_VOL BOOST_AMOUNT BOOST_TIMEOUT BOOST_TIMESTAMP <<< "$boost_data"

        # Validate
        if empty "$BOOST_ORIGINAL_VOL" || empty "$BOOST_AMOUNT" || empty "$BOOST_TIMEOUT" || empty "$BOOST_TIMESTAMP"; then
            return 1
        fi

        # Check if boost has expired
        local current_time elapsed_time
        current_time=$(date +%s)
        elapsed_time=$(( current_time - BOOST_TIMESTAMP ))

        if (( elapsed_time >= BOOST_TIMEOUT )); then
            # Boost has expired, clean up
            clear_boost_state
            return 1
        fi

        return 0
    }

    clear_boost_state() {
        local boost_file pid_file
        boost_file=$(get_boost_file)
        pid_file=$(get_boost_pid_file)

        # Kill background process if it exists
        if [[ -f "$pid_file" ]]; then
            local pid
            pid=$(cat "$pid_file" 2>/dev/null)
            if not_empty "$pid" && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
            fi
            rm -f "$pid_file"
        fi

        rm -f "$boost_file"
    }

    is_boost_active() {
        get_boost_state 2>/dev/null
    }

    enable_boost() {
        local -r boost_amount=${1:?$(error 'Boost amount is required')}
        local -r timeout_sec=${2:-30}  # Default 30 seconds
        local current_vol original_vol target_vol actual_boost

        # Validate boost amount
        if ! [[ "$boost_amount" =~ ^[0-9]+$ ]] || (( boost_amount < 1 || boost_amount > 100 )); then
            error "Invalid boost amount: $boost_amount (must be 1-100)"
            return 1
        fi

        # Check if boost is already active
        if is_boost_active; then
            error "Boost is already active. Use 'volume boost off' to cancel first."
            return 1
        fi

        # Get current volume
        current_vol=$(get_volume)
        original_vol=$current_vol

        # Calculate target volume (boost is additive percentage)
        target_vol=$(( current_vol + boost_amount ))
        actual_boost=$boost_amount

        # Respect MAX_VOL if set
        if not_empty "$MAX_VOL" && (( target_vol > MAX_VOL )); then
            target_vol=$MAX_VOL
            # Adjust boost amount to what we can actually apply
            actual_boost=$(( target_vol - original_vol ))
            if (( actual_boost <= 0 )); then
                error "Cannot boost: already at maximum volume"
                return 1
            fi
        fi

        # Don't exceed 200% (hard limit for safety)
        if (( target_vol > 200 )); then
            target_vol=200
            actual_boost=$(( target_vol - original_vol ))
        fi

        # Save boost state (use actual_boost for what was actually applied)
        save_boost_state "$original_vol" "$actual_boost" "$timeout_sec" || return 1

        # Set boosted volume
        if not_empty "$FADE_DURATION"; then
            fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
        else
            invalidate_cache
            wpctl set-volume "$NODE_ID" "${target_vol}%"
        fi

        # Start background process to auto-revert
        # Capture values needed in subshell
        local config_dir_boost node_id_boost
        config_dir_boost=$(get_config_dir)
        node_id_boost=$NODE_ID
        (
            sleep "$timeout_sec"
            # Check if boost is still active (might have been cancelled)
            local boost_file restore_vol
            boost_file="$config_dir_boost/.volume_boost"
            if [[ -f "$boost_file" ]]; then
                # Read original volume from file
                local boost_data
                boost_data=$(cat "$boost_file" 2>/dev/null)
                if [[ -n "$boost_data" ]]; then
                    IFS='|' read -r restore_vol _ _ _ <<< "$boost_data"
                    # Restore original volume (direct wpctl call, no fade in background)
                    if [[ -n "$restore_vol" ]]; then
                        wpctl set-volume "$node_id_boost" "${restore_vol}%" &>/dev/null
                    fi
                    # Clean up boost state files
                    rm -f "$boost_file"
                    rm -f "$config_dir_boost/.volume_boost_pid"
                fi
            fi
        ) &

        # Save PID of background process
        local pid_file
        pid_file=$(get_boost_pid_file)
        echo $! > "$pid_file"

        if [[ "$actual_boost" != "$boost_amount" ]]; then
            echo "Boost enabled: +${actual_boost}% (requested +${boost_amount}%, limited by max volume) for ${timeout_sec}s"
        else
            echo "Boost enabled: +${actual_boost}% for ${timeout_sec}s"
        fi
    }

    disable_boost() {
        if ! is_boost_active; then
            error "No active boost to cancel"
            return 1
        fi

        # Get original volume
        local original_vol
        original_vol=$BOOST_ORIGINAL_VOL

        # Restore original volume
        if not_empty "$FADE_DURATION"; then
            fade_volume "$original_vol" "$FADE_DURATION" "$NODE_ID"
        else
            invalidate_cache
            wpctl set-volume "$NODE_ID" "${original_vol}%"
        fi

        # Clear boost state (this also kills the background process)
        clear_boost_state

        echo "Boost disabled"
    }

    boost() {
        local -r subcommand=${1:-}
        local -r value=${2:-}

        case "$subcommand" in
            off|cancel|disable)
                disable_boost
                ;;
            "")
                error "Boost subcommand required. Use: boost <amount> [timeout] or boost off"
                echo "  ${COLOR_GREEN}boost <amount> [timeout]${COLOR_RESET}  - enable boost (default timeout: 30s)"
                echo "  ${COLOR_GREEN}boost off${COLOR_RESET}                 - disable boost"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                # Try to parse as boost amount
                if [[ "$subcommand" =~ ^[0-9]+$ ]]; then
                    enable_boost "$subcommand" "$value"
                else
                    error "Unknown boost subcommand: $subcommand"
                    echo "Use: boost <amount> [timeout] or boost off"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                ;;
        esac
    }

    save_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        # Validate profile name (alphanumeric, dash, underscore only)
        if [[ ! "$profile_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            error "Invalid profile name: $profile_name"
            echo "Profile names can only contain letters, numbers, dashes, and underscores."
            return 1
        fi

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        # Create profiles directory if it doesn't exist
        mkdir -p "$profiles_dir" || {
            error "Failed to create profiles directory: $profiles_dir"
            return 1
        }

        # Get current state
        local vol muted sink_name port_id mic_vol mic_muted
        vol=$(get_volume)
        muted=$(is_muted && echo "true" || echo "false")
        sink_name="$NODE_NAME"
        port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null || echo "")

        # Get mic state if available
        if not_empty "$SOURCE_ID"; then
            mic_vol=$(get_mic_volume 2>/dev/null || echo "")
            mic_muted=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
        else
            mic_vol=""
            mic_muted=""
        fi

        # Create JSON profile
        local profile_json
        profile_json=$(jq -n \
            --arg vol "$vol" \
            --arg muted "$muted" \
            --arg sink "$sink_name" \
            --arg port "$port_id" \
            --arg mic_vol "${mic_vol:-}" \
            --arg mic_muted "${mic_muted:-}" \
            '{volume: ($vol | tonumber), muted: ($muted == "true"), sink: $sink, port: (if $port == "" then null else $port end), mic_volume: (if $mic_vol == "" then null else ($mic_vol | tonumber) end), mic_muted: (if $mic_muted == "" then null else ($mic_muted == "true") end)}' 2>/dev/null)

        if empty "$profile_json"; then
            error "Failed to create profile JSON"
            return 1
        fi

        # Save to file
        echo "$profile_json" > "$profile_file" || {
            error "Failed to save profile to: $profile_file"
            return 1
        }

        echo "Profile saved: $profile_name"
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")
            summary="Profile saved: $profile_name"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd 0 "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti 0 ;;
                kosd    ) notify_volume_kosd 0 ;;
                *       ) notify_volume_libnotify 0 "$icon" "$summary" "" ;;
            esac
        fi
    }

    load_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        if [[ ! -f "$profile_file" ]]; then
            error "Profile not found: $profile_name"
            echo "Use 'volume profile list' to see available profiles."
            return 1
        fi

        # Read profile JSON
        local vol muted sink_name port_id mic_vol mic_muted
        vol=$(jq -r '.volume // empty' "$profile_file" 2>/dev/null)
        muted=$(jq -r '.muted // false' "$profile_file" 2>/dev/null)
        sink_name=$(jq -r '.sink // empty' "$profile_file" 2>/dev/null)
        port_id=$(jq -r '.port // empty' "$profile_file" 2>/dev/null)
        mic_vol=$(jq -r '.mic_volume // empty' "$profile_file" 2>/dev/null)
        mic_muted=$(jq -r '.mic_muted // false' "$profile_file" 2>/dev/null)

        if empty "$vol"; then
            error "Invalid profile: $profile_name (missing volume)"
            return 1
        fi

        # Switch sink if specified and different
        if not_empty "$sink_name" && [[ "$sink_name" != "$NODE_NAME" ]]; then
            # Find sink by name
            local sink_id
            sink_id=$(pw_dump | jq -r --arg name "$sink_name" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.name" == $name) | .id' 2>/dev/null)

            if not_empty "$sink_id"; then
                wpctl set-default "$sink_id" &>/dev/null
                invalidate_cache
                # Reinitialize audio to get new NODE_ID
                NODE_NAME="$sink_name"
                NODE_ID=$(get_node_id)
            fi
        fi

        # Set volume
        set_volume "$vol"

        # Set mute status
        local current_muted
        current_muted=$(is_muted && echo "true" || echo "false")
        if [[ "$muted" == "true" && "$current_muted" != "true" ]]; then
            toggle_mute
        elif [[ "$muted" != "true" && "$current_muted" == "true" ]]; then
            toggle_mute
        fi

        # Set port if specified
        if not_empty "$port_id" && [[ "$port_id" != "null" ]]; then
            set_port "$port_id" &>/dev/null || true
        fi

        # Set mic volume and mute if specified
        if not_empty "$mic_vol" && [[ "$mic_vol" != "null" ]] && not_empty "$SOURCE_ID"; then
            set_mic_volume "$mic_vol"
            local current_mic_muted
            current_mic_muted=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
            if [[ "$mic_muted" == "true" && "$current_mic_muted" != "true" ]]; then
                toggle_mic_mute
            elif [[ "$mic_muted" != "true" && "$current_mic_muted" == "true" ]]; then
                toggle_mic_mute
            fi
        fi

        echo "Profile loaded: $profile_name"
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")
            summary="Profile loaded: $profile_name"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd "$vol" "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti "$vol" ;;
                kosd    ) notify_volume_kosd "$vol" ;;
                *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "" ;;
            esac
        fi

        # Update statusbar
        update_statusbar || true
    }

    list_profiles() {
        local profiles_dir
        profiles_dir=$(get_profiles_dir)

        if [[ ! -d "$profiles_dir" ]]; then
            echo "${COLOR_YELLOW}No profiles directory found.${COLOR_RESET}"
            echo "Save a profile first using: ${COLOR_GREEN}volume profile save <name>${COLOR_RESET}"
            return 0
        fi

        local profiles
        readarray -t profiles < <(find "$profiles_dir" -name "*.json" -type f -printf "%f\n" 2>/dev/null | sed 's/\.json$//' | sort)

        if [[ ${#profiles[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No profiles found.${COLOR_RESET}"
            echo "Save a profile first using: ${COLOR_GREEN}volume profile save <name>${COLOR_RESET}"
            return 0
        fi

        echo "${COLOR_YELLOW}Saved Profiles:${COLOR_RESET}"
        echo

        local profile_name profile_file vol muted sink_name
        for profile_name in "${profiles[@]}"; do
            profile_file="$profiles_dir/$profile_name.json"
            vol=$(jq -r '.volume // "N/A"' "$profile_file" 2>/dev/null)
            muted=$(jq -r '.muted // false' "$profile_file" 2>/dev/null)
            sink_name=$(jq -r '.sink // "default"' "$profile_file" 2>/dev/null)

            printf "  ${COLOR_GREEN}%s${COLOR_RESET}" "$profile_name"
            if [[ "$muted" == "true" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($sink_name)${COLOR_RESET}"
        done
        echo
    }

    delete_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        if [[ ! -f "$profile_file" ]]; then
            error "Profile not found: $profile_name"
            return 1
        fi

        rm -f "$profile_file" || {
            error "Failed to delete profile: $profile_name"
            return 1
        }

        echo "Profile deleted: $profile_name"
    }

    profile() {
        local -r subcommand=${1:-}
        local -r target=${2:-}

        case "$subcommand" in
            save)
                if empty "$target"; then
                    error "Profile name required. Use: profile save <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                save_profile "$target"
                ;;
            load)
                if empty "$target"; then
                    error "Profile name required. Use: profile load <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                load_profile "$target"
                ;;
            list)
                list_profiles
                ;;
            delete|remove|rm)
                if empty "$target"; then
                    error "Profile name required. Use: profile delete <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                delete_profile "$target"
                ;;
            "")
                error "Profile subcommand required. Use: profile save|load|list|delete"
                echo "  ${COLOR_GREEN}profile save <name>${COLOR_RESET}   - save current settings as profile"
                echo "  ${COLOR_GREEN}profile load <name>${COLOR_RESET}   - load a saved profile"
                echo "  ${COLOR_GREEN}profile list${COLOR_RESET}          - list all saved profiles"
                echo "  ${COLOR_GREEN}profile delete <name>${COLOR_RESET} - delete a profile"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                # Quick access: profile <name> loads the profile
                load_profile "$subcommand"
                ;;
        esac
    }

    get_all_sinks() {
        # Returns array of sink IDs
        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | .id' 2>/dev/null)
        echo "${sinks[@]}"
    }

    get_default_sink_id() {
        # Returns the ID of the current default sink
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
        pw_dump | jq -r --arg name "$default_sink_name" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == $name) | .id' 2>/dev/null
    }

    get_sink_display_name_by_id() {
        local -r sink_id=$1
        local sink_name sink_nick display_name

        sink_name=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
        sink_nick=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.nick" // "N/A"' 2>/dev/null)

        # Apply alias if available
        display_name="$sink_nick"
        if isset NODE_ALIASES["$sink_id"]; then
            display_name="${NODE_ALIASES[$sink_id]}"
        elif isset NODE_ALIASES["$sink_name"]; then
            display_name="${NODE_ALIASES[$sink_name]}"
        elif isset NODE_ALIASES["$sink_nick"]; then
            display_name="${NODE_ALIASES[$sink_nick]}"
        fi

        echo "$display_name"
    }

    find_sink_by_name_or_id() {
        # Find sink by ID, name, nick, or alias
        local -r search=$1
        local sink_id sink_name sink_nick

        # Try as ID first
        sink_id=$(pw_dump | jq -r --argjson id "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .id == ($id | tonumber? // empty)) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as name
        sink_id=$(pw_dump | jq -r --arg name "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.name" == $name) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as nick
        sink_id=$(pw_dump | jq -r --arg nick "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.nick" == $nick) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as alias
        local alias_key
        for alias_key in "${!NODE_ALIASES[@]}"; do
            if [[ "${NODE_ALIASES[$alias_key]}" == "$search" ]]; then
                # Found alias, now find the sink
                sink_id=$(pw_dump | jq -r --arg key "$alias_key" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and (.id == ($key | tonumber? // empty) or .info.props."node.name" == $key or .info.props."node.nick" == $key)) | .id' 2>/dev/null)
                if not_empty "$sink_id"; then
                    echo "$sink_id"
                    return 0
                fi
            fi
        done

        return 1
    }

    switch_sink() {
        local target_sink_id target_sink_name
        local -r target=${1:-}

        # Get all available sinks
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error "No audio sinks found."
            return 1
        fi

        if [[ ${#all_sinks[@]} -eq 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        # If no target specified, cycle to next sink
        if empty "$target"; then
            local current_sink_id
            current_sink_id=$(get_default_sink_id)

            if empty "$current_sink_id"; then
                error "Could not determine current default sink."
                return 1
            fi

            # Find current sink index
            local idx=0
            local found=false
            for sink in "${all_sinks[@]}"; do
                if [[ "$sink" == "$current_sink_id" ]]; then
                    found=true
                    break
                fi
                ((idx++))
            done

            if ! $found; then
                error "Current sink not found in available sinks."
                return 1
            fi

            # Move to next sink (wrap around)
            idx=$(( (idx + 1) % ${#all_sinks[@]} ))
            target_sink_id="${all_sinks[$idx]}"
        else
            # Find sink by name, ID, or alias
            target_sink_id=$(find_sink_by_name_or_id "$target")

            if empty "$target_sink_id"; then
                error "Sink not found: $target"
                echo "Use 'volume list sinks' to see available sinks."
                return 1
            fi

            # Check if it's already the default
            local current_sink_id
            current_sink_id=$(get_default_sink_id)
            if [[ "$target_sink_id" == "$current_sink_id" ]]; then
                echo "Sink is already the default."
                return 0
            fi
        fi

        # Switch to the target sink
        if ! wpctl set-default "$target_sink_id" &>/dev/null; then
            error "Failed to switch to sink ID $target_sink_id"
            return 1
        fi

        # Get display name and volume for notification
        target_sink_name=$(get_sink_display_name_by_id "$target_sink_id")
        local target_vol target_muted
        target_vol=$(wpctl get-volume "$target_sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
        target_muted=$(wpctl get-volume "$target_sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)

        # Invalidate cache and reinitialize audio
        invalidate_cache

        # Update NODE_ID and NODE_NAME to the new sink for potential future use
        NODE_ID="$target_sink_id"
        NODE_NAME=$(pw_dump | jq -r --argjson id "$target_sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)

        # Show notification if enabled
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            if $target_muted; then
                icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
                summary="Switched to: $target_sink_name (MUTED)"
            else
                icon=$(get_volume_icon "$target_vol")
                printf -v summary "Switched to: %s (%s%%)" "$target_sink_name" "$target_vol"
            fi

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd "$target_vol" "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti "$target_vol" ;;
                kosd    ) notify_volume_kosd "$target_vol" ;;
                *       ) notify_volume_libnotify "$target_vol" "$icon" "$summary" "" ;;
            esac
        else
            if $target_muted; then
                echo "Switched to: $target_sink_name (MUTED, ${target_vol}%)"
            else
                echo "Switched to: $target_sink_name (${target_vol}%)"
            fi
        fi

        # Update statusbar if configured
        update_statusbar || true
    }

    next_sink() { switch_sink; }
    prev_sink() {
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -le 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        local current_sink_id
        current_sink_id=$(get_default_sink_id)

        if empty "$current_sink_id"; then
            error "Could not determine current default sink."
            return 1
        fi

        # Find current sink index
        local idx=0
        local found=false
        for sink in "${all_sinks[@]}"; do
            if [[ "$sink" == "$current_sink_id" ]]; then
                found=true
                break
            fi
            ((idx++))
        done

        if ! $found; then
            error "Current sink not found in available sinks."
            return 1
        fi

        # Move to previous sink (wrap around)
        idx=$(( (idx - 1 + ${#all_sinks[@]}) % ${#all_sinks[@]} ))
        local target_sink_id="${all_sinks[$idx]}"

        # Switch using the main function
        switch_sink "$target_sink_id"
    }

    usage() {
        cat <<- EOF 1>&2
${COLOR_YELLOW}Usage:${COLOR_RESET} $0 [<options>] <command> [<args>]
Control volume and related notifications.

${COLOR_YELLOW}Commands:${COLOR_RESET}
  ${COLOR_GREEN}up [value]${COLOR_RESET}                  increase volume (uses default step if value omitted)
  ${COLOR_GREEN}down [value]${COLOR_RESET}                decrease volume (uses default step if value omitted)
  ${COLOR_GREEN}set <value>${COLOR_RESET}                 set volume
  ${COLOR_GREEN}mute${COLOR_RESET}                        toggle mute
  ${COLOR_GREEN}fade <from> <to> [duration_ms]${COLOR_RESET} fade volume smoothly
                              examples:
                                  fade 0 100        - fade from 0% to 100% (500ms)
                                  fade 0 100 2000  - fade from 0% to 100% over 2 seconds
  ${COLOR_GREEN}mic <cmd> [value]${COLOR_RESET}           control microphone
                              commands:
                                  up <value>    - increase microphone volume
                                  down <value>  - decrease microphone volume
                                  set <value>   - set microphone volume
                                  mute          - toggle microphone mute
  ${COLOR_GREEN}listen${COLOR_RESET}                      monitor volume changes on a sink
  ${COLOR_GREEN}list <type>${COLOR_RESET}                 list sinks, sources, or ports
                              types:
                                  sinks   - list all audio output sinks
                                  sources - list all audio input sources
                                  ports   - list ports for current sink
  ${COLOR_GREEN}switch [sink]${COLOR_RESET}               switch to next sink or specified sink
  ${COLOR_GREEN}next${COLOR_RESET}                        switch to next sink
  ${COLOR_GREEN}prev${COLOR_RESET}                        switch to previous sink
  ${COLOR_GREEN}port <cmd> [port]${COLOR_RESET}           control audio ports
                              commands:
                                  list        - list available ports
                                  set <port>  - set active port
  ${COLOR_GREEN}profile <cmd> [name]${COLOR_RESET}       manage volume profiles
                              commands:
                                  save <name>   - save current settings as profile
                                  load <name>   - load a saved profile
                                  list          - list all saved profiles
                                  delete <name> - delete a profile
                              quick access:
                                  profile <name> - load profile (shortcut for load)
  ${COLOR_GREEN}boost <amount> [timeout]${COLOR_RESET}   temporarily boost volume
                              examples:
                                  boost 20        - boost by 20% for 30s (default)
                                  boost 20 60    - boost by 20% for 60s
                                  boost off      - cancel active boost
  ${COLOR_GREEN}output <format>${COLOR_RESET}             display volume in a custom format
                              format placeholders:
                                  %v = volume
                                  %s = sink name
                                  %p = volume progress bar
                                  %i = volume icon/emoji
                                  %P = active port description
                                  %m = microphone volume

                                  examples:
                                      "Volume is %v" = Volume is 50%
                                      "%i %v %p \n"  =  50% 
  ${COLOR_GREEN}outputs${COLOR_RESET}                     show supported output formats
  ${COLOR_GREEN}notifications${COLOR_RESET}               list notification methods
  ${COLOR_GREEN}help${COLOR_RESET}                        show help

${COLOR_YELLOW}Options:${COLOR_RESET}
  ${COLOR_GREEN}-n${COLOR_RESET}                          enable notifications
  ${COLOR_GREEN}-C${COLOR_RESET}                          play event sounds using libcanberra
  ${COLOR_GREEN}-P${COLOR_RESET}                          play sound for volume changes
  ${COLOR_GREEN}-j <muted,high,low,medium>${COLOR_RESET}  custom volume emojis
  ${COLOR_GREEN}-s <sink>${COLOR_RESET}                   specify sink (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SINK@${COLOR_RESET})
  ${COLOR_GREEN}-I <source>${COLOR_RESET}                 specify input source (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SOURCE@${COLOR_RESET})
  ${COLOR_GREEN}-t <process_name>${COLOR_RESET}           status bar process name (${COLOR_MAGENTA}requires -u${COLOR_RESET})
  ${COLOR_GREEN}-A <node.nick:alias>${COLOR_RESET}        alias a node nick (e.g., -A "ALC287 Analog:Speakers")
  ${COLOR_GREEN}-u <signal>${COLOR_RESET}                 signal to update status bar (${COLOR_MAGENTA}requires -t${COLOR_RESET})
  ${COLOR_GREEN}-D <value>${COLOR_RESET}                  set default step size (${COLOR_MAGENTA}default: 5${COLOR_RESET})
  ${COLOR_GREEN}-f <duration_ms>${COLOR_RESET}            fade duration in milliseconds (${COLOR_MAGENTA}for set/up/down/mute${COLOR_RESET})
  ${COLOR_GREEN}-x <value>${COLOR_RESET}                  set maximum volume
  ${COLOR_GREEN}-h${COLOR_RESET}                          show help

${COLOR_YELLOW}Notification Options:${COLOR_RESET}
  ${COLOR_GREEN}-N <method>${COLOR_RESET}                 notification method (${COLOR_MAGENTA}default: libnotify${COLOR_RESET})
  ${COLOR_GREEN}-p${COLOR_RESET}                          enable progress bar in notifications
  ${COLOR_GREEN}-L <placement>${COLOR_RESET}              progress bar placement (${COLOR_MAGENTA}default: summary${COLOR_RESET}; ${COLOR_MAGENTA}requires -p${COLOR_RESET})
                              placements:
                                  body
                                  summary
  ${COLOR_GREEN}-e <ms>${COLOR_RESET}                     notification expiration time
  ${COLOR_GREEN}-l${COLOR_RESET}                          use full-color icons
  ${COLOR_GREEN}-S <suffix>${COLOR_RESET}                 add suffix to symbolic icon names
  ${COLOR_GREEN}-y${COLOR_RESET}                          use dunstify (${COLOR_MAGENTA}default: notify-send${COLOR_RESET})

${COLOR_YELLOW}Environment Variables:${COLOR_RESET}
  ${COLOR_CYAN}XOSD_PATH${COLOR_RESET}                   path to osd_cat
  ${COLOR_CYAN}HERBE_PATH${COLOR_RESET}                  path to herbe
  ${COLOR_CYAN}VOLNOTI_PATH${COLOR_RESET}                path to volnoti-show
  ${COLOR_CYAN}CANBERRA_PATH${COLOR_RESET}               path to canberra-gtk-play
  ${COLOR_CYAN}NOTIFY_PATH${COLOR_RESET}                 path to command that sends notifications
  ${COLOR_CYAN}NO_NOTIFY_COLOR${COLOR_RESET}             flag to disable colors in notifications
  ${COLOR_CYAN}USE_NOTIFY_SEND_PY${COLOR_RESET}          flag to use notify-send.py instead of notify-send
EOF
        exit "$EX_USAGE"
    }
}

get_volume() { wpctl get-volume "$NODE_ID" | awk '{print $2 * 100}'; }
is_muted() { wpctl get-volume "$NODE_ID" | grep -q '\[MUTED\]'; }

get_mic_volume() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | awk '{print $2 * 100}'
}

is_mic_muted() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | grep -q '\[MUTED\]'
}

get_volume_icon() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if $USE_FULLCOLOR_ICONS; then
        if (( vol >= 70 )); then icon=${ICONS[1]}
        elif (( vol >= 40 )); then icon=${ICONS[3]}
        elif (( vol > 0 )); then icon=${ICONS[2]}
        else icon=${ICONS[2]}
        fi
    else
        # Get overamplified icon if available, otherwise default to high volume icon
        if (( vol > 100 )); then icon=${ICONS_SYMBOLIC[4]:-${ICONS_SYMBOLIC[1]}}
        elif (( vol >= 70 )); then icon=${ICONS_SYMBOLIC[1]}
        elif (( vol >= 40 )); then icon=${ICONS_SYMBOLIC[3]}
        elif (( vol > 0 )); then icon=${ICONS_SYMBOLIC[2]}
        else icon=${ICONS_SYMBOLIC[2]}
        fi
    fi

    echo "$icon"
}

get_volume_emoji() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if is_muted; then icon=${ICONS_EMOJI[0]}
    else
        if (( vol >= 70 )); then icon=${ICONS_EMOJI[1]}
        elif (( vol >= 40 )); then icon=${ICONS_EMOJI[3]}
        elif (( vol > 0 )); then icon=${ICONS_EMOJI[2]}
        else icon=${ICONS_EMOJI[2]}
        fi
    fi
    echo "$icon"
}

update_statusline() {
    local signal=${1:?$(error 'Signal is required')}
    local proc=${2:?$(error 'Process name is required')}
    pkill "-$signal" "$proc"
}

progress_bar() {
    local percent=${1:?$(error 'Percentage is required')}
    local -i max_percent=${2:-100}
    local -i bar_length=${3:-20}

    # Clamp the percentage to be within 0 and max_percent
    (( percent = percent < 0 ? 0 : (percent > max_percent ? max_percent : percent) ))

    local filled_blocks=$(( percent * bar_length / max_percent ))
    local empty_blocks=$(( bar_length - filled_blocks ))
    local bar; printf -v bar "%${filled_blocks}s" ''
    local empty; printf -v empty "%${empty_blocks}s" ''

    echo "${bar// /}${empty// /}"
}

apply_symbolic_icon_suffix() { for i in "${!ICONS_SYMBOLIC[@]}"; do ICONS_SYMBOLIC[i]="${ICONS_SYMBOLIC[i]}${SYMBOLIC_ICON_SUFFIX}"; done; }

volume_color() {
    local -ir vol=${1:?$(error 'A volume is required')}
    if (( vol >= MIN_VOL && vol < DEFAULT_VOL )); then echo "$COLOR_MIN_TO_DEFAULT";
    elif (( vol == 100 )); then echo "$COLOR_FULL";
    elif (( vol > 100 && vol <= MAX_VOL )); then echo "$COLOR_FULL_TO_MAX";
    else echo "$COLOR_OTHER";
    fi
}

# Returns
#   0 when both signal and statusline are set
#   1 when one of signal or statusline are set but not both
update_statusbar() {
    if not_empty "$SIGNAL" && empty "$STATUSLINE"; then return 1; fi
    if not_empty "$SIGNAL"; then update_statusline "$SIGNAL" "$STATUSLINE";
    elif not_empty "$STATUSLINE"; then return 1; fi
    return 0
}

init_audio() {
    if empty "$NODE_NAME"; then
        NODE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SINK@ | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    NODE_ID=$(get_node_id)
    NODE_NICK=$(get_node_nick)
    DEFAULT_VOL=$(get_default_volume)
    MIN_VOL=$(get_min_volume)
    MAX_VOL=$(get_max_volume)
}

init_source() {
    if empty "$SOURCE_NAME"; then
        SOURCE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    SOURCE_ID=$(get_source_id)
    # shellcheck disable=SC2034  # SOURCE_NICK may be used in future features
    SOURCE_NICK=$(get_source_nick)
}

get_node_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$NODE_NAME"'") | .id'; }
get_node_nick() { pw_dump | jq -r '.[] | select(.id == '"$NODE_ID"') | .info.props."node.nick"'; }

get_source_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$SOURCE_NAME"'") | .id'; }
get_source_nick() { pw_dump | jq -r '.[] | select(.id == '"$SOURCE_ID"') | .info.props."node.nick"'; }

get_node_display_name() {
    if isset NODE_ALIASES["$NODE_ID"]; then echo "${NODE_ALIASES[$NODE_ID]}"
    elif isset NODE_ALIASES["$NODE_NAME"]; then echo "${NODE_ALIASES[$NODE_NAME]}"
    elif isset NODE_ALIASES["$NODE_NICK"]; then echo "${NODE_ALIASES[$NODE_NICK]}"
    else get_node_nick
    fi
}

# get_node_name_by_id() {
#     local -r id=${1:?$(error 'Node ID is required')}
#     wpctl inspect "$id" | jq -r '.info.props."node.name"'
# }

# dump_node() {
#     local -r name=${1:?$(error 'Node name is required')}
#     pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$name"'")'
# }

pw_dump() {
    if [[ $COMMAND == "listen" ]] || empty "$PW_DUMP"; then PW_DUMP=$(pw-dump); fi
    echo "$PW_DUMP"
}

invalidate_cache() { PW_DUMP=""; }

# Listens for PipeWire events
#
# Arguments:
#   Output    (optional) (string) An output mode. When set, outputs volume in the output mode format.
listen() {
    local -r output=$*

    # Output volume so status bars have something to display before any event occurs
    not_empty "$output" && output_volume "$output"

    # Monitor events and filter for the sink ID
    pw-cli subscribe | stdbuf -oL grep -F "object.id = $NODE_ID" | while IFS= read -r; do
        show_volume_notification
        update_statusbar
        play_volume_changed
        not_empty "$output" && output_volume "$output"
    done
}

pw_play() {
    command_exists pw-play || { error "pw-play is not installed or not in \$PATH"; return 1; }
    pw-play --target "$NODE_ID" "$1" &
}

get_volume_info() {
    local -r type=${1:?$(error 'Volume type (default/min/max) is required')}
    local vol
    vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "volume") | .type.'"$type"'' 2>/dev/null)

    empty "$vol" && { echo "Error: $type volume information not found for NODE_ID=$NODE_ID" >&2; return 1; }
    echo "$vol" | awk '{print $1 * 100}'
}

get_default_volume() { get_volume_info "default"; }
get_min_volume() { get_volume_info "min"; }
get_max_volume() { get_volume_info "max"; }

init_color() {
    has_color && {
        COLOR_RESET=$'\033[0m'
        COLOR_RED=$'\033[0;31m'
        COLOR_GREEN=$'\033[0;32m'
        COLOR_YELLOW=$'\033[0;33m'
        COLOR_MAGENTA=$'\033[0;35m'
        COLOR_CYAN=$'\033[0;36m'
    }
}

load_config() {
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    # shellcheck source=/dev/null
    [[ -f $config ]] && source "$config"

    # Set defaults if not defined in config
    : "${NOTIFICATION_METHOD:=libnotify}"
}

save_config_value() {
    local -r key=$1
    local -r value=$2
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    local config_dir
    config_dir=$(dirname "$config")

    # Create config directory if it doesn't exist
    mkdir -p "$config_dir" || {
        error "Failed to create config directory: $config_dir"
        return 1
    }

    # If config file exists, update or add the key
    if [[ -f $config ]]; then
        # Check if key already exists
        if grep -q "^[[:space:]]*${key}=" "$config" 2>/dev/null; then
            # Update existing key (handle both quoted and unquoted values)
            if [[ "$value" =~ ^[0-9]+$ ]]; then
                # Numeric value - no quotes needed
                sed -i "s|^[[:space:]]*${key}=.*|${key}=${value}|" "$config"
            else
                # String value - add quotes if not already quoted
                sed -i "s|^[[:space:]]*${key}=.*|${key}=\"${value}\"|" "$config"
            fi
        else
            # Add new key at the end
            if [[ "$value" =~ ^[0-9]+$ ]]; then
                echo "${key}=${value}" >> "$config"
            else
                echo "${key}=\"${value}\"" >> "$config"
            fi
        fi
    else
        # Create new config file
        if [[ "$value" =~ ^[0-9]+$ ]]; then
            echo "${key}=${value}" > "$config"
        else
            echo "${key}=\"${value}\"" > "$config"
        fi
    fi
}

# Rearrange all options to place flags first
# Author: greycat
# URL: https://mywiki.wooledge.org/ComplexOptionParsing
arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=:A:Ce:f:hj:lL:nN:pPs:S:t:u:yI:D:

    arrange_opts "$optstring" "$@"
    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            A    ) IFS=: read -r node alias <<< "$OPTARG"
                   NODE_ALIASES[$node]=$alias ;;
            C    ) USE_CANBERRA=true ;;
            e    ) EXPIRES=$OPTARG ;;
            f    ) FADE_DURATION=$OPTARG ;;
            j    ) IFS=, read -ra ICONS_EMOJI <<< "$OPTARG" ;;
            l    ) USE_FULLCOLOR_ICONS=true ;;
            L    ) PROGRESS_PLACEMENT=$OPTARG ;;
            n    ) DISPLAY_NOTIFICATIONS=true ;;
            N    ) NOTIFICATION_METHOD=$OPTARG ;;
            p    ) SHOW_VOLUME_PROGRESS=true ;;
            P    ) PLAY_SOUND=true ;;
            s    ) NODE_NAME=$OPTARG ;;
            S    ) SYMBOLIC_ICON_SUFFIX=$OPTARG ;;
            t    ) STATUSLINE=$OPTARG ;;
            u    ) SIGNAL=$OPTARG ;;
            I    ) SOURCE_NAME=$OPTARG ;;
            D    ) DEFAULT_STEP=$OPTARG
                   save_config_value "DEFAULT_STEP" "$OPTARG" ;;
            y    ) USE_DUNSTIFY=true ;;
            h | *) usage ;;
        esac
    done

    read -ra CMDARGS <<< "${OPTARR[@]:$((OPTIND-1))}"
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    case "$COMMAND" in
        up|raise|increase)
            case "$#" in
                0) increase_volume ;;
                1) increase_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        down|lower|decrease)
            case "$#" in
                0) decrease_volume ;;
                1) decrease_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        set)
            case "$#" in 1) ;; *) usage ;; esac
            case "$1" in
                +*) increase_volume "${1:1}" ;;
                -*) decrease_volume "${1:1}" ;;
                *) set_volume "$1" ;;
            esac
            ;;
        mute) toggle_mute ;;
        fade)
            case "$#" in
                2)
                    # fade <from> <to> - uses default duration (500ms)
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" 500 "$NODE_ID"
                    ;;
                3)
                    # fade <from> <to> <duration_ms>
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local -r duration=$3
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" "$duration" "$NODE_ID"
                    ;;
                *)
                    error "Usage: fade <from> <to> [duration_ms]"
                    echo "  ${COLOR_GREEN}fade 0 100${COLOR_RESET}        - fade from 0% to 100% (default 500ms)"
                    echo "  ${COLOR_GREEN}fade 0 100 2000${COLOR_RESET}  - fade from 0% to 100% over 2000ms"
                    EXITCODE=$EX_USAGE
                    return 1
                    ;;
            esac
            ;;
        mic)
            case "$#" in
                0) usage ;;
                1)
                    case "$1" in
                        mute) toggle_mic_mute ;;
                        up|raise|increase) increase_mic_volume ;;
                        down|lower|decrease) decrease_mic_volume ;;
                        *) usage ;;
                    esac
                    ;;
                2)
                    case "$1" in
                        up|raise|increase) increase_mic_volume "$2" ;;
                        down|lower|decrease) decrease_mic_volume "$2" ;;
                        set)
                            case "$2" in
                                +*) increase_mic_volume "${2:1}" ;;
                                -*) decrease_mic_volume "${2:1}" ;;
                                *) set_mic_volume "$2" ;;
                            esac
                            ;;
                        *) usage ;;
                    esac
                    ;;
                *) usage ;;
            esac
            ;;
        listen) listen "$*" ;;
        list)
            case "$#" in
                0) list "" ;;
                1) list "$1" ;;
                *) usage ;;
            esac
            ;;
        switch)
            case "$#" in
                0) switch_sink ;;
                1) switch_sink "$1" ;;
                *) usage ;;
            esac
            ;;
        next) next_sink ;;
        prev|previous) prev_sink ;;
        port)
            case "$#" in
                0) port "" ;;
                1) port "$1" ;;
                2) port "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        profile)
            case "$#" in
                0) profile "" ;;
                1) profile "$1" ;;
                2) profile "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        boost)
            case "$#" in
                0) boost "" ;;
                1) boost "$1" ;;
                2) boost "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        output)
            case "$#" in 0) usage ;; esac
            output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        outputs) list_output_formats ;;
        notifications) list_notification_methods ;;
        *) usage ;;
    esac
}

play_volume_changed() {
    $PLAY_SOUND || return

    # Sound can be handled by the notification method
    if $DISPLAY_NOTIFICATIONS && has_capability sound; then return; fi

    if $USE_CANBERRA; then ca_play "$SOUND_VOLUME_CHANGED" "Volume Changed"
    else pw_play "$SOUND_VOLUME_CHANGED"; fi
}

ca_play() {
    local -r file=$1 desc=$2
    local executable="${CANBERRA_PATH:+${CANBERRA_PATH%/}/}canberra-gtk-play"

    command_exists "$executable" || { error "$executable not found. Please install it or set CANBERRA_PATH to the correct path."; return 1; }

    if [[ -f $file ]]; then "$executable" -f "$file" -d "$desc"
    else "$executable" -i "audio-volume-change" -d "$desc"
    fi
}

post_command_hook() {
    if is_command_hookable "$COMMAND"; then
        # Check if this was a mic command
        if [[ $COMMAND == "mic" ]]; then
            show_mic_notification
            play_volume_changed
            update_statusbar || usage
        else
            show_volume_notification
            play_volume_changed
            update_statusbar || usage
        fi
    fi
}

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Commands which will not use post_command_hook(), usually because
    # they handle notifications and/or statusbar updates manually
    declare -a POST_HOOK_EXEMPT_COMMANDS=(
        listen
        notifications
        outputs
        list
        switch
        next
        prev
        port
        profile
    )

    # Exit codes
    declare -ir EX_OK=0 EX_URGENT=33 EX_USAGE=64 EX_UNAVAILABLE=69

    # Main program exit code
    declare -i EXITCODE=$EX_OK

    # Standard notification icons. Usually full color
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS=(
        audio-volume-muted
        audio-volume-high
        audio-volume-low
        audio-volume-medium
    )

    # Symbolic notification icons. Usually low color or monochrome
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS_SYMBOLIC=(
        audio-volume-muted-symbolic
        audio-volume-high-symbolic
        audio-volume-low-symbolic
        audio-volume-medium-symbolic
        ## Only exists in some icon sets
        # audio-volume-overamplified-symbolic
    )

    # Emoji-based icons.
    declare -a ICONS_EMOJI=(     )

    # Volume changed sound.
    declare SOUND_VOLUME_CHANGED=${SOUND_VOLUME_CHANGED:-/usr/share/sounds/freedesktop/stereo/audio-volume-change.oga}

    # DBUS constants
    declare -r \
        DBUS_NAME=org.freedesktop.Notifications \
        DBUS_PATH=/org/freedesktop/Notifications \
        DBUS_IFAC_FDN=org.freedesktop.Notifications

    # Notification server information
    declare \
        NOTIFY_SERVER
        # NOTIFY_VENDOR \
        # NOTIFY_VERSION \
        # NOTIFY_SPEC_VERSION

    # Notification capabilities
    declare -a NOTIFY_CAPS=()

    # PipeWire node aliases
    declare -gA NODE_ALIASES=()

    declare -i DEFAULT_VOL=100 MIN_VOL=0 MAX_VOL=100
    declare -i DEFAULT_STEP=${DEFAULT_STEP:-5}

    # Cached output of `pw-dump`; so we don't have to call it each time we need it
    declare PW_DUMP=""

    # Colors
    declare -r \
        COLOR_MUTED=${COLOR_MUTED:-#FFFF00} \
        COLOR_MIN_TO_DEFAULT=${COLOR_MIN_TO_DEFAULT:-#00FF00} \
        COLOR_FULL=${COLOR_FULL:-#FFFF00} \
        COLOR_FULL_TO_MAX=${COLOR_FULL_TO_MAX:-#FF0000} \
        COLOR_OTHER=${COLOR_OTHER:-#FFFFFF} \
        COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-#222222} \
        COLOR_TEXT=${COLOR_TEXT:-#FFFF00}

    declare COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_MAGENTA COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################
    declare NOTIFICATION_METHOD=""

    declare \
        COMMAND="" \
        DISPLAY_NOTIFICATIONS=false \
        SHOW_VOLUME_PROGRESS=false \
        USE_DUNSTIFY=false \
        USE_FULLCOLOR_ICONS=false \
        PROGRESS_PLACEMENT=summary \
        SIGNAL="" \
        NODE_NAME="" \
        NODE_ID="" \
        SOURCE_NAME="" \
        SOURCE_ID="" \
        STATUSLINE="" \
        SYMBOLIC_ICON_SUFFIX="" \
        PLAY_SOUND=false \
        USE_CANBERRA=false \
        FADE_DURATION=""

    declare -i EXPIRES=1500

    define_helpers
    define_notify
    define_output_formats
    define_commands

    init_color

    load_config
    parse_opts "$@"

    # Requires options to be parsed first
    init_audio
    init_source

    exec_command "${CMDARGS[*]}" && post_command_hook

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
