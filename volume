#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications.
#
#  Dependencies:
#      awk
#      jq
#      WirePlumber
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume
#  Wiki: https://github.com/hastinbe/i3-volume/wiki/

define_helpers() {
    empty()               { [[ -z $1 ]]; }
    not_empty()           { [[ -n $1 ]]; }
    isset()               { [[ -v $1 ]]; }
    command_exists()      { command -v "$1" >/dev/null 2>&1; }
    error()               { echo "$COLOR_RED$*$COLOR_RESET"; }
    has_color()           { [ "$(tput colors)" -ge 8 ] &>/dev/null && [ -t 1 ]; }
    ms_to_secs()          { echo "scale=0; (${1} + 999) / 1000" | bc; }
    is_command_hookable() { ! [[ ${POST_HOOK_EXEMPT_COMMANDS[*]} =~ $1 ]]; }
    has_capability()      { [[ "${NOTIFY_CAPS[*]}" =~ $1 ]]; }
    max()                 { echo $(( $1 > $2 ? $1 : $2 )); }
}

define_notify() {
    # Display a notification indicating muted or current volume.
    notify_volume() {
        local -r vol=$(get_volume)
        local icon
        local summary
        local body=""

        if is_muted; then
            summary="Volume muted"

            if $USE_FULLCOLOR_ICONS; then
                icon=${ICONS[0]}
            else
                icon=${ICONS_SYMBOLIC[0]}
            fi
        else
            printf -v summary "Volume %3s%%" "$vol"

            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")

                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then
                    body="$progress"
                else
                    summary="$summary $progress"
                fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "$body" ;;
        esac
    }

    list_notification_methods() {
        local source="${BASH_SOURCE[0]}"
        awk -v source="$source" '
            match($0, / +notify_volume_([[:alnum:]]+)\(\)/) {
                print substr($0, RSTART + 18, RLENGTH - 20) > "/dev/stdout"
            }
        ' "$source" || exit "$EX_USAGE"
        exit "$EX_OK"
    }

    setup_notification_icons() {
        not_empty "$SYMBOLIC_ICON_SUFFIX" && apply_symbolic_icon_suffix;
    }

    show_volume_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_volume
    }

    load_notify_server_info() {
        command_exists dbus-send || return
        IFS=$'\t' read -r NOTIFY_SERVER _ _ _ < <(dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.GetServerInformation | awk 'BEGIN { ORS="\t" }; match($0, /^   string ".*"/) {print substr($0, RSTART+11, RLENGTH-12)}')
    }

    load_notify_server_caps() {
        command_exists dbus-send || return
        IFS= read -r -d '' -a NOTIFY_CAPS < <(dbus-send --print-reply=literal --dest="${DBUS_NAME}" "${DBUS_PATH}" "${DBUS_IFAC_FDN}.GetCapabilities" | awk 'RS="      " { if (NR > 2) print $1 }')
    }

    notify_volume_libnotify() {
        local -r vol=$1
        local -r icon=$2
        local -r summary=$3
        local -r body=${*:4}
        local args=(
            '-t' "$EXPIRES"
        )
        local hints=(
            # Replaces previous notification in some notification servers
            'string:synchronous:volume'
            # Replaces previous notification in NotifyOSD
            'string:x-canonical-private-synchronous:volume'
        )
        local executable

        # If we're not drawing our own progress bar, allow the notification daemon to draw its own (if supported)
        $SHOW_VOLUME_PROGRESS || hints+=( "int:value:$vol" )

        # (( ${#NOTIFY_CAPS[@]} < 1 )) && load_notify_server_caps
        [[ ${#NOTIFY_CAPS[@]} -lt 1 ]] && load_notify_server_caps

        if has_capability icon-static || has_capability icon-multi; then
            # haskell-notification-daemon (aka deadd-notification-center) does not support -i|--icon, but supports string:image-path
            args+=( '-i' "$icon" )
            hints+=( "string:image-path:$icon" )
        fi

        $PLAY_SOUND && has_capability sound && hints+=( "string:sound-name:audio-volume-change" )

        if [[ $NOTIFICATION_METHOD == "dunst" ]]; then
            hints+=( "string:x-dunst-stack-tag:volume" )

            if ! isset NO_NOTIFY_COLOR; then
                if is_muted; then
                    hints+=( "string:fgcolor:$COLOR_MUTED" )
                else
                    hints+=( "string:fgcolor:$(volume_color "$vol")" )
                fi
            fi
        fi

        if $USE_DUNSTIFY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}dunstify"

            args+=( '-r' 1000 )

            # Transient notifications will bypass the idle_threshold setting.
            # Should be boolean, but Notify-OSD doesn't support boolean yet. Dunst checks
            # for int and bool with transient so lets play nice with both servers.
            hints+=( "int:transient:1" )
        elif isset USE_NOTIFY_SEND_PY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send.py"

            # Replaces previous notification, but leaves itself running in the bg to work
            args+=( --replaces-process volume )

            # By-pass the server's persistence capability, if it should exist
            hints+=( "boolean:transient:true" )

            # Prefix all hints with --hint to work with notify-send.py
            hints=( "${hints[@]/#/--hint }" )
        else
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send"
        fi

        command_exists "$executable" || {
            error "$executable not found. Please install it or set NOTIFY_PATH to the correct path."
            exit "$EX_UNAVAILABLE"
        }

        read -ra hints <<< "${hints[@]/#/-h }"

        "$executable" "${hints[@]}" "${args[@]}" "$summary" "$body" &
    }

    notify_volume_xosd() {
        local -r vol=$1
        local -r text=${*:2}
        local percentage
        local executable

        if is_muted; then
            color=$COLOR_MUTED
            percentage=0
        else
            color=$(volume_color "$vol")
            percentage=$vol
        fi

        executable="${XOSD_PATH:+${XOSD_PATH%/}/}osd_cat"

        command_exists "$executable" || {
            error "$executable not found. Please install it or set XOSD_PATH to the correct path."
            exit "$EX_UNAVAILABLE"
        }

        "$executable" \
            --align center \
            -b percentage \
            -P "$percentage" \
            -d "$(ms_to_secs "$EXPIRES")" \
            -p top \
            -A center \
            -c "$color" \
            -T "$text" \
            -O 2 \
            -u "$COLOR_XOSD_OUTLINE" & disown
    }

    # Note: a patch with a notify-send script for herbe, not in the current version at this
    #       time but would make this irrelevant. See https://github.com/dudik/herbe/pull/10
    notify_volume_herbe() {
        local -r text=$*
        local executable

        # Dismiss existing/pending notifications to prevent queuing
        pkill -SIGUSR1 herbe

        executable="${HERBE_PATH:+${HERBE_PATH%/}/}herbe"

        command_exists "$executable" || {
            error "$executable not found. Please install it or set HERBE_PATH to the correct path."
            exit "$EX_UNAVAILABLE"
        }

        "$executable" "$text" & disown
    }

    notify_volume_volnoti() {
        local -r vol=$1
        local executable
        executable="${VOLNOTI_PATH:+${VOLNOTI_PATH%/}/}volnoti-show"

        command_exists "$executable" || {
            error "$executable not found. Please install it or set VOLNOTI_PATH to the correct path."
            exit "$EX_UNAVAILABLE"
        }

        if is_muted; then
            "$executable" -m "$vol"
        else
            "$executable" "$vol"
        fi
    }

    notify_volume_kosd() {
        local -r vol=$1
        local -r muted=$(is_muted && echo 1 || echo 0)
        qdbus org.kde.kded /modules/kosd showVolume "$vol" "$muted"
    }
}

define_output_formats() {
    output_volume_default() {
        if is_muted; then
            echo MUTE
        else
            echo "$(get_volume)%"
        fi
    }

    # Format options:
    #   %v = volume percentage or "MUTE" when muted
    #   %n = node display name/alias
    #   %d = node id
    #   %p = volume progress bar
    #   %i = volume icon
    output_volume_custom() {
        local -r vol=$(get_volume)
        local -r format=${1//\%v/$vol%}
        local string=${format//\%n/$(get_node_display_name)}
        string=${string//\%d/$NODE_ID}
        string=${string//\%p/$(progress_bar "$vol")}
        string=${string//\%i/$(get_volume_emoji "$vol")}

        if is_muted; then
            echo -ne "${string//\%v/MUTED}"
        else
            echo -ne "$string"
        fi
    }

    output_volume_i3blocks() {
        local -r name=$(get_node_display_name)
        local short_text

        if is_muted; then
            short_text="<span color=\"$COLOR_MUTED\">MUTED</span>\n"
        else
            local -r vol=$(get_volume)
            short_text="<span color=\"$(volume_color "$vol")\">${vol}%</span>\n"
            isset MAX_VOL && (( vol > MAX_VOL )) && EXITCODE=$EX_URGENT
        fi

        local full_text=${short_text}
        not_empty "$name" && full_text="<span color=\"$COLOR_TEXT\">$name</span> $short_text"

        echo -ne "$full_text$short_text"
    }

    # Outputs the current volume for xob.
    output_volume_xob() {
        local -ir vol=$(get_volume)

        if is_muted; then
            echo "${vol}!"
        else
            echo "$vol"
        fi
    }
}

define_commands() {
    set_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        if not_empty "$MAX_VOL"; then
            case "$op" in
                +)  # Increase volume
                    local -r curr_vol=$(get_volume)
                    if (( curr_vol + vol > MAX_VOL )); then
                        # Instead of doing nothing, step to max_volume
                        local -r step=$( max "0" "$(( MAX_VOL - curr_vol ))" )
                        wpctl set-volume "$NODE_ID" "$step%+"
                        return
                    fi
                    ;;
                *)  # Set absolute volume
                    if (( vol > MAX_VOL )); then
                        return
                    fi
                    ;;
            esac
        fi

        invalidate_cache

        case "$op" in
            +) wpctl set-volume "$NODE_ID" "${vol}%+" ;;
            -) wpctl set-volume "$NODE_ID" "${vol}%-" ;;
            *) wpctl set-volume "$NODE_ID" "${vol}%" ;;
        esac
    }

    increase_volume() {
        set_volume "${1:?$(error 'Step is required')}" "+"
    }

    decrease_volume() {
        set_volume "${1:?$(error 'Step is required')}" "-"
    }

    toggle_mute() {
        invalidate_cache
        wpctl set-mute "$NODE_ID" toggle
    }

    output_volume() {
        local -r for=${1:?$(error 'Output method is required')}

        case "$for" in
            i3blocks ) output_volume_i3blocks ;;
            xob      ) output_volume_xob ;;
            default  ) output_volume_default ;;
            *        ) output_volume_custom "$*" ;;
        esac
    }

    list_output_formats() {
        awk 'match($0,/ +output_volume_([[:alnum:]]+)\(\)/) {print substr($0, RSTART + 18, RLENGTH - 20)}' "${BASH_SOURCE[0]}" || exit "$EX_USAGE"
        exit "$EX_OK"
    }

    usage() {
        cat <<- EOF 1>&2
${COLOR_YELLOW}Usage:${COLOR_RESET} $0 [<options>] <command> [<args>]
Control volume and related notifications.

${COLOR_YELLOW}Commands:${COLOR_RESET}
  ${COLOR_GREEN}up <value>${COLOR_RESET}                  increase volume
  ${COLOR_GREEN}down <value>${COLOR_RESET}                decrease volume
  ${COLOR_GREEN}set <value>${COLOR_RESET}                 set volume
  ${COLOR_GREEN}mute${COLOR_RESET}                        toggle mute
  ${COLOR_GREEN}listen${COLOR_RESET}                      listen for changes to a PipeWire sink
  ${COLOR_GREEN}output <format>${COLOR_RESET}             output volume in a supported format
                              custom format substitutions:
                                  %v = volume
                                  %s = sink name (PipeWire only)
                                  %p = volume progress bar
                                  %i = volume icon/emoji
                                  %P = active port description (PipeWire only)

                                  examples:
                                      "Volume is %v" = Volume is 50%
                                      "%i %v %p \n"  = 奔 50% ██████████
  ${COLOR_GREEN}outputs${COLOR_RESET}                     show available output formats
  ${COLOR_GREEN}notifications${COLOR_RESET}               show available notification methods
  ${COLOR_GREEN}help${COLOR_RESET}                        display help

${COLOR_YELLOW}Options:${COLOR_RESET}
  ${COLOR_GREEN}-n${COLOR_RESET}                          enable notifications
  ${COLOR_GREEN}-C${COLOR_RESET}                          use libcanberra for playing event sounds
  ${COLOR_GREEN}-P${COLOR_RESET}                          play sound for volume changes
  ${COLOR_GREEN}-j <muted,high,low,medium>${COLOR_RESET}  specify custom volume emojis as a comma separated list
  ${COLOR_GREEN}-t <process_name>${COLOR_RESET}           process name of status bar (${COLOR_MAGENTA}requires -u${COLOR_RESET})
  ${COLOR_GREEN}-u <signal>${COLOR_RESET}                 signal to update status bar (${COLOR_MAGENTA}requires -t${COLOR_RESET})
  ${COLOR_GREEN}-x <value>${COLOR_RESET}                  maximum volume
  ${COLOR_GREEN}-X <value>${COLOR_RESET}                  maximum amplification; if supported (${COLOR_MAGENTA}default: 2${COLOR_RESET})
  ${COLOR_GREEN}-h${COLOR_RESET}                          display help

${COLOR_YELLOW}PipeWire Options:${COLOR_RESET}
  ${COLOR_GREEN}-s <sink>${COLOR_RESET}                   symbolic name of sink

${COLOR_YELLOW}Notification Options:${COLOR_RESET}
  ${COLOR_GREEN}-N <method>${COLOR_RESET}                 notification method (${COLOR_MAGENTA}default: libnotify${COLOR_RESET})
  ${COLOR_GREEN}-p${COLOR_RESET}                          enable progress bar
  ${COLOR_GREEN}-L <placement>${COLOR_RESET}              progress bar placement (${COLOR_MAGENTA}default: summary${COLOR_RESET}; ${COLOR_MAGENTA}requires -p${COLOR_RESET})
                              placements:
                                  body
                                  summary
  ${COLOR_GREEN}-e <expires>${COLOR_RESET}                expiration time of notifications in ms
  ${COLOR_GREEN}-l${COLOR_RESET}                          use fullcolor instead of symbolic icons
  ${COLOR_GREEN}-S <suffix>${COLOR_RESET}                 append suffix to symbolic icon names
  ${COLOR_GREEN}-y${COLOR_RESET}                          use dunstify (${COLOR_MAGENTA}default: notify-send${COLOR_RESET})

${COLOR_YELLOW}Environment Variables:${COLOR_RESET}
  ${COLOR_CYAN}XOSD_PATH${COLOR_RESET}                   path to osd_cat
  ${COLOR_CYAN}HERBE_PATH${COLOR_RESET}                  path to herbe
  ${COLOR_CYAN}VOLNOTI_PATH${COLOR_RESET}                path to volnoti-show
  ${COLOR_CYAN}CANBERRA_PATH${COLOR_RESET}               path to canberra-gtk-play
  ${COLOR_CYAN}NOTIFY_PATH${COLOR_RESET}                 path to command that sends notifications
  ${COLOR_CYAN}NO_NOTIFY_COLOR${COLOR_RESET}             flag to disable colors in notifications
  ${COLOR_CYAN}USE_NOTIFY_SEND_PY${COLOR_RESET}          flag to use notify-send.py instead of notify-send
EOF
        exit "$EX_USAGE"
    }
}

get_volume() { wpctl get-volume "$NODE_ID" | awk '{print $2 * 100}'; }
is_muted() { wpctl get-volume "$NODE_ID" | grep -q '\[MUTED\]'; }

get_volume_icon() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if $USE_FULLCOLOR_ICONS; then
        if (( vol >= 70 )); then icon=${ICONS[1]}
        elif (( vol >= 40 )); then icon=${ICONS[3]}
        elif (( vol > 0 )); then icon=${ICONS[2]}
        else icon=${ICONS[2]}
        fi
    else
        # Get overamplified icon if available, otherwise default to high volume icon
        if (( vol > 100 )); then icon=${ICONS_SYMBOLIC[4]:-${ICONS_SYMBOLIC[1]}}
        elif (( vol >= 70 )); then icon=${ICONS_SYMBOLIC[1]}
        elif (( vol >= 40 )); then icon=${ICONS_SYMBOLIC[3]}
        elif (( vol > 0 )); then icon=${ICONS_SYMBOLIC[2]}
        else icon=${ICONS_SYMBOLIC[2]}
        fi
    fi

    echo "$icon"
}

get_volume_emoji() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if is_muted; then
        icon=${ICONS_EMOJI[0]}
    else
        if (( vol >= 70 )); then icon=${ICONS_EMOJI[1]}
        elif (( vol >= 40 )); then icon=${ICONS_EMOJI[3]}
        elif (( vol > 0 )); then icon=${ICONS_EMOJI[2]}
        else icon=${ICONS_EMOJI[2]}
        fi
    fi

    echo "$icon"
}

update_statusline() {
    local -r signal=${1:?$(error 'Signal is required')}
    local -r proc=${2:?$(error 'Process name is required')}
    pkill "-$signal" "$proc"
}

# Arguments:
#   Percentage      (integer) Percentage of progress.
#   Maximum         (integer) Maximum percentage. (default: 100)
#   Divisor         (integer) For calculating the ratio of blocks to progress (default: 5)
#
# Returns:
#   The progress bar.
progress_bar() {
    local -r percent=${1:?$(error 'Percentage is required')}
    local -r max_percent=${2:-100}
    local -r divisor=${3:-5}
    local -r normalized=$(( percent > max_percent ? max_percent : percent ))
    local -r progress=$(( normalized / divisor ))

    printf -v bar "%*s" $progress ""
    echo "${bar// /█}"
}

apply_symbolic_icon_suffix() {
    for i in "${!ICONS_SYMBOLIC[@]}"; do
        ICONS_SYMBOLIC[i]="${ICONS_SYMBOLIC[i]}${SYMBOLIC_ICON_SUFFIX}"
    done
}

volume_color() {
    local -ir vol=${1:?$(error 'A volume is required')}

    if (( vol >= MIN_VOL && vol < DEFAULT_VOL )); then
        echo "$COLOR_MIN_TO_DEFAULT"
    elif (( vol == 100 )); then
        echo "$COLOR_FULL"
    elif (( vol > 100 && vol <= MAX_VOL )); then
        echo "$COLOR_FULL_TO_MAX"
    else
        echo "$COLOR_OTHER"
    fi
}

# Returns
#   0 when both signal and statusline are set
#   1 when one of signal or statusline are set but not both
update_statusbar() {
    if not_empty "$SIGNAL" && empty "$STATUSLINE"; then
        return 1
    fi

    if not_empty "$SIGNAL"; then
        update_statusline "$SIGNAL" "$STATUSLINE"
    elif not_empty "$STATUSLINE"; then
        return 1
    fi

    return 0
}

init_audio() {
    if empty "$NODE_NAME"; then
        NODE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SINK@ | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    NODE_ID=$(get_node_id)
    NODE_NICK=$(get_node_nick)
    DEFAULT_VOL=$(get_default_volume)
    MIN_VOL=$(get_min_volume)
    MAX_VOL=$(get_max_volume)
}

get_node_id() {
    pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$NODE_NAME"'") | .id'
}

get_node_nick() {
    pw_dump | jq -r '.[] | select(.id == '$NODE_ID') | .info.props."node.nick"'
}

get_node_display_name() {
    if isset NODE_ALIASES[$NODE_ID]; then
        echo "${NODE_ALIASES[$NODE_ID]}"
    elif isset NODE_ALIASES[$NODE_NAME]; then
        echo "${NODE_ALIASES[$NODE_NAME]}"
    elif isset NODE_ALIASES["$NODE_NICK"]; then
        echo "${NODE_ALIASES[$NODE_NICK]}"
    else
        get_node_nick
    fi
}

# get_node_name_by_id() {
#     local -r id=${1:?$(error 'Node ID is required')}
#     wpctl inspect "$id" | jq -r '.info.props."node.name"'
# }

# dump_node() {
#     local -r name=${1:?$(error 'Node name is required')}
#     pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$name"'")'
# }

pw_dump() {
    if [[ $COMMAND == "listen" ]] || empty "$PW_DUMP"; then
        PW_DUMP=$(pw-dump)
    fi
    echo "$PW_DUMP"
}

invalidate_cache() { PW_DUMP=""; }

# Listens for PipeWire events
#
# Arguments:
#   Output    (optional) (string) An output mode. When set, outputs volume in the output mode format.
listen() {
    local -r output=$*

    # Output volume so status bars have something to display before any event occurs
    not_empty "$output" && output_volume "$output"

    # Monitor events and filter for the sink ID
    pw-cli subscribe | stdbuf -oL grep -F "object.id = $NODE_ID" | while IFS= read -r event; do
        show_volume_notification
        update_statusbar
        play_volume_changed
        not_empty "$output" && output_volume "$output"
    done
}

pw_play() {
    local -r file=$1

    command_exists pw-play || {
        error "pw-play is not installed or not in \$PATH"
        return 1
    }

    pw-play --target "$NODE_ID" "$file" &
}

get_volume_info() {
    local -r type=${1:?$(error 'Volume type (default/min/max) is required')}
    local vol

    vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "volume") | .type.'$type'' 2>/dev/null)

    if empty "$vol"; then
        echo "Error: $type volume information not found for NODE_ID=$NODE_ID" >&2
        return 1
    fi

    echo "$vol" | awk '{print $1 * 100}'
}

get_default_volume() { get_volume_info "default"; }
get_min_volume() { get_volume_info "min"; }
get_max_volume() { get_volume_info "max"; }

init_color() {
    if has_color; then
        COLOR_RESET=$'\033[0m'
        COLOR_RED=$'\033[0;31m'
        COLOR_GREEN=$'\033[0;32m'
        COLOR_YELLOW=$'\033[0;33m'
        COLOR_MAGENTA=$'\033[0;35m'
        COLOR_CYAN=$'\033[0;36m'
    fi
}

load_config() {
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    # shellcheck source=/dev/null
    [[ -f $config ]] && source "$config"

    # Set defaults if not defined in config
    : "${NOTIFICATION_METHOD:=libnotify}"
}

# Rearrange all options to place flags first
# Author: greycat
# URL: https://mywiki.wooledge.org/ComplexOptionParsing
arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=:A:Ce:hj:lL:nN:pPs:S:t:u:y

    arrange_opts "$optstring" "$@"
    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            A    ) IFS=: read -r node alias <<< "$OPTARG"
                   NODE_ALIASES[$node]=$alias ;;
            C    ) USE_CANBERRA=true ;;
            e    ) EXPIRES=$OPTARG ;;
            j    ) IFS=, read -ra ICONS_EMOJI <<< "$OPTARG" ;;
            l    ) USE_FULLCOLOR_ICONS=true ;;
            L    ) PROGRESS_PLACEMENT=$OPTARG ;;
            n    ) DISPLAY_NOTIFICATIONS=true ;;
            N    ) NOTIFICATION_METHOD=$OPTARG ;;
            p    ) SHOW_VOLUME_PROGRESS=true ;;
            P    ) PLAY_SOUND=true ;;
            s    ) NODE_NAME=$OPTARG ;;
            S    ) SYMBOLIC_ICON_SUFFIX=$OPTARG ;;
            t    ) STATUSLINE=$OPTARG ;;
            u    ) SIGNAL=$OPTARG ;;
            y    ) USE_DUNSTIFY=true ;;
            h | *) usage ;;
        esac
    done

    read -ra CMDARGS <<< "${OPTARR[@]:$((OPTIND-1))}"
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    case "$COMMAND" in
        up|raise|increase)
            case "$#" in 1) ;; *) usage ;; esac
            increase_volume "$1"
            ;;
        down|lower|decrease)
            case "$#" in 1) ;; *) usage ;; esac
            decrease_volume "$1"
            ;;
        set)
            case "$#" in 1) ;; *) usage ;; esac
            case "$1" in
                +*) increase_volume "${1:1}" ;;
                -*) decrease_volume "${1:1}" ;;
                *) set_volume "$1" ;;
            esac
            ;;
        mute)
            toggle_mute
            ;;
        listen)
            listen "$*"
            ;;
        output)
            case "$#" in 0) usage ;; esac
            output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        outputs)
            list_output_formats
            ;;
        notifications)
            list_notification_methods
            ;;
        *)
            usage
            ;;
    esac
}

play_volume_changed() {
    $PLAY_SOUND || return

    # Sound can be handled by the notification method
    if $DISPLAY_NOTIFICATIONS && has_capability sound; then
        return
    fi

    if $USE_CANBERRA; then
        ca_play "$SOUND_VOLUME_CHANGED" "Volume Changed"
    else
        pw_play "$SOUND_VOLUME_CHANGED"
    fi
}

ca_play() {
    local -r file=$1 desc=$2
    local executable="${CANBERRA_PATH:+${CANBERRA_PATH%/}/}canberra-gtk-play"

    command_exists "$executable" || {
        error "$executable not found. Please install it or set NOTIFY_PATH to the correct path."
        return 1
    }

    if [[ -f $file ]]; then
        "$executable" -f "$file" -d "$desc"
    else
        "$executable" -i "audio-volume-change" -d "$desc"
    fi
}

post_command_hook() {
    if is_command_hookable "$COMMAND"; then
        show_volume_notification
        play_volume_changed
        update_statusbar || usage
    fi
}

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Commands which will not use post_command_hook(), usually because
    # they handle notifications and/or statusbar updates manually
    declare -a POST_HOOK_EXEMPT_COMMANDS=(
        listen
    )

    # Exit codes
    declare -ir \
        EX_OK=0 \
        EX_URGENT=33 \
        EX_USAGE=64 \
        EX_UNAVAILABLE=69

    # Main program exit code
    declare -i EXITCODE=$EX_OK

    # Standard notification icons. Usually full color
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS=(
        audio-volume-muted
        audio-volume-high
        audio-volume-low
        audio-volume-medium
    )

    # Symbolic notification icons. Usually low color or monochrome
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS_SYMBOLIC=(
        audio-volume-muted-symbolic
        audio-volume-high-symbolic
        audio-volume-low-symbolic
        audio-volume-medium-symbolic
        ## Only exists in some icon sets
        # audio-volume-overamplified-symbolic
    )

    # Emoji-based icons.
    declare -a ICONS_EMOJI=(
        ﱝ
        墳
        奄
        奔
    )

    # Volume changed sound.
    declare SOUND_VOLUME_CHANGED=${SOUND_VOLUME_CHANGED:-/usr/share/sounds/freedesktop/stereo/audio-volume-change.oga}

    # DBUS constants
    declare -r \
        DBUS_NAME=org.freedesktop.Notifications \
        DBUS_PATH=/org/freedesktop/Notifications \
        DBUS_IFAC_FDN=org.freedesktop.Notifications

    # Notification server information
    declare \
        NOTIFY_SERVER
        # NOTIFY_VENDOR \
        # NOTIFY_VERSION \
        # NOTIFY_SPEC_VERSION

    # Notification capabilities
    declare -a NOTIFY_CAPS=()

    # PipeWire node aliases
    declare -gA NODE_ALIASES=()

    declare -i \
        DEFAULT_VOL=100 \
        MIN_VOL=0 \
        MAX_VOL=100

    # Cached output of `pw-dump`; so we don't have to call it each time we need it
    declare PW_DUMP=""

    # Colors
    declare -r \
        COLOR_MUTED=${COLOR_MUTED:-#FFFF00} \
        COLOR_MIN_TO_DEFAULT=${COLOR_MIN_TO_DEFAULT:-#00FF00} \
        COLOR_FULL=${COLOR_FULL:-#FFFF00} \
        COLOR_FULL_TO_MAX=${COLOR_FULL_TO_MAX:-#FF0000} \
        COLOR_OTHER=${COLOR_OTHER:-#FFFFFF} \
        COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-#222222} \
        COLOR_TEXT=${COLOR_TEXT:-#FFFF00}

    declare \
        COLOR_RESET \
        COLOR_RED \
        COLOR_GREEN \
        COLOR_YELLOW \
        COLOR_MAGENTA \
        COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################
    declare NOTIFICATION_METHOD=""

    declare \
        COMMAND="" \
        DISPLAY_NOTIFICATIONS=false \
        SHOW_VOLUME_PROGRESS=false \
        USE_DUNSTIFY=false \
        USE_FULLCOLOR_ICONS=false \
        PROGRESS_PLACEMENT=summary \
        SIGNAL="" \
        NODE_NAME="" \
        NODE_ID="" \
        STATUSLINE="" \
        SYMBOLIC_ICON_SUFFIX="" \
        PLAY_SOUND=false \
        USE_CANBERRA=false

    declare -i EXPIRES=1500

    define_helpers
    define_notify
    define_output_formats
    define_commands

    init_color

    load_config
    parse_opts "$@"

    # Requires options to be parsed first
    init_audio
    exec_command "${CMDARGS[*]}" && post_command_hook

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
