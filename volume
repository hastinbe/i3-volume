#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications.
#
#  Dependencies: awk bc jq WirePlumber
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume
#  Wiki: https://github.com/hastinbe/i3-volume/wiki/

# Get script directory for module loading
SCRIPT_DIR=$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")

# Source modules in dependency order
source "$SCRIPT_DIR/lib/helpers.sh"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/audio.sh"
source "$SCRIPT_DIR/lib/notify.sh"
source "$SCRIPT_DIR/lib/output.sh"
source "$SCRIPT_DIR/lib/commands.sh"

arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            --no-notify)
                flags+=("-q")
                ;;
            --dry-run)
                flags+=("-d")
                ;;
            --exit-code)
                # Handle this in main() before command execution
                flags+=("--exit-code")
                ;;
            --log)
                flags+=("--log")
                # If next argument exists and looks like a log file path, include it
                if [[ $# -gt 1 ]] && [[ "$2" != -* ]]; then
                    local next_arg="$2"
                    # Only treat as log file if it looks like a path (starts with /, ., ~) or is "syslog"
                    if [[ "$next_arg" == "syslog" ]] || [[ "$next_arg" == /* ]] || [[ "$next_arg" == .* ]] || [[ "$next_arg" == ~* ]]; then
                        flags+=("$next_arg")
                        shift
                    fi
                fi
                ;;
            --debug)
                flags+=("--debug")
                ;;
            --watch|--all|--input|--volume-only|--mute-only)
                # These are listen command options, not global flags
                # Pass them through as command arguments
                args+=("$1")
                ;;
            -[0-9]*|-*.[0-9]*)
                # Negative numbers (e.g., -20, -2.0) should be treated as arguments, not options
                args+=("$1")
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=:A:Ce:ad:f:hj:lL:nN:pPs:S:t:u:vyI:D:qU:

    arrange_opts "$optstring" "$@"

    # Handle --log and --debug options (long options not handled by getopts)
    # Extract their values and remove them from OPTARR BEFORE getopts processes it
    local temp_arr=()
    local i=0
    while [[ $i -lt ${#OPTARR[@]} ]]; do
        case "${OPTARR[$i]}" in
            --log)
                # Extract log file value
                if [[ $((i+1)) -lt ${#OPTARR[@]} ]] && [[ ${OPTARR[$((i+1))]} != -* ]]; then
                    local next_arg="${OPTARR[$((i+1))]}"
                    # Only treat as log file if it looks like a path (starts with /, ., ~) or is "syslog"
                    if [[ "$next_arg" == "syslog" ]] || [[ "$next_arg" == /* ]] || [[ "$next_arg" == .* ]] || [[ "$next_arg" == ~* ]]; then
                        LOG_FILE="$next_arg"
                        ((i += 2))  # Skip both --log and its argument
                    else
                        # Not a log file path, default to syslog and keep the argument as a command
                        # Skip --log entirely (don't add to temp_arr), keep next arg for command extraction
                        LOG_FILE="syslog"
                        ((i++))  # Skip just --log, keep next arg
                    fi
                else
                    # Default to syslog if no file specified
                    LOG_FILE="syslog"
                    ((i++))  # Skip just --log
                fi
                ;;
            --debug)
                DEBUG_MODE=true
                ((i++))  # Skip --debug
                ;;
            *)
                # Keep all other arguments
                temp_arr+=("${OPTARR[$i]}")
                ((i++))
                ;;
        esac
    done
    OPTARR=("${temp_arr[@]}")

    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            A    ) IFS=: read -r node alias <<< "$OPTARG"
                   NODE_ALIASES[$node]=$alias ;;
            C    ) USE_CANBERRA=true ;;
            e    ) EXPIRES=$OPTARG ;;
            a    ) ALL_SINKS=true ;;
            d    ) DRY_RUN=true ;;
            f    ) FADE_DURATION=$OPTARG ;;
            j    ) IFS=, read -ra ICONS_EMOJI <<< "$OPTARG" ;;
            l    ) USE_FULLCOLOR_ICONS=true ;;
            L    ) PROGRESS_PLACEMENT=$OPTARG ;;
            n    ) DISPLAY_NOTIFICATIONS=true ;;
            N    ) NOTIFICATION_METHOD=$OPTARG ;;
            p    ) SHOW_VOLUME_PROGRESS=true ;;
            P    ) PLAY_SOUND=true ;;
            s    ) NODE_NAME=$OPTARG ;;
            S    ) SYMBOLIC_ICON_SUFFIX=$OPTARG ;;
            t    ) STATUSLINE=$OPTARG ;;
            u    ) SIGNAL=$OPTARG ;;
            v    ) VERBOSE=true ;;
            I    ) SOURCE_NAME=$OPTARG ;;
            D    ) DEFAULT_STEP=$OPTARG
                   save_config_value "DEFAULT_STEP" "$OPTARG" ;;
            y    ) USE_DUNSTIFY=true ;;
            q    ) DISPLAY_NOTIFICATIONS=false ;;
            U    ) VOLUME_DISPLAY_UNIT=$OPTARG ;;
            h | *) usage ;;
        esac
    done

    # Extract command arguments: skip all processed options
    # Since arrange_opts puts all flags first, then args, we need to find where flags end
    # Count how many elements in OPTARR are options (start with -)
    i=0
    while [[ $i -lt ${#OPTARR[@]} && ${OPTARR[$i]} == -* && ${OPTARR[$i]} != -- ]]; do
        # Check if this option takes an argument by looking it up in optstring
        local opt="${OPTARR[$i]#-}"
        local opt_char="${opt:0:1}"
        # Check if opt_char: appears in optstring (option char followed by colon means it takes an arg)
        # Simple substring match is sufficient since we're checking specific option chars
        if [[ "$optstring" == *"${opt_char}:"* ]] && [[ $((i+1)) -lt ${#OPTARR[@]} ]] && [[ ${OPTARR[$((i+1))]} != -* ]]; then
            ((i += 2))  # Skip option and its argument
        else
            ((i++))  # Skip just the option
        fi
    done
    # If we hit --, skip it too
    [[ $i -lt ${#OPTARR[@]} && ${OPTARR[$i]} == -- ]] && ((i++))
    # Extract remaining arguments as command
    if [[ $i -lt ${#OPTARR[@]} ]]; then
        CMDARGS=("${OPTARR[@]:$i}")
    else
        CMDARGS=()
    fi
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    # Log command execution
    if not_empty "${LOG_FILE:-}"; then
        log_command "$COMMAND" "$@"
    fi

    case "$COMMAND" in
        up|raise|increase)
            case "$#" in
                0) increase_volume ;;
                1) increase_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        down|lower|decrease)
            case "$#" in
                0) decrease_volume ;;
                1) decrease_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        set)
            case "$#" in 1) ;; *) usage ;; esac
            case "$1" in
                +*) increase_volume "${1:1}" ;;
                -*) decrease_volume "${1:1}" ;;
                *) set_volume "$1" ;;
            esac
            ;;
        wheel)
            case "$#" in
                0)
                    error "Wheel delta required. Use: wheel <delta>"
                    echo "  ${COLOR_GREEN}wheel 2.0${COLOR_RESET}   - scroll up (positive delta)"
                    echo "  ${COLOR_GREEN}wheel -2.0${COLOR_RESET}  - scroll down (negative delta)"
                    EXITCODE=$EX_USAGE
                    return 1
                    ;;
                1)
                    wheel_volume "$1"
                    ;;
                *)
                    usage
                    ;;
            esac
            ;;
        mute) toggle_mute ;;
        fade)
            case "$#" in
                2)
                    # fade <from> <to> - uses default duration (500ms)
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" 500 "$NODE_ID"
                    ;;
                3)
                    # fade <from> <to> <duration_ms>
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local -r duration=$3
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" "$duration" "$NODE_ID"
                    ;;
                *)
                    error "Usage: fade <from> <to> [duration_ms]"
                    echo "  ${COLOR_GREEN}fade 0 100${COLOR_RESET}        - fade from 0% to 100% (default 500ms)"
                    echo "  ${COLOR_GREEN}fade 0 100 2000${COLOR_RESET}  - fade from 0% to 100% over 2000ms"
                    EXITCODE=$EX_USAGE
                    return 1
                    ;;
            esac
            ;;
        mic)
            case "$#" in
                0) usage ;;
                1)
                    case "$1" in
                        mute) toggle_mic_mute ;;
                        up|raise|increase) increase_mic_volume ;;
                        down|lower|decrease) decrease_mic_volume ;;
                        *) usage ;;
                    esac
                    ;;
                2)
                    case "$1" in
                        up|raise|increase) increase_mic_volume "$2" ;;
                        down|lower|decrease) decrease_mic_volume "$2" ;;
                        set)
                            case "$2" in
                                +*) increase_mic_volume "${2:1}" ;;
                                -*) decrease_mic_volume "${2:1}" ;;
                                *) set_mic_volume "$2" ;;
                            esac
                            ;;
                        *) usage ;;
                    esac
                    ;;
                *) usage ;;
            esac
            ;;
        listen) listen "$*" ;;
        list)
            case "$#" in
                0) list "" ;;
                1) list "$1" ;;
                *) usage ;;
            esac
            ;;
        switch)
            case "$#" in
                0) switch_sink ;;
                1) switch_sink "$1" ;;
                *) usage ;;
            esac
            ;;
        next) next_sink ;;
        prev|previous) prev_sink ;;
        port)
            case "$#" in
                0) port "" ;;
                1) port "$1" ;;
                2) port "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        profile)
            case "$#" in
                0) profile "" ;;
                1) profile "$1" ;;
                2) profile "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        boost)
            case "$#" in
                0) boost "" ;;
                1) boost "$1" ;;
                2) boost "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        sync)
            case "$#" in
                0) sync_volume ;;
                *) usage ;;
            esac
            ;;
        app)
            case "$#" in
                0) app "" ;;
                1) app "$1" ;;
                2) app "$1" "$2" ;;
                3) app "$1" "$2" "$3" ;;
                4) app "$1" "$2" "$3" "$4" ;;
                *) usage ;;
            esac
            ;;
        output)
            case "$#" in 0) usage ;; esac
            output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        outputs) list_output_formats ;;
        notifications) list_notification_methods ;;
        config)
            case "$#" in
                0) config "" ;;
                1) config "$1" ;;
                2) config "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        balance)
            case "$#" in
                0)
                    # Show current balance
                    local current_balance
                    current_balance=$(get_balance 2>/dev/null || echo "0")
                    echo "Balance: $current_balance (0=center, negative=left, positive=right)"
                    ;;
                1)
                    case "$1" in
                        +*) set_balance "${1:1}" "+" ;;
                        -*) set_balance "${1:1}" "-" ;;
                        *) set_balance "$1" ;;
                    esac
                    ;;
                *) usage ;;
            esac
            ;;
        normalize)
            case "$#" in
                0) normalize suggest ;;
                1) normalize "$1" ;;
                2) normalize "$1" "$2" ;;
                3) normalize "$1" "$2" "$3" ;;
                *) usage ;;
            esac
            ;;
        undo)
            case "$#" in
                0) undo_volume ;;
                *) usage ;;
            esac
            ;;
        history)
            case "$#" in
                0) show_volume_history ;;
                1) show_volume_history "$1" ;;
                *) usage ;;
            esac
            ;;
        *) usage ;;
    esac
}

play_volume_changed() {
    $PLAY_SOUND || return

    # Sound can be handled by the notification method
    if $DISPLAY_NOTIFICATIONS && has_capability sound; then return; fi

    if $USE_CANBERRA; then ca_play "$SOUND_VOLUME_CHANGED" "Volume Changed"
    else pw_play "$SOUND_VOLUME_CHANGED"; fi
}

ca_play() {
    local -r file=$1 desc=$2
    local executable="${CANBERRA_PATH:+${CANBERRA_PATH%/}/}canberra-gtk-play"

    command_exists "$executable" || { error "$executable not found. Please install it or set CANBERRA_PATH to the correct path."; return 1; }

    if [[ -f $file ]]; then "$executable" -f "$file" -d "$desc"
    else "$executable" -i "audio-volume-change" -d "$desc"
    fi
}

post_command_hook() {
    if is_command_hookable "$COMMAND"; then
        # Check if this was a mic command
        if [[ $COMMAND == "mic" ]]; then
            show_mic_notification
            play_volume_changed
            update_statusbar || usage
        else
            show_volume_notification
            play_volume_changed
            update_statusbar || usage
        fi
    fi
}

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Commands which will not use post_command_hook(), usually because
    # they handle notifications and/or statusbar updates manually
    # shellcheck disable=SC2034  # Used externally by modules
    declare -ga POST_HOOK_EXEMPT_COMMANDS=(
        listen
        notifications
        outputs
        list
        switch
        next
        prev
        port
        profile
        sync
        app
        config
        normalize
        history
    )

    # Exit codes
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gir EX_OK=0 EX_URGENT=33 EX_USAGE=64 EX_UNAVAILABLE=69

    # Main program exit code
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gi EXITCODE=$EX_OK

    # Standard notification icons. Usually full color
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    # shellcheck disable=SC2034  # Used externally by modules
    declare -ga ICONS=(
        audio-volume-muted
        audio-volume-high
        audio-volume-low
        audio-volume-medium
    )

    # Symbolic notification icons. Usually low color or monochrome
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    # shellcheck disable=SC2034  # Used externally by modules
    declare -ga ICONS_SYMBOLIC=(
        audio-volume-muted-symbolic
        audio-volume-high-symbolic
        audio-volume-low-symbolic
        audio-volume-medium-symbolic
        ## Only exists in some icon sets
        # audio-volume-overamplified-symbolic
    )

    # Emoji-based icons.
    # shellcheck disable=SC2034  # Used externally by modules
    declare -ga ICONS_EMOJI=( ﱝ 墳 奄 奔 )

    # Volume changed sound.
    # shellcheck disable=SC2034  # Used externally by modules
    declare -g SOUND_VOLUME_CHANGED=${SOUND_VOLUME_CHANGED:-/usr/share/sounds/freedesktop/stereo/audio-volume-change.oga}

    # DBUS constants
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gr \
        DBUS_NAME=org.freedesktop.Notifications \
        DBUS_PATH=/org/freedesktop/Notifications \
        DBUS_IFAC_FDN=org.freedesktop.Notifications

    # Notification server information
    # shellcheck disable=SC2034  # Used externally by modules
    declare -g \
        NOTIFY_SERVER
        # NOTIFY_VENDOR \
        # NOTIFY_VERSION \
        # NOTIFY_SPEC_VERSION

    # Notification capabilities
    # shellcheck disable=SC2034  # Used externally by modules
    declare -ga NOTIFY_CAPS=()

    # PipeWire node aliases
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gA NODE_ALIASES=()

    # Per-sink configuration arrays
    # These can be keyed by sink ID, name, or nick
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gA SINK_MAX_VOL=()
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gA SINK_DEFAULT_STEP=()
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gA SINK_DISPLAY_NOTIFICATIONS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_NOTIFICATION_METHOD=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_USE_DUNSTIFY=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_USE_FULLCOLOR_ICONS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_SHOW_VOLUME_PROGRESS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_EXPIRES=()
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gA SINK_BALANCE=()

    # shellcheck disable=SC2034  # Used externally by modules
    declare -gi DEFAULT_VOL=100 MIN_VOL=0 MAX_VOL=100
    # shellcheck disable=SC2034  # Used externally by modules
    declare -gi DEFAULT_STEP=${DEFAULT_STEP:-5}

    # Cached output of `pw-dump`; so we don't have to call it each time we need it
    # shellcheck disable=SC2034  # Used externally by modules
    declare -g PW_DUMP=""

    # Colors
    declare -r \
        COLOR_MUTED=${COLOR_MUTED:-#FFFF00} \
        COLOR_MIN_TO_DEFAULT=${COLOR_MIN_TO_DEFAULT:-#00FF00} \
        COLOR_FULL=${COLOR_FULL:-#FFFF00} \
        COLOR_FULL_TO_MAX=${COLOR_FULL_TO_MAX:-#FF0000} \
        COLOR_OTHER=${COLOR_OTHER:-#FFFFFF} \
        COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-#222222} \
        COLOR_TEXT=${COLOR_TEXT:-#FFFF00}

    # shellcheck disable=SC2034  # Used externally by modules
    declare -g COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_MAGENTA COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################
    # shellcheck disable=SC2034  # Used externally by modules
    declare -g NOTIFICATION_METHOD=""

    # shellcheck disable=SC2034  # Used externally by modules
    declare -g \
        COMMAND="" \
        DISPLAY_NOTIFICATIONS=false \
        SHOW_VOLUME_PROGRESS=false \
        USE_DUNSTIFY=false \
        USE_FULLCOLOR_ICONS=false \
        PROGRESS_PLACEMENT=summary \
        SIGNAL="" \
        NODE_NAME="" \
        NODE_ID="" \
        SOURCE_NAME="" \
        SOURCE_ID="" \
        STATUSLINE="" \
        SYMBOLIC_ICON_SUFFIX="" \
        PLAY_SOUND=false \
        USE_CANBERRA=false \
        FADE_DURATION="" \
        ALL_SINKS=false \
        VERBOSE=false \
        VOLUME_DISPLAY_UNIT="percent" \
        DRY_RUN=false \
        LOG_FILE="" \
        DEBUG_MODE=false \
        LOG_TO_SYSLOG=false

    # shellcheck disable=SC2034  # Used externally by modules
    declare -gi EXPIRES=1500

    init_color

    load_config

    # Handle --exit-code option before parsing (to avoid triggering usage())
    for arg in "$@"; do
        if [[ "$arg" == "--exit-code" ]]; then
            show_exit_codes
            exit "$EX_OK"
        fi
    done

    parse_opts "$@"

    # Remove --exit-code from CMDARGS if it somehow ended up there
    local temp=()
    for arg in "${CMDARGS[@]}"; do
        [[ "$arg" != "--exit-code" ]] && temp+=("$arg")
    done
    CMDARGS=("${temp[@]}")

    # Initialize logging if enabled
    if not_empty "$LOG_FILE"; then
        init_logging
        log_info "i3-volume started" "PID: $$" "Arguments: $*"
        if [[ "$DEBUG_MODE" == "true" ]]; then
            log_debug "Debug mode enabled"
        fi
    fi

    # Requires options to be parsed first
    init_audio
    init_source

    # Handle i3blocks mouse wheel events automatically
    # When i3blocks calls with BLOCK_BUTTON set and output i3blocks command,
    # handle wheel events before executing the output command
    if not_empty "${BLOCK_BUTTON:-}" && [[ "${CMDARGS[0]:-}" == "output" ]] && [[ "${CMDARGS[1]:-}" == "i3blocks" ]]; then
        local step
        step=$(get_effective_default_step)

        case "$BLOCK_BUTTON" in
            4)  # Scroll up
                exec_command "wheel $step"
                post_command_hook
                # Continue to output after handling wheel event
                ;;
            5)  # Scroll down
                exec_command "wheel -$step"
                post_command_hook
                # Continue to output after handling wheel event
                ;;
        esac
    fi

    exec_command "${CMDARGS[*]}" && post_command_hook

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
