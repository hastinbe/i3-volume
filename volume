#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications.
#
#  Dependencies: awk bc jq WirePlumber
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume
#  Wiki: https://github.com/hastinbe/i3-volume/wiki/

define_helpers() {
    empty() { [[ -z $1 ]]; }
    not_empty() { [[ -n $1 ]]; }
    isset() { [[ -v $1 ]]; }
    command_exists() { command -v "$1" &>/dev/null; }
    error() { echo "$COLOR_RED$*$COLOR_RESET"; }
    error_with_suggestion() {
        local msg="$1"
        shift
        error "$msg"
        while [[ $# -gt 0 ]]; do
            echo "  ${COLOR_YELLOW}â†’${COLOR_RESET} $1" >&2
            shift
        done
    }
    has_color() { [ "$(tput colors)" -ge 8 ] &>/dev/null && [ -t 1 ]; }
    ms_to_secs() { echo "scale=0; (${1} + 999) / 1000" | bc; }
    is_command_hookable() { ! [[ ${POST_HOOK_EXEMPT_COMMANDS[*]} =~ $1 ]]; }
    has_capability() { [[ "${NOTIFY_CAPS[*]}" =~ $1 ]]; }
    max() { echo $(( $1 > $2 ? $1 : $2 )); }

    # Generalized plugin system for multiple plugin types
    declare -gA LOADED_PLUGINS=()

    get_plugin_dir() {
        local plugin_type=$1
        local base_dir="${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/plugins"
        echo "$base_dir/$plugin_type"
    }

    load_plugin() {
        local plugin_type=$1
        local plugin_name=$2
        local plugin_key="${plugin_type}:${plugin_name}"

        # Check if plugin is already loaded
        [[ -v LOADED_PLUGINS["$plugin_key"] ]] && return 0

        local plugin_dir plugin_file
        plugin_dir=$(get_plugin_dir "$plugin_type")
        plugin_file="$plugin_dir/$plugin_name"

        # Check if plugin file exists
        if [[ ! -f "$plugin_file" ]]; then
            return 1
        fi

        # Check if plugin file is executable
        if [[ ! -x "$plugin_file" ]]; then
            error "Plugin $plugin_name is not executable: $plugin_file"
            return 1
        fi

        # Source the plugin file
        # shellcheck source=/dev/null
        if source "$plugin_file" 2>/dev/null; then
            LOADED_PLUGINS["$plugin_key"]=1
            return 0
        else
            error "Failed to load plugin: $plugin_name"
            return 1
        fi
    }

    is_plugin_available() {
        local plugin_type=$1
        local plugin_name=$2
        local plugin_dir plugin_file
        plugin_dir=$(get_plugin_dir "$plugin_type")
        plugin_file="$plugin_dir/$plugin_name"

        [[ -f "$plugin_file" && -x "$plugin_file" ]]
    }

    call_plugin() {
        local plugin_type=$1
        local plugin_name=$2
        shift 2
        local func_name="${plugin_type}_${plugin_name}"

        # Try to load plugin if not already loaded
        if ! load_plugin "$plugin_type" "$plugin_name"; then
            return 1
        fi

        # Check if the function exists
        if ! declare -f "$func_name" >/dev/null 2>&1; then
            error "Plugin $plugin_name does not define function: $func_name"
            return 1
        fi

        # Call the plugin function with all remaining arguments
        "$func_name" "$@"
    }

    list_plugins() {
        local plugin_type=$1
        local plugin_dir
        plugin_dir=$(get_plugin_dir "$plugin_type")

        if [[ ! -d "$plugin_dir" ]]; then
            return 0
        fi

        local plugin_file
        while IFS= read -r -d '' plugin_file; do
            local plugin_name
            plugin_name=$(basename "$plugin_file")
            if [[ -x "$plugin_file" ]]; then
                echo "$plugin_name"
            fi
        done < <(find "$plugin_dir" -maxdepth 1 -type f -executable -print0 2>/dev/null)
    }

    # Check if PipeWire is running
    check_pipewire_running() {
        if ! command_exists pw-dump; then
            return 1
        fi
        if ! pw-dump &>/dev/null; then
            return 1
        fi
        return 0
    }

    # Check if wpctl is available and working
    check_wpctl_available() {
        if ! command_exists wpctl; then
            return 1
        fi
        return 0
    }

    # Get diagnostic information for verbose mode
    get_pipewire_diagnostics() {
        local diag=""
        if ! check_pipewire_running; then
            diag="PipeWire service may not be running. Try: systemctl --user status pipewire pipewire-pulse"
        elif ! check_wpctl_available; then
            diag="wpctl command not found. Install WirePlumber package."
        else
            # Try to get default sink info
            if ! wpctl inspect @DEFAULT_AUDIO_SINK@ &>/dev/null; then
                diag="Cannot access default audio sink. PipeWire may not be fully initialized."
            fi
        fi
        echo "$diag"
    }
}

define_notify() {
    # Notification-specific plugin wrappers (use generalized plugin system from define_helpers)
    call_notification_plugin() {
        local plugin_name=$1
        shift
        # Notification plugins use function name: notify_volume_<name>
        local func_name="notify_volume_$plugin_name"

        # Load plugin using generalized system (plugins stored in plugins/notify/ directory)
        if ! load_plugin "notify" "$plugin_name"; then
            return 1
        fi

        # Check if the function exists
        if ! declare -f "$func_name" >/dev/null 2>&1; then
            error "Notification plugin $plugin_name does not define function: $func_name"
            return 1
        fi

        # Call the plugin function
        "$func_name" "$@"
    }

    is_notification_plugin_available() {
        is_plugin_available "notify" "$1"
    }

    list_notification_plugins() {
        list_plugins "notify"
    }

    # Check if multiple sinks are available
    has_multiple_sinks() {
        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | .id' 2>/dev/null)
        [[ ${#sinks[@]} -gt 1 ]]
    }

    notify_volume() {
        local -r vol=$(get_volume)
        local icon summary body=""
        local boost_info=""

        # Check if boost is active
        if is_boost_active 2>/dev/null; then
            boost_info=" (+${BOOST_AMOUNT}% boost)"
        fi

        # Build summary with sink name if multiple sinks available
        local sink_info=""
        if has_multiple_sinks; then
            local sink_display_name
            sink_display_name=$(get_node_display_name)
            sink_info=" ($sink_display_name)"
        fi

        # Get current port information
        local port_info=""
        local port_desc current_port_id
        current_port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)
        if empty "$current_port_id"; then
            current_port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
        fi

        port_desc=$(get_active_port_description 2>/dev/null || echo "")
        if not_empty "$port_desc"; then
            port_info=" - $port_desc"
        fi

        # Check if port changed
        local last_port_id port_changed=false
        last_port_id=$(get_last_port 2>/dev/null || echo "")
        if not_empty "$current_port_id" && not_empty "$last_port_id" && [[ "$current_port_id" != "$last_port_id" ]]; then
            port_changed=true
            # Enhance port info to indicate change
            if not_empty "$port_desc"; then
                port_info=" - $port_desc ${COLOR_YELLOW}[changed]${COLOR_RESET}"
            fi
        fi

        # Save current port for next comparison
        if not_empty "$current_port_id"; then
            save_last_port "$current_port_id" 2>/dev/null || true
        fi

        if is_muted; then
            summary="Volume muted${sink_info}${port_info}"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Volume %3s%%%s%s%s" "$vol" "$boost_info" "$sink_info" "$port_info"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            libnotify|dunst|notify-osd|*)
                # Check if it's a plugin
                if is_notification_plugin_available "$NOTIFICATION_METHOD"; then
                    call_notification_plugin "$NOTIFICATION_METHOD" "$vol" "$icon" "$summary" "$body" || notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                else
                    notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                fi
                ;;
        esac

        # Check for newly available ports and suggest switching (only if port didn't just change)
        if [[ "$port_changed" == "false" ]]; then
            detect_and_suggest_port_switch || true
        fi
    }

    notify_mic() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            return 1
        fi

        local -r vol=$(get_mic_volume)
        local icon summary body=""

        if is_mic_muted; then
            summary="Microphone muted"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "Microphone %3s%%" "$vol"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            libnotify|dunst|notify-osd|*)
                # Check if it's a plugin
                if is_notification_plugin_available "$NOTIFICATION_METHOD"; then
                    call_notification_plugin "$NOTIFICATION_METHOD" "$vol" "$icon" "$summary" "$body" || notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                else
                    notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                fi
                ;;
        esac
    }

    list_notification_methods() {
        local source="${BASH_SOURCE[0]}"
        # List built-in methods
        awk -v source="$source" 'match($0, / +notify_volume_([[:alnum:]]+)\(\)/) { print substr($0, RSTART + 18, RLENGTH - 20) }' "$source" || EXITCODE=$EX_USAGE
        # List notification plugins
        list_notification_plugins
    }

    setup_notification_icons() { not_empty "$SYMBOLIC_ICON_SUFFIX" && apply_symbolic_icon_suffix; }

    show_volume_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_volume
    }

    load_notify_server_info() {
        command_exists dbus-send || return
        IFS=$'\t' read -r NOTIFY_SERVER _ _ _ < <(dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.GetServerInformation | awk 'BEGIN { ORS="\t" }; match($0, /^   string ".*"/) {print substr($0, RSTART+11, RLENGTH-12)}')
    }

    load_notify_server_caps() {
        command_exists dbus-send || return
        IFS= read -r -d '' -a NOTIFY_CAPS < <(dbus-send --print-reply=literal --dest="${DBUS_NAME}" "${DBUS_PATH}" "${DBUS_IFAC_FDN}.GetCapabilities" | awk 'RS="      " { if (NR > 2) print $1 }')
    }

    notify_volume_libnotify() {
        local vol=$1 icon=$2 summary=$3 body=${*:4}
        local args=('-t' "$EXPIRES")
        local hints=(
            'string:synchronous:volume'                     # Replace previous notification in some notification servers
            'string:x-canonical-private-synchronous:volume' # Replace previous notification in NotifyOSD
        )
        local executable

        # Add progress hint if we're not drawing our own (if supported)
        $SHOW_VOLUME_PROGRESS || hints+=( "int:value:$vol" )

        # Load notification server capabilities if not already loaded
        [[ ${#NOTIFY_CAPS[@]} -lt 1 ]] && load_notify_server_caps

        # Add icon hints if supported
        if has_capability icon-static || has_capability icon-multi; then
            args+=( '-i' "$icon" )
            hints+=( "string:image-path:$icon" ) # For linux_notification_center, supports string:image-path instead of -i|--icon
        fi

        # Add sound hint if sound is enabled and supported
        $PLAY_SOUND && has_capability sound && hints+=( "string:sound-name:audio-volume-change" )

        # Dunst-specific options
        if [[ $NOTIFICATION_METHOD == "dunst" ]]; then
            # Use grouping tag if notification grouping is enabled
            local group_tag="volume"
            if isset NOTIFICATION_GROUP && [[ "$NOTIFICATION_GROUP" == "true" ]]; then
                group_tag="volume-group"
            fi
            hints+=( "string:x-dunst-stack-tag:$group_tag" )
            if ! isset NO_NOTIFY_COLOR; then
                local color
                if is_muted; then color=$COLOR_MUTED; else color=$(volume_color "$vol"); fi
                hints+=( "string:fgcolor:$color" )
            fi
        fi

        # Determine executable and additional arguments
        if $USE_DUNSTIFY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}dunstify"
            args+=( '-r' 1000 )

            # Transient notifications will bypass the idle_threshold setting.
            # Should be boolean, but Notify-OSD doesn't support boolean yet. Dunst checks
            # for int and bool with transient so use what works with both servers.
            hints+=( "int:transient:1" )
        elif isset USE_NOTIFY_SEND_PY; then
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send.py"
            args+=( --replaces-process volume ) # Replaces previous notification, but leaves itself running in the bg to work
            hints+=( "boolean:transient:true" ) # By-pass the server's persistence capability, if it should exist
            hints=( "${hints[@]/#/--hint }" ) # Prefix all hints with --hint to work with notify-send.py
        else
            executable="${NOTIFY_PATH:+${NOTIFY_PATH%/}/}notify-send"
        fi

        command_exists "$executable" || { error "$executable not found. Please install it or set NOTIFY_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        read -ra hints <<< "${hints[@]/#/-h }"
        "$executable" "${hints[@]}" "${args[@]}" "$summary" "$body" &
    }

    notify_volume_xosd() {
        local vol=$1 text=${*:2}
        local executable="${XOSD_PATH:+${XOSD_PATH%/}/}osd_cat"
        local percentage
        local color

        if is_muted; then percentage=0; color=$COLOR_MUTED
        else percentage=$vol; color=$(volume_color "$vol"); fi

        command_exists "$executable" || { error "$executable not found. Please install it or set XOSD_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        "$executable" --align center -b percentage -P "$percentage" -d "$(ms_to_secs "$EXPIRES")" -p top -A center -c "$color" -T "$text" -O 2 -u "$COLOR_XOSD_OUTLINE" & disown
    }

    # Note: a patch with a notify-send script for herbe, not in the current version at this
    #       time but would make this irrelevant. See https://github.com/dudik/herbe/pull/10
    notify_volume_herbe() {
        local -r text=$*
        local executable="${HERBE_PATH:+${HERBE_PATH%/}/}herbe"

        command_exists "$executable" || { error "$executable not found. Please install it or set HERBE_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        pkill -SIGUSR1 herbe # Dismiss existing/pending notifications to prevent queuing
        "$executable" "$text" & disown
    }

    notify_volume_volnoti() {
        local -r vol=$1
        local executable="${VOLNOTI_PATH:+${VOLNOTI_PATH%/}/}volnoti-show"

        command_exists "$executable" || { error "$executable not found. Please install it or set VOLNOTI_PATH to the correct path."; exit "$EX_UNAVAILABLE"; }

        if is_muted; then "$executable" -m "$vol"
        else "$executable" "$vol"; fi
    }

    notify_volume_kosd() {
        local -r vol=$1
        local muted
        if is_muted; then muted=1; else muted=0; fi
        qdbus org.kde.kded /modules/kosd showVolume "$vol" "$muted"
    }
}

define_output_formats() {
    output_volume_default() { if is_muted; then echo MUTE; else echo "$(get_volume)%"; fi }

    # Format options:
    #   %v = volume percentage or "MUTE" when muted
    #   %n = node display name/alias
    #   %d = node id
    #   %p = volume progress bar
    #   %i = volume icon
    output_volume_custom() {
        local -r vol=$(get_volume)
        local format="$1"
        local string

        # Process conditional formatting first (e.g., %v{>50:high:low})
        # This must be done before replacing %v with the actual volume
        while [[ $format =~ %([a-z])\{([^}]+)\} ]]; do
            local placeholder="${BASH_REMATCH[1]}"
            local condition="${BASH_REMATCH[2]}"
            local replacement=""

            # Parse condition: operator:value:true_text:false_text
            # Examples: >50:high:low, <30:quiet:normal, ==100:max:normal
            if [[ $condition =~ ^([<>=!]+)([0-9.]+):(.+):(.+)$ ]]; then
                local op="${BASH_REMATCH[1]}"
                local threshold="${BASH_REMATCH[2]}"
                local true_text="${BASH_REMATCH[3]}"
                local false_text="${BASH_REMATCH[4]}"

                # Get the value to compare based on placeholder
                local compare_val
                case "$placeholder" in
                    v) compare_val=$vol ;;
                    m) compare_val=$(get_mic_volume 2>/dev/null || echo "0") ;;
                    b) compare_val=$(get_balance 2>/dev/null || echo "0") ;;
                    *) compare_val=0 ;;
                esac

                # Evaluate condition using bash arithmetic
                local condition_result=false
                # Convert to integers for comparison (bash arithmetic works with integers)
                local compare_int threshold_int
                compare_int=$(printf "%.0f" "$compare_val" 2>/dev/null || echo "0")
                threshold_int=$(printf "%.0f" "$threshold" 2>/dev/null || echo "0")

                case "$op" in
                    ">")  (( compare_int > threshold_int )) && condition_result=true ;;
                    "<")  (( compare_int < threshold_int )) && condition_result=true ;;
                    ">=") (( compare_int >= threshold_int )) && condition_result=true ;;
                    "<=") (( compare_int <= threshold_int )) && condition_result=true ;;
                    "==") (( compare_int == threshold_int )) && condition_result=true ;;
                    "!=") (( compare_int != threshold_int )) && condition_result=true ;;
                esac

                if [[ "$condition_result" == "true" ]]; then
                    replacement="$true_text"
                else
                    replacement="$false_text"
                fi
            else
                # Invalid condition format, remove the conditional
                replacement=""
            fi

            # Replace the conditional placeholder with the result
            local conditional_pattern="%${placeholder}{${condition}}"
            format=${format//$conditional_pattern/$replacement}
        done

        # Now process regular placeholders
        string=${format//\%v/$vol%}
        string=${string//\%n/$(get_node_display_name)}
        string=${string//\%d/$NODE_ID}
        string=${string//\%p/$(progress_bar "$vol")}
        string=${string//\%i/$(get_volume_emoji "$vol")}

        # Replace %s with sink name
        if [[ $string == *%s* ]]; then
            local sink_name="${NODE_NAME:-}"
            string=${string//%s/$sink_name}
        fi

        # Replace %m with microphone volume
        if [[ $string == *%m* ]]; then
            local mic_vol
            if is_mic_muted 2>/dev/null; then
                mic_vol="MUTED"
            else
                mic_vol=$(get_mic_volume 2>/dev/null || echo "N/A")
                mic_vol="${mic_vol}%"
            fi
            string=${string//%m/$mic_vol}
        fi

        # Replace %b with balance
        if [[ $string == *%b* ]]; then
            local balance
            balance=$(get_balance 2>/dev/null || echo "0")
            # Format balance: negative = left, positive = right, 0 = center
            if (( balance < 0 )); then
                balance="L${balance#-}"
            elif (( balance > 0 )); then
                balance="R${balance}"
            else
                balance="C"
            fi
            string=${string//%b/$balance}
        fi

        # Replace %c with color codes
        if [[ $string == *%c* ]]; then
            local color_code
            color_code=$(get_volume_color_code "$vol")
            string=${string//%c/$color_code}
        fi

        # Replace %P with active port description (with availability if available)
        if [[ $string == *%P* ]]; then
            local port_desc port_id port_availability port_info
            port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)
            if empty "$port_id"; then
                port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
            fi

            port_desc=$(get_active_port_description 2>/dev/null || echo "")
            if not_empty "$port_id" && not_empty "$port_desc"; then
                # Check availability
                port_availability=$(get_port_availability "$port_id" 2>/dev/null || echo "unknown")
                case "$port_availability" in
                    available)
                        port_info="$port_desc [plugged]"
                        ;;
                    unavailable)
                        port_info="$port_desc [unplugged]"
                        ;;
                    *)
                        port_info="$port_desc"
                        ;;
                esac
            else
                port_info="$port_desc"
            fi
            string=${string//%P/$port_info}
        fi

        # Replace %a with active application name
        if [[ $string == *%a* ]]; then
            local app_name
            app_name=$(get_active_app_name 2>/dev/null || echo "")
            string=${string//%a/$app_name}
        fi

        if is_muted; then echo -ne "${string//\%v/MUTED}"
        else echo -ne "$string"; fi
    }

    output_volume_i3blocks() {
        local -r name=$(get_node_display_name)
        local short_text

        if is_muted; then
            short_text="<span color=\"$COLOR_MUTED\">MUTED</span>\n"
        else
            local -r vol=$(get_volume)
            short_text="<span color=\"$(volume_color "$vol")\">${vol}%</span>\n"
            local effective_max_vol
            effective_max_vol=$(get_effective_max_vol)
            if not_empty "$effective_max_vol" && (( vol > effective_max_vol )); then
                EXITCODE=$EX_URGENT
            fi
        fi

        local full_text=${short_text}
        not_empty "$name" && full_text="<span color=\"$COLOR_TEXT\">$name</span> $short_text"

        echo -ne "$full_text$short_text"
    }

    output_volume_xob() { echo "$(get_volume)$(is_muted && echo "!")"; }

    output_volume_json() {
        local vol muted display_name port_desc app_name mic_vol mic_muted
        local json_output

        # Get volume and muted status
        vol=$(get_volume)
        if is_muted; then
            muted="true"
        else
            muted="false"
        fi

        # Get display name
        display_name=$(get_node_display_name)

        # Get port description (may be empty)
        port_desc=$(get_active_port_description 2>/dev/null || echo "")

        # Get active app name (may be empty)
        app_name=$(get_active_app_name 2>/dev/null || echo "")

        # Get microphone information (may not be available)
        if is_mic_muted 2>/dev/null; then
            mic_muted="true"
            mic_vol=""
        else
            mic_muted="false"
            mic_vol=$(get_mic_volume 2>/dev/null || echo "")
        fi

        # Build JSON using jq for proper escaping and formatting
        json_output=$(jq -n \
            --arg volume "$vol" \
            --arg sink_name "${NODE_NAME:-}" \
            --arg node_id "${NODE_ID:-}" \
            --arg display_name "$display_name" \
            --arg port "${port_desc:-}" \
            --arg active_app "${app_name:-}" \
            --arg mic_volume "${mic_vol:-}" \
            --arg muted_str "$muted" \
            --arg mic_muted_str "$mic_muted" \
            '{
                volume: ($volume | tonumber),
                muted: ($muted_str == "true"),
                sink_name: (if $sink_name == "" then null else $sink_name end),
                node_id: (if $node_id == "" then null else ($node_id | tonumber) end),
                display_name: (if $display_name == "" then null else $display_name end),
                port: (if $port == "" then null else $port end),
                active_app: (if $active_app == "" then null else $active_app end),
                microphone: {
                    volume: (if $mic_volume == "" then null else ($mic_volume | tonumber) end),
                    muted: ($mic_muted_str == "true")
                }
            }' 2>/dev/null)

        # Fallback to manual JSON construction if jq fails
        if [[ -z "$json_output" ]]; then
            # Escape strings for JSON (simple escaping)
            escape_json() {
                echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g'
            }

            local esc_display_name esc_port esc_app_name esc_sink_name
            esc_display_name=$(escape_json "$display_name")
            esc_port=$(escape_json "$port_desc")
            esc_app_name=$(escape_json "$app_name")
            esc_sink_name=$(escape_json "${NODE_NAME:-}")

            json_output="{"
            json_output="${json_output}\"volume\":${vol},"
            json_output="${json_output}\"muted\":${muted},"
            if [[ -n "$NODE_NAME" ]]; then
                json_output="${json_output}\"sink_name\":\"${esc_sink_name}\","
            else
                json_output="${json_output}\"sink_name\":null,"
            fi
            if [[ -n "$NODE_ID" ]]; then
                json_output="${json_output}\"node_id\":${NODE_ID},"
            else
                json_output="${json_output}\"node_id\":null,"
            fi
            if [[ -n "$display_name" ]]; then
                json_output="${json_output}\"display_name\":\"${esc_display_name}\","
            else
                json_output="${json_output}\"display_name\":null,"
            fi
            if [[ -n "$port_desc" ]]; then
                json_output="${json_output}\"port\":\"${esc_port}\","
            else
                json_output="${json_output}\"port\":null,"
            fi
            if [[ -n "$app_name" ]]; then
                json_output="${json_output}\"active_app\":\"${esc_app_name}\","
            else
                json_output="${json_output}\"active_app\":null,"
            fi
            json_output="${json_output}\"microphone\":{"
            if [[ -n "$mic_vol" ]]; then
                json_output="${json_output}\"volume\":${mic_vol},"
            else
                json_output="${json_output}\"volume\":null,"
            fi
            json_output="${json_output}\"muted\":${mic_muted}"
            json_output="${json_output}}}"
        fi

        echo "$json_output"
    }
}

define_commands() {
    fade_volume() {
        local -r target_vol=$1
        local -r duration_ms=$2
        local -r node_id=$3
        local -r start_vol=${4:-}  # Optional starting volume
        local current_vol target_vol_int
        local -i steps=50  # Number of steps for smooth fade
        local -i step_delay

        if not_empty "$start_vol"; then
            current_vol=${start_vol%.*}  # Use provided starting volume
        else
            current_vol=$(get_volume)
        fi
        target_vol_int=${target_vol%.*}  # Convert to integer

        # Calculate step delay in milliseconds
        if (( duration_ms > 0 && steps > 0 )); then
            step_delay=$(( duration_ms / steps ))
        else
            step_delay=10  # Default 10ms per step
        fi

        # Calculate volume difference
        local -i vol_diff=$(( target_vol_int - current_vol ))

        if (( vol_diff == 0 )); then
            return 0  # Already at target
        fi

        # Calculate step size
        local -i step_size
        if (( vol_diff > 0 )); then
            step_size=$(( (vol_diff + steps - 1) / steps ))  # Ceiling division
        else
            step_size=$(( (vol_diff - steps + 1) / steps ))  # Floor division
        fi

        # Perform fade
        local -i i
        for (( i = 0; i < steps; i++ )); do
            local -i new_vol=$(( current_vol + step_size * (i + 1) ))

            # Clamp to target
            if (( vol_diff > 0 && new_vol > target_vol_int )); then
                new_vol=$target_vol_int
            elif (( vol_diff < 0 && new_vol < target_vol_int )); then
                new_vol=$target_vol_int
            fi

            # Clamp to valid range
            if (( new_vol < 0 )); then
                new_vol=0
            else
                local effective_max_vol
                effective_max_vol=$(get_effective_max_vol)
                if not_empty "$effective_max_vol" && (( new_vol > effective_max_vol )); then
                    new_vol=$effective_max_vol
                fi
            fi

            wpctl set-volume "$node_id" "${new_vol}%" &>/dev/null

            # Sleep between steps (convert ms to microseconds for usleep, or use sleep)
            if (( i < steps - 1 )); then
                if command -v usleep &>/dev/null; then
                    # usleep takes microseconds
                    usleep $(( step_delay * 1000 )) 2>/dev/null || sleep 0.01
                else
                    # sleep with decimal seconds (bash 4+ supports this)
                    local sleep_time
                    sleep_time=$(awk "BEGIN {printf \"%.3f\", $step_delay / 1000}" 2>/dev/null)
                    if [[ -n "$sleep_time" ]]; then
                        sleep "$sleep_time" 2>/dev/null || sleep 0.01
                    else
                        sleep 0.01
                    fi
                fi
            fi
        done

        # Ensure we end at exact target
        wpctl set-volume "$node_id" "${target_vol_int}%" &>/dev/null
        invalidate_cache
    }

    set_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        # Check if operating on all sinks
        if $ALL_SINKS; then
            set_volume_all "$vol" "$op"
            return
        fi

        local target_vol current_vol
        local effective_max_vol
        effective_max_vol=$(get_effective_max_vol)

        if not_empty "$effective_max_vol"; then
            case "$op" in
                +)  # Increase volume
                    current_vol=$(get_volume)
                    if (( current_vol + vol > effective_max_vol )); then
                        # Instead of doing nothing, step to max_volume
                        local -r step=$( max "0" "$(( effective_max_vol - current_vol ))" )
                        if not_empty "$FADE_DURATION"; then
                            fade_volume "$effective_max_vol" "$FADE_DURATION" "$NODE_ID"
                        else
                            wpctl set-volume "$NODE_ID" "$step%+"
                        fi
                        return
                    fi
                    ;;
                *)  # Set absolute volume
                    if (( vol > effective_max_vol )); then
                        return
                    fi
                    ;;
            esac
        fi

        # Handle fade if requested
        if not_empty "$FADE_DURATION"; then
            case "$op" in
                +)
                    current_vol=$(get_volume)
                    target_vol=$(( current_vol + vol ))
                    fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
                -)
                    current_vol=$(get_volume)
                    target_vol=$(( current_vol - vol ))
                    fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
                *)
                    fade_volume "$vol" "$FADE_DURATION" "$NODE_ID"
                    ;;
            esac
        else
            invalidate_cache
            case "$op" in
                +) wpctl set-volume "$NODE_ID" "${vol}%+" ;;
                -) wpctl set-volume "$NODE_ID" "${vol}%-" ;;
                *) wpctl set-volume "$NODE_ID" "${vol}%" ;;
            esac
        fi
    }

    increase_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=$(get_effective_default_step)
        fi
        set_volume "$step" "+"
    }
    decrease_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=$(get_effective_default_step)
        fi
        set_volume "$step" "-"
    }

    wheel_volume() {
        local -r delta_change=${1:?$(error 'Wheel delta is required')}
        local step threshold current_delta new_delta volume_change threshold_reached

        # Use DEFAULT_STEP as the base for threshold (per-sink or global)
        step=$(get_effective_default_step)
        # Threshold is based on step size - accumulate until we reach one step
        threshold=$(awk "BEGIN {printf \"%.2f\", $step}")

        # Get current accumulated delta
        current_delta=$(get_wheel_delta)

        # Add the new change to accumulated delta
        new_delta=$(awk "BEGIN {printf \"%.2f\", $current_delta + $delta_change}")

        # Check if we've reached the threshold
        threshold_reached=$(awk "BEGIN {if ($new_delta >= $threshold || $new_delta <= -$threshold) print 1; else print 0}")
        if (( threshold_reached == 1 )); then
            # Calculate how many whole steps to apply
            volume_change=$(awk "BEGIN {printf \"%.0f\", $new_delta}")

            # Apply the volume change
            if (( volume_change > 0 )); then
                increase_volume "$volume_change"
            elif (( volume_change < 0 )); then
                decrease_volume "${volume_change#-}"  # Remove negative sign
            fi

            # Reset accumulated delta (keep remainder)
            new_delta=$(awk "BEGIN {printf \"%.2f\", $new_delta - $volume_change}")
        fi

        # Save the new accumulated delta
        save_wheel_delta "$new_delta"
    }

    toggle_mute() {
        # Check if operating on all sinks
        if $ALL_SINKS; then
            toggle_mute_all
            return
        fi
        if not_empty "$FADE_DURATION"; then
            if is_muted; then
                # Fade in (unmute)
                wpctl set-mute "$NODE_ID" 0
                local current_vol saved_vol
                current_vol=$(get_volume)
                # Try to restore saved volume from before mute
                saved_vol=$(restore_volume_after_mute)
                if not_empty "$saved_vol"; then
                    # Restore to saved volume
                    wpctl set-volume "$NODE_ID" "0%"
                    fade_volume "$saved_vol" "$FADE_DURATION" "$NODE_ID"
                    clear_saved_volume
                elif (( current_vol == 0 )); then
                    # If volume is 0, fade from 0 to a reasonable level
                    fade_volume "${DEFAULT_VOL:-50}" "$FADE_DURATION" "$NODE_ID"
                else
                    # Fade from 0 to current volume
                    wpctl set-volume "$NODE_ID" "0%"
                    fade_volume "$current_vol" "$FADE_DURATION" "$NODE_ID"
                fi
            else
                # Fade out (mute)
                # Ensure device is not muted before starting fade
                wpctl set-mute "$NODE_ID" 0 &>/dev/null
                # Invalidate cache to ensure we get the current volume
                invalidate_cache
                local current_vol
                current_vol=$(get_volume)
                # Save the current volume before muting so we can restore it later
                save_volume_before_mute "$current_vol"
                # Fade down to 0 from current volume
                # Pass current_vol as starting volume to ensure we fade from the correct value
                fade_volume 0 "$FADE_DURATION" "$NODE_ID" "$current_vol"
                # Now that fade is complete, mute the device
                # Set volume to 0 one more time to ensure it's at 0, then mute
                wpctl set-volume "$NODE_ID" "0%" &>/dev/null
                wpctl set-mute "$NODE_ID" 1
                # Some systems restore volume when muting, so set it to 0 again after mute
                wpctl set-volume "$NODE_ID" "0%" &>/dev/null
                invalidate_cache
            fi
        else
            invalidate_cache
            wpctl set-mute "$NODE_ID" toggle
        fi
    }

    set_mic_volume() {
        local -r vol=${1:?$(error 'Volume is required')}
        local -r op=${2:-}

        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error_with_suggestion "No audio source available." \
                "Check if a microphone or audio input device is connected." \
                "Use 'volume list sources' to see available sources."
            return 1
        fi

        invalidate_cache

        case "$op" in
            +) wpctl set-volume "$SOURCE_ID" "${vol}%+" ;;
            -) wpctl set-volume "$SOURCE_ID" "${vol}%-" ;;
            *) wpctl set-volume "$SOURCE_ID" "${vol}%" ;;
        esac
    }

    increase_mic_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_mic_volume "$step" "+"
    }
    decrease_mic_volume() {
        local step=${1:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_mic_volume "$step" "-"
    }
    toggle_mic_mute() {
        if empty "$SOURCE_ID"; then
            init_source
        fi

        if empty "$SOURCE_ID"; then
            error_with_suggestion "No audio source available." \
                "Check if a microphone or audio input device is connected." \
                "Use 'volume list sources' to see available sources."
            return 1
        fi

        invalidate_cache
        wpctl set-mute "$SOURCE_ID" toggle
    }

    show_mic_notification() {
        $DISPLAY_NOTIFICATIONS || return

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_mic
    }

    # Output format plugin wrappers (use generalized plugin system from define_helpers)
    call_output_plugin() {
        local plugin_name=$1
        shift
        # Output plugins use function name: output_volume_<name>
        local func_name="output_volume_$plugin_name"

        # Load plugin using generalized system (plugins stored in plugins/output/ directory)
        if ! load_plugin "output" "$plugin_name"; then
            return 1
        fi

        # Check if the function exists
        if ! declare -f "$func_name" >/dev/null 2>&1; then
            error "Output plugin $plugin_name does not define function: $func_name"
            return 1
        fi

        # Call the plugin function
        "$func_name" "$@"
    }

    is_output_plugin_available() {
        is_plugin_available "output" "$1"
    }

    list_output_plugins() {
        list_plugins "output"
    }

    output_volume() {
        local -r for=${1:?$(error 'Output method is required')}

        case "$for" in
            i3blocks ) output_volume_i3blocks ;;
            xob      ) output_volume_xob ;;
            json     ) output_volume_json ;;
            default  ) output_volume_default ;;
            *        )
                # Check if it's a plugin first
                if is_output_plugin_available "$for"; then
                    call_output_plugin "$for" || output_volume_custom "$*"
                else
                    output_volume_custom "$*"
                fi
                ;;
        esac
    }

    list_output_formats() {
        # List built-in formats
        awk 'match($0,/ +output_volume_([[:alnum:]]+)\(\)/) {print substr($0, RSTART + 18, RLENGTH - 20)}' "${BASH_SOURCE[0]}" || EXITCODE=$EX_USAGE
        # List output plugins
        list_output_plugins
    }

    list_sinks() {
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sinks[@]} -eq 0 ]]; then
            error "No audio sinks found."
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sinks:${COLOR_RESET}"
        echo

        local sink_id sink_name sink_nick vol muted is_default
        for sink in "${sinks[@]}"; do
            IFS='|' read -r sink_id sink_name sink_nick <<< "$sink"

            # Get volume and mute status
            vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default sink
            if [[ "$sink_name" == "$default_sink_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$sink_nick"
            if isset NODE_ALIASES["$sink_id"]; then
                display_name="${NODE_ALIASES[$sink_id]}"
            elif isset NODE_ALIASES["$sink_name"]; then
                display_name="${NODE_ALIASES[$sink_name]}"
            elif isset NODE_ALIASES["$sink_nick"]; then
                display_name="${NODE_ALIASES[$sink_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$sink_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($sink_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default sink"
    }

    list_sources() {
        local default_source_name
        default_source_name=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')

        local sources
        readarray -t sources < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Source") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null)

        if [[ ${#sources[@]} -eq 0 ]]; then
            error_with_suggestion "No audio sources found." \
                "Check if a microphone or audio input device is connected." \
                "Ensure PipeWire is running: systemctl --user status pipewire pipewire-pulse"
            return 1
        fi

        echo "${COLOR_YELLOW}Audio Sources:${COLOR_RESET}"
        echo

        local source_id source_name source_nick vol muted is_default
        for source in "${sources[@]}"; do
            IFS='|' read -r source_id source_name source_nick <<< "$source"

            # Get volume and mute status
            vol=$(wpctl get-volume "$source_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
            muted=$(wpctl get-volume "$source_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            # Check if this is the default source
            if [[ "$source_name" == "$default_source_name" ]]; then
                is_default="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_default="  "
            fi

            # Apply alias if available
            local display_name="$source_nick"
            if isset NODE_ALIASES["$source_id"]; then
                display_name="${NODE_ALIASES[$source_id]}"
            elif isset NODE_ALIASES["$source_name"]; then
                display_name="${NODE_ALIASES[$source_name]}"
            elif isset NODE_ALIASES["$source_nick"]; then
                display_name="${NODE_ALIASES[$source_nick]}"
            fi

            printf "%s${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$is_default" "$source_id" "$display_name"
            if [[ -n "$muted" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($source_name)${COLOR_RESET}"
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = default source"
    }

    list_ports() {
        if empty "$NODE_ID"; then
            error_with_suggestion "No sink specified. Use -s <sink> or ensure default sink is available." \
                "Use 'volume list sinks' to see available sinks." \
                "Specify a sink with: volume -s <sink_name> port list"
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        local sink_display_name
        sink_display_name=$(get_node_display_name)

        echo "${COLOR_YELLOW}Ports for sink: ${COLOR_GREEN}$sink_display_name${COLOR_RESET} (ID: ${COLOR_CYAN}$NODE_ID${COLOR_RESET})"
        echo

        # Try to get ports from PropInfo first with availability
        local ports
        readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | "\(.id)|\(.name)|\(.description // "N/A")|\(.availability // "unknown")"' 2>/dev/null)

        # If no ports found via PropInfo, try alternative method using node properties
        if [[ ${#ports[@]} -eq 0 ]]; then
            readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props | to_entries[] | select(.key | test("port\\..*")) | "\(.key)|\(.value)|N/A|unknown"' 2>/dev/null)
        fi

        if [[ ${#ports[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No ports found for this sink.${COLOR_RESET}"
            echo "This sink may not support port switching, or port information is not available."
            echo "Try using ${COLOR_GREEN}wpctl status${COLOR_RESET} for more information."
            return 0
        fi

        # Get active port
        local active_port
        active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        # If no active port from PropInfo, try node properties
        if empty "$active_port"; then
            active_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
        fi

        local port_id port_name port_desc port_availability is_active availability_status
        for port in "${ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc port_availability <<< "$port"

            # Handle different port formats
            if [[ -z "$port_desc" || "$port_desc" == "N/A" ]]; then
                port_desc="$port_name"
            fi

            # Determine if port is active
            if [[ "$port_id" == "$active_port" || "$port_name" == "$active_port" ]]; then
                is_active="${COLOR_GREEN}*${COLOR_RESET} "
            else
                is_active="  "
            fi

            # Format availability status
            case "$port_availability" in
                available|yes|1|true)
                    availability_status="${COLOR_GREEN}[plugged]${COLOR_RESET}"
                    ;;
                unavailable|no|0|false)
                    availability_status="${COLOR_RED}[unplugged]${COLOR_RESET}"
                    ;;
                *)
                    # If availability is unknown, try to check it
                    local checked_availability
                    checked_availability=$(get_port_availability "$port_id" 2>/dev/null || echo "unknown")
                    case "$checked_availability" in
                        available)
                            availability_status="${COLOR_GREEN}[plugged]${COLOR_RESET}"
                            ;;
                        unavailable)
                            availability_status="${COLOR_RED}[unplugged]${COLOR_RESET}"
                            ;;
                        *)
                            availability_status="${COLOR_YELLOW}[unknown]${COLOR_RESET}"
                            ;;
                    esac
                    ;;
            esac

            printf "%s${COLOR_CYAN}%s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}  %s" "$is_active" "$port_id" "$port_desc" "$availability_status"
            if [[ -n "$port_name" && "$port_name" != "$port_desc" ]]; then
                echo "  ${COLOR_MAGENTA}($port_name)${COLOR_RESET}"
            else
                echo
            fi
        done
        echo
        echo "${COLOR_GREEN}*${COLOR_RESET} = active port"
    }

    list() {
        local -r type=${1:-}

        case "$type" in
            sinks|sink)
                list_sinks
                ;;
            sources|source)
                list_sources
                ;;
            ports|port)
                list_ports
                ;;
            "")
                error "List type required. Use: list sinks|sources|ports"
                echo "  ${COLOR_GREEN}list sinks${COLOR_RESET}    - list all audio output sinks"
                echo "  ${COLOR_GREEN}list sources${COLOR_RESET} - list all audio input sources"
                echo "  ${COLOR_GREEN}list ports${COLOR_RESET}    - list ports for current sink"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                error "Unknown list type: $type"
                echo "Valid types: sinks, sources, ports"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_active_port_description() {
        if empty "$NODE_ID"; then
            return 1
        fi

        # Get active port ID - try multiple methods
        local active_port_id
        active_port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        # Fallback: try node properties
        if empty "$active_port_id"; then
            active_port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.props."audio.port" // empty' 2>/dev/null)
        fi

        if empty "$active_port_id"; then
            return 1
        fi

        # Get port description - try multiple methods
        local port_desc
        port_desc=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$active_port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .description // .name' 2>/dev/null)

        # Fallback: try to get from port name if description not available
        if empty "$port_desc"; then
            port_desc=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$active_port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .name' 2>/dev/null)
        fi

        # If still empty, use port_id as fallback
        if empty "$port_desc"; then
            port_desc="$active_port_id"
        fi

        echo "$port_desc"
    }

    get_port_availability() {
        local -r port_id=$1
        if empty "$NODE_ID" || empty "$port_id"; then
            return 1
        fi

        # Check port availability from PropInfo
        local availability
        availability=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .availability // "unknown"' 2>/dev/null)

        # If availability is not in PropInfo, try to infer from port properties
        if [[ "$availability" == "unknown" || -z "$availability" ]]; then
            # Check if port exists in available ports list (if it's listed, it's likely available)
            local port_exists
            port_exists=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .id' 2>/dev/null)
            if [[ -n "$port_exists" ]]; then
                availability="available"
            else
                availability="unavailable"
            fi
        fi

        echo "$availability"
    }

    get_all_ports() {
        if empty "$NODE_ID"; then
            return 1
        fi

        # Get all ports for the current sink with availability information
        # Format: port_id|port_name|port_description|availability
        local ports
        readarray -t ports < <(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | "\(.id)|\(.name)|\(.description // "N/A")|\(.availability // "unknown")"' 2>/dev/null)

        if [[ ${#ports[@]} -eq 0 ]]; then
            return 1
        fi

        echo "${ports[@]}"
    }

    check_for_newly_available_ports() {
        if empty "$NODE_ID"; then
            return 1
        fi

        # Get current active port
        local current_port
        current_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        # Get all available ports
        local -a all_ports
        readarray -t all_ports < <(get_all_ports)

        if [[ ${#all_ports[@]} -eq 0 ]]; then
            return 1
        fi

        # Find newly available ports (available but not currently active)
        local port_id port_name port_desc port_availability
        local -a newly_available_ports
        for port in "${all_ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc port_availability <<< "$port"

            # Check if port is available and not the current one
            if [[ "$port_id" != "$current_port" ]]; then
                # Check availability
                local availability
                availability=$(get_port_availability "$port_id" 2>/dev/null || echo "unknown")
                if [[ "$availability" == "available" ]] || [[ "$port_availability" == "available" ]]; then
                    # Format: port_id|port_description
                    newly_available_ports+=("$port_id|$port_desc")
                fi
            fi
        done

        # If we found newly available ports, suggest switching
        if [[ ${#newly_available_ports[@]} -gt 0 ]]; then
            # Return the first newly available port (most likely the one just plugged in)
            echo "${newly_available_ports[0]}"
            return 0
        fi

        return 1
    }

    detect_and_suggest_port_switch() {
        if empty "$NODE_ID" || ! $DISPLAY_NOTIFICATIONS; then
            return 0
        fi

        # Check for newly available ports
        local new_port_info
        new_port_info=$(check_for_newly_available_ports 2>/dev/null)

        if not_empty "$new_port_info"; then
            IFS='|' read -r new_port_id new_port_desc <<< "$new_port_info"

            # Only suggest if we have a meaningful description
            if not_empty "$new_port_desc" && [[ "$new_port_desc" != "N/A" ]]; then
                local icon summary body
                icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")

                # Include sink name if multiple sinks available
                local sink_info=""
                if has_multiple_sinks; then
                    local sink_display_name
                    sink_display_name=$(get_node_display_name)
                    sink_info=" on $sink_display_name"
                fi

                summary="New port available: $new_port_desc${sink_info}"
                body="Switch with: volume port set $new_port_id"

                case "$NOTIFICATION_METHOD" in
                    xosd    ) notify_volume_xosd 0 "$summary" ;;
                    herbe   ) notify_volume_herbe "$summary" ;;
                    volnoti ) notify_volume_volnoti 0 ;;
                    kosd    ) notify_volume_kosd 0 ;;
                    *       ) notify_volume_libnotify 0 "$icon" "$summary" "$body" ;;
                esac
            fi
        fi
    }

    find_port_by_name_or_id() {
        local -r search=$1
        local port_id port_name port_desc

        if empty "$NODE_ID"; then
            return 1
        fi

        # Get all ports
        local -a all_ports
        readarray -t all_ports < <(get_all_ports)

        if [[ ${#all_ports[@]} -eq 0 ]]; then
            return 1
        fi

        # Search for port
        for port in "${all_ports[@]}"; do
            IFS='|' read -r port_id port_name port_desc <<< "$port"

            # Try as ID
            if [[ "$port_id" == "$search" ]]; then
                echo "$port_id"
                return 0
            fi

            # Try as name
            if [[ "$port_name" == "$search" ]]; then
                echo "$port_id"
                return 0
            fi

            # Try as description (case-insensitive partial match)
            if [[ "${port_desc,,}" == *"${search,,}"* ]]; then
                echo "$port_id"
                return 0
            fi
        done

        return 1
    }

    set_port() {
        local -r port_target=${1:?$(error 'Port name or ID is required')}

        if empty "$NODE_ID"; then
            error "No sink specified. Use -s <sink> or ensure default sink is available."
            return 1
        fi

        # Find the port
        local port_id
        port_id=$(find_port_by_name_or_id "$port_target")

        if empty "$port_id"; then
            error_with_suggestion "Port not found: $port_target" \
                "Use 'volume port list' to see available ports for the current sink." \
                "Port names are case-sensitive."
            return 1
        fi

        # Get current active port
        local current_port
        current_port=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null)

        if [[ "$port_id" == "$current_port" ]]; then
            echo "Port is already active."
            return 0
        fi

        # Set the port using pw-cli set-param
        # Note: This requires the EnumPort param to be available on the node
        # The param format uses PipeWire's POD format for Props
        # To test port switching on a device with ports:
        #   1. Use 'volume port list' to see available ports
        #   2. Use 'volume port set <port_id>' to switch ports
        #   3. Verify with 'wpctl inspect <node_id>' that the port changed
        if ! pw-cli set-param "$NODE_ID" Props '{"EnumPort":"'"$port_id"'"}' &>/dev/null; then
            error_with_suggestion "Failed to set port to $port_id" \
                "The port may not be available for this sink." \
                "Use 'volume port list' to verify the port exists and is available."
            echo "Note: Port switching may not be supported on this device, or the port ID may be incorrect."
            echo "Verify ports are available with: volume port list"
            return 1
        fi

        # Get port description for notification
        local port_desc
        port_desc=$(pw_dump | jq -r --argjson node_id "$NODE_ID" --arg port_id "$port_id" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .values[]? | select(.id == $port_id) | .description // .name' 2>/dev/null)

        # Invalidate cache
        invalidate_cache

        # Show notification if enabled
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary body=""
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")

            # Include sink name if multiple sinks available
            local sink_info=""
            if has_multiple_sinks; then
                local sink_display_name
                sink_display_name=$(get_node_display_name)
                sink_info=" on $sink_display_name"
            fi

            summary="Port switched to: $port_desc${sink_info}"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd 0 "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti 0 ;;
                kosd    ) notify_volume_kosd 0 ;;
                *       ) notify_volume_libnotify 0 "$icon" "$summary" "$body" ;;
            esac
        else
            echo "Port switched to: $port_desc"
        fi

        # Update statusbar if configured
        update_statusbar || true
    }

    port() {
        local -r subcommand=${1:-}
        local -r target=${2:-}

        case "$subcommand" in
            list)
                list_ports
                ;;
            set)
                if empty "$target"; then
                    error "Port name or ID required. Use: port set <port>"
                    echo "Use 'volume port list' to see available ports."
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                set_port "$target"
                ;;
            "")
                error "Port subcommand required. Use: port list|set"
                echo "  ${COLOR_GREEN}port list${COLOR_RESET}        - list available ports"
                echo "  ${COLOR_GREEN}port set <port>${COLOR_RESET}  - set active port"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                error "Unknown port subcommand: $subcommand"
                echo "Valid subcommands: list, set"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_profiles_dir() {
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/profiles"
    }

    get_config_dir() {
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume"
    }

    get_port_cache_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.last_port_${NODE_ID:-default}"
    }

    save_last_port() {
        local -r port_id=$1
        if empty "$port_id"; then
            return 1
        fi

        local port_file
        port_file=$(get_port_cache_file)
        local config_dir
        config_dir=$(get_config_dir)

        # Create config directory if it doesn't exist
        mkdir -p "$config_dir" || {
            return 1
        }

        # Save the port ID to file
        echo "$port_id" > "$port_file" 2>/dev/null || {
            return 1
        }
    }

    get_last_port() {
        local port_file
        port_file=$(get_port_cache_file)

        if [[ ! -f "$port_file" ]]; then
            return 1
        fi

        cat "$port_file" 2>/dev/null
    }

    save_volume_before_mute() {
        local -r vol=$1
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"

        # Create config directory if it doesn't exist
        mkdir -p "$config_dir" || {
            error "Failed to create config directory: $config_dir"
            return 1
        }

        # Save the volume to file
        echo "$vol" > "$volume_file" || {
            error "Failed to save volume to: $volume_file"
            return 1
        }
    }

    restore_volume_after_mute() {
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"

        # Check if the file exists
        if [[ ! -f "$volume_file" ]]; then
            return 1
        fi

        # Read the saved volume
        local saved_vol
        saved_vol=$(cat "$volume_file" 2>/dev/null)

        # Validate the volume
        if empty "$saved_vol" || ! [[ "$saved_vol" =~ ^[0-9]+$ ]]; then
            rm -f "$volume_file"
            return 1
        fi

        # Return the saved volume
        echo "$saved_vol"
    }

    clear_saved_volume() {
        local config_dir volume_file
        config_dir=$(get_config_dir)
        volume_file="$config_dir/.volume_before_mute"
        rm -f "$volume_file"
    }

    get_wheel_delta_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.wheel_delta"
    }

    get_wheel_delta() {
        local delta_file
        delta_file=$(get_wheel_delta_file)

        if [[ ! -f "$delta_file" ]]; then
            echo "0"
            return
        fi

        local delta
        delta=$(cat "$delta_file" 2>/dev/null)

        if empty "$delta" || ! [[ "$delta" =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
            echo "0"
            return
        fi

        echo "$delta"
    }

    save_wheel_delta() {
        local -r delta=$1
        local config_dir delta_file
        config_dir=$(get_config_dir)
        delta_file=$(get_wheel_delta_file)

        # Create config directory if it doesn't exist
        mkdir -p "$config_dir" || {
            error "Failed to create config directory: $config_dir"
            return 1
        }

        # Save the delta to file
        echo "$delta" > "$delta_file" || {
            error "Failed to save wheel delta to: $delta_file"
            return 1
        }
    }

    get_boost_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.volume_boost"
    }

    get_boost_pid_file() {
        local config_dir
        config_dir=$(get_config_dir)
        echo "$config_dir/.volume_boost_pid"
    }

    save_boost_state() {
        local -r original_vol=$1
        local -r boost_amount=$2
        local -r timeout_sec=$3
        local boost_file
        boost_file=$(get_boost_file)

        # Create config directory if it doesn't exist
        local config_dir
        config_dir=$(get_config_dir)
        mkdir -p "$config_dir" || {
            error "Failed to create config directory: $config_dir"
            return 1
        }

        # Save boost state: original_vol|boost_amount|timeout_sec|timestamp
        echo "${original_vol}|${boost_amount}|${timeout_sec}|$(date +%s)" > "$boost_file" || {
            error "Failed to save boost state"
            return 1
        }
    }

    get_boost_state() {
        local boost_file
        boost_file=$(get_boost_file)

        if [[ ! -f "$boost_file" ]]; then
            return 1
        fi

        # Read boost state
        local boost_data
        boost_data=$(cat "$boost_file" 2>/dev/null)

        if empty "$boost_data"; then
            return 1
        fi

        # Parse: original_vol|boost_amount|timeout_sec|timestamp
        IFS='|' read -r BOOST_ORIGINAL_VOL BOOST_AMOUNT BOOST_TIMEOUT BOOST_TIMESTAMP <<< "$boost_data"

        # Validate
        if empty "$BOOST_ORIGINAL_VOL" || empty "$BOOST_AMOUNT" || empty "$BOOST_TIMEOUT" || empty "$BOOST_TIMESTAMP"; then
            return 1
        fi

        # Check if boost has expired
        local current_time elapsed_time
        current_time=$(date +%s)
        elapsed_time=$(( current_time - BOOST_TIMESTAMP ))

        if (( elapsed_time >= BOOST_TIMEOUT )); then
            # Boost has expired, clean up
            clear_boost_state
            return 1
        fi

        return 0
    }

    clear_boost_state() {
        local boost_file pid_file
        boost_file=$(get_boost_file)
        pid_file=$(get_boost_pid_file)

        # Kill background process if it exists
        if [[ -f "$pid_file" ]]; then
            local pid
            pid=$(cat "$pid_file" 2>/dev/null)
            if not_empty "$pid" && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
            fi
            rm -f "$pid_file"
        fi

        rm -f "$boost_file"
    }

    is_boost_active() {
        get_boost_state 2>/dev/null
    }

    enable_boost() {
        local -r boost_amount=${1:?$(error 'Boost amount is required')}
        local -r timeout_sec=${2:-30}  # Default 30 seconds
        local current_vol original_vol target_vol actual_boost

        # Validate boost amount
        if ! [[ "$boost_amount" =~ ^[0-9]+$ ]] || (( boost_amount < 1 || boost_amount > 100 )); then
            error "Invalid boost amount: $boost_amount (must be 1-100)"
            return 1
        fi

        # Check if boost is already active
        if is_boost_active; then
            error "Boost is already active. Use 'volume boost off' to cancel first."
            return 1
        fi

        # Get current volume
        current_vol=$(get_volume)
        original_vol=$current_vol

        # Calculate target volume (boost is additive percentage)
        target_vol=$(( current_vol + boost_amount ))
        actual_boost=$boost_amount

        # Respect MAX_VOL if set (per-sink or global)
        local effective_max_vol
        effective_max_vol=$(get_effective_max_vol)
        if not_empty "$effective_max_vol" && (( target_vol > effective_max_vol )); then
            target_vol=$effective_max_vol
            # Adjust boost amount to what we can actually apply
            actual_boost=$(( target_vol - original_vol ))
            if (( actual_boost <= 0 )); then
                error "Cannot boost: already at maximum volume"
                return 1
            fi
        fi

        # Don't exceed 200% (hard limit for safety)
        if (( target_vol > 200 )); then
            target_vol=200
            actual_boost=$(( target_vol - original_vol ))
        fi

        # Save boost state (use actual_boost for what was actually applied)
        save_boost_state "$original_vol" "$actual_boost" "$timeout_sec" || return 1

        # Set boosted volume
        if not_empty "$FADE_DURATION"; then
            fade_volume "$target_vol" "$FADE_DURATION" "$NODE_ID"
        else
            invalidate_cache
            wpctl set-volume "$NODE_ID" "${target_vol}%"
        fi

        # Start background process to auto-revert
        # Capture values needed in subshell
        local config_dir_boost node_id_boost
        config_dir_boost=$(get_config_dir)
        node_id_boost=$NODE_ID
        (
            sleep "$timeout_sec"
            # Check if boost is still active (might have been cancelled)
            local boost_file restore_vol
            boost_file="$config_dir_boost/.volume_boost"
            if [[ -f "$boost_file" ]]; then
                # Read original volume from file
                local boost_data
                boost_data=$(cat "$boost_file" 2>/dev/null)
                if [[ -n "$boost_data" ]]; then
                    IFS='|' read -r restore_vol _ _ _ <<< "$boost_data"
                    # Restore original volume (direct wpctl call, no fade in background)
                    if [[ -n "$restore_vol" ]]; then
                        wpctl set-volume "$node_id_boost" "${restore_vol}%" &>/dev/null
                    fi
                    # Clean up boost state files
                    rm -f "$boost_file"
                    rm -f "$config_dir_boost/.volume_boost_pid"
                fi
            fi
        ) &

        # Save PID of background process
        local pid_file
        pid_file=$(get_boost_pid_file)
        echo $! > "$pid_file"

        if [[ "$actual_boost" != "$boost_amount" ]]; then
            echo "Boost enabled: +${actual_boost}% (requested +${boost_amount}%, limited by max volume) for ${timeout_sec}s"
        else
            echo "Boost enabled: +${actual_boost}% for ${timeout_sec}s"
        fi
    }

    disable_boost() {
        if ! is_boost_active; then
            error "No active boost to cancel"
            return 1
        fi

        # Get original volume
        local original_vol
        original_vol=$BOOST_ORIGINAL_VOL

        # Restore original volume
        if not_empty "$FADE_DURATION"; then
            fade_volume "$original_vol" "$FADE_DURATION" "$NODE_ID"
        else
            invalidate_cache
            wpctl set-volume "$NODE_ID" "${original_vol}%"
        fi

        # Clear boost state (this also kills the background process)
        clear_boost_state

        echo "Boost disabled"
    }

    boost() {
        local -r subcommand=${1:-}
        local -r value=${2:-}

        case "$subcommand" in
            off|cancel|disable)
                disable_boost
                ;;
            "")
                error "Boost subcommand required. Use: boost <amount> [timeout] or boost off"
                echo "  ${COLOR_GREEN}boost <amount> [timeout]${COLOR_RESET}  - enable boost (default timeout: 30s)"
                echo "  ${COLOR_GREEN}boost off${COLOR_RESET}                 - disable boost"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                # Try to parse as boost amount
                if [[ "$subcommand" =~ ^[0-9]+$ ]]; then
                    enable_boost "$subcommand" "$value"
                else
                    error "Unknown boost subcommand: $subcommand"
                    echo "Use: boost <amount> [timeout] or boost off"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                ;;
        esac
    }

    save_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        # Validate profile name (alphanumeric, dash, underscore only)
        if [[ ! "$profile_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            error "Invalid profile name: $profile_name"
            echo "Profile names can only contain letters, numbers, dashes, and underscores."
            return 1
        fi

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        # Create profiles directory if it doesn't exist
        mkdir -p "$profiles_dir" || {
            error "Failed to create profiles directory: $profiles_dir"
            return 1
        }

        # Get current state
        local vol muted sink_name port_id mic_vol mic_muted
        vol=$(get_volume)
        muted=$(is_muted && echo "true" || echo "false")
        sink_name="$NODE_NAME"
        port_id=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "EnumPort") | .value' 2>/dev/null || echo "")

        # Get mic state if available
        if not_empty "$SOURCE_ID"; then
            mic_vol=$(get_mic_volume 2>/dev/null || echo "")
            mic_muted=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
        else
            mic_vol=""
            mic_muted=""
        fi

        # Create JSON profile
        local profile_json
        profile_json=$(jq -n \
            --arg vol "$vol" \
            --arg muted "$muted" \
            --arg sink "$sink_name" \
            --arg port "$port_id" \
            --arg mic_vol "${mic_vol:-}" \
            --arg mic_muted "${mic_muted:-}" \
            '{volume: ($vol | tonumber), muted: ($muted == "true"), sink: $sink, port: (if $port == "" then null else $port end), mic_volume: (if $mic_vol == "" then null else ($mic_vol | tonumber) end), mic_muted: (if $mic_muted == "" then null else ($mic_muted == "true") end)}' 2>/dev/null)

        if empty "$profile_json"; then
            error "Failed to create profile JSON"
            return 1
        fi

        # Save to file
        echo "$profile_json" > "$profile_file" || {
            error "Failed to save profile to: $profile_file"
            return 1
        }

        echo "Profile saved: $profile_name"
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")
            summary="Profile saved: $profile_name"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd 0 "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti 0 ;;
                kosd    ) notify_volume_kosd 0 ;;
                *       ) notify_volume_libnotify 0 "$icon" "$summary" "" ;;
            esac
        fi
    }

    load_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        if [[ ! -f "$profile_file" ]]; then
            error_with_suggestion "Profile not found: $profile_name" \
                "Use 'volume profile list' to see available profiles." \
                "Create a profile with: volume profile save <name>"
            return 1
        fi

        # Read profile JSON
        local vol muted sink_name port_id mic_vol mic_muted
        vol=$(jq -r '.volume // empty' "$profile_file" 2>/dev/null)
        muted=$(jq -r '.muted // false' "$profile_file" 2>/dev/null)
        sink_name=$(jq -r '.sink // empty' "$profile_file" 2>/dev/null)
        port_id=$(jq -r '.port // empty' "$profile_file" 2>/dev/null)
        mic_vol=$(jq -r '.mic_volume // empty' "$profile_file" 2>/dev/null)
        mic_muted=$(jq -r '.mic_muted // false' "$profile_file" 2>/dev/null)

        if empty "$vol"; then
            error "Invalid profile: $profile_name (missing volume)"
            return 1
        fi

        # Switch sink if specified and different
        if not_empty "$sink_name" && [[ "$sink_name" != "$NODE_NAME" ]]; then
            # Find sink by name
            local sink_id
            sink_id=$(pw_dump | jq -r --arg name "$sink_name" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.name" == $name) | .id' 2>/dev/null)

            if not_empty "$sink_id"; then
                wpctl set-default "$sink_id" &>/dev/null
                invalidate_cache
                # Reinitialize audio to get new NODE_ID
                NODE_NAME="$sink_name"
                NODE_ID=$(get_node_id)
            fi
        fi

        # Set volume
        set_volume "$vol"

        # Set mute status
        local current_muted
        current_muted=$(is_muted && echo "true" || echo "false")
        if [[ "$muted" == "true" && "$current_muted" != "true" ]]; then
            toggle_mute
        elif [[ "$muted" != "true" && "$current_muted" == "true" ]]; then
            toggle_mute
        fi

        # Set port if specified
        if not_empty "$port_id" && [[ "$port_id" != "null" ]]; then
            set_port "$port_id" &>/dev/null || true
        fi

        # Set mic volume and mute if specified
        if not_empty "$mic_vol" && [[ "$mic_vol" != "null" ]] && not_empty "$SOURCE_ID"; then
            set_mic_volume "$mic_vol"
            local current_mic_muted
            current_mic_muted=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
            if [[ "$mic_muted" == "true" && "$current_mic_muted" != "true" ]]; then
                toggle_mic_mute
            elif [[ "$mic_muted" != "true" && "$current_mic_muted" == "true" ]]; then
                toggle_mic_mute
            fi
        fi

        echo "Profile loaded: $profile_name"
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[1]}" || echo "${ICONS_SYMBOLIC[1]}")
            summary="Profile loaded: $profile_name"

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd "$vol" "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti "$vol" ;;
                kosd    ) notify_volume_kosd "$vol" ;;
                *       ) notify_volume_libnotify "$vol" "$icon" "$summary" "" ;;
            esac
        fi

        # Update statusbar
        update_statusbar || true
    }

    list_profiles() {
        local profiles_dir
        profiles_dir=$(get_profiles_dir)

        if [[ ! -d "$profiles_dir" ]]; then
            echo "${COLOR_YELLOW}No profiles directory found.${COLOR_RESET}"
            echo "Save a profile first using: ${COLOR_GREEN}volume profile save <name>${COLOR_RESET}"
            return 0
        fi

        local profiles
        readarray -t profiles < <(find "$profiles_dir" -name "*.json" -type f -printf "%f\n" 2>/dev/null | sed 's/\.json$//' | sort)

        if [[ ${#profiles[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No profiles found.${COLOR_RESET}"
            echo "Save a profile first using: ${COLOR_GREEN}volume profile save <name>${COLOR_RESET}"
            return 0
        fi

        echo "${COLOR_YELLOW}Saved Profiles:${COLOR_RESET}"
        echo

        local profile_name profile_file vol muted sink_name
        for profile_name in "${profiles[@]}"; do
            profile_file="$profiles_dir/$profile_name.json"
            vol=$(jq -r '.volume // "N/A"' "$profile_file" 2>/dev/null)
            muted=$(jq -r '.muted // false' "$profile_file" 2>/dev/null)
            sink_name=$(jq -r '.sink // "default"' "$profile_file" 2>/dev/null)

            printf "  ${COLOR_GREEN}%s${COLOR_RESET}" "$profile_name"
            if [[ "$muted" == "true" ]]; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%s%%${COLOR_RESET}" "$vol"
            fi
            echo "  ${COLOR_MAGENTA}($sink_name)${COLOR_RESET}"
        done
        echo
    }

    delete_profile() {
        local -r profile_name=${1:?$(error 'Profile name is required')}
        local profiles_dir profile_file

        profiles_dir=$(get_profiles_dir)
        profile_file="$profiles_dir/$profile_name.json"

        if [[ ! -f "$profile_file" ]]; then
            error_with_suggestion "Profile not found: $profile_name" \
                "Use 'volume profile list' to see available profiles." \
                "Create a profile with: volume profile save <name>"
            return 1
        fi

        rm -f "$profile_file" || {
            error "Failed to delete profile: $profile_name"
            return 1
        }

        echo "Profile deleted: $profile_name"
    }

    profile() {
        local -r subcommand=${1:-}
        local -r target=${2:-}

        case "$subcommand" in
            save)
                if empty "$target"; then
                    error "Profile name required. Use: profile save <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                save_profile "$target"
                ;;
            load)
                if empty "$target"; then
                    error "Profile name required. Use: profile load <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                load_profile "$target"
                ;;
            list)
                list_profiles
                ;;
            delete|remove|rm)
                if empty "$target"; then
                    error "Profile name required. Use: profile delete <name>"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                delete_profile "$target"
                ;;
            "")
                error "Profile subcommand required. Use: profile save|load|list|delete"
                echo "  ${COLOR_GREEN}profile save <name>${COLOR_RESET}   - save current settings as profile"
                echo "  ${COLOR_GREEN}profile load <name>${COLOR_RESET}   - load a saved profile"
                echo "  ${COLOR_GREEN}profile list${COLOR_RESET}          - list all saved profiles"
                echo "  ${COLOR_GREEN}profile delete <name>${COLOR_RESET} - delete a profile"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                # Quick access: profile <name> loads the profile
                load_profile "$subcommand"
                ;;
        esac
    }

    get_config_file() {
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config"
    }

    show_config() {
        local config_file
        config_file=$(get_config_file)

        if [[ ! -f "$config_file" ]]; then
            echo "${COLOR_YELLOW}No configuration file found.${COLOR_RESET}"
            echo "Config file location: ${COLOR_CYAN}$config_file${COLOR_RESET}"
            echo ""
            echo "Create a config file to customize i3-volume behavior."
            echo "Use ${COLOR_GREEN}volume config validate${COLOR_RESET} to check config syntax."
            return 0
        fi

        echo "${COLOR_YELLOW}Current Configuration:${COLOR_RESET}"
        echo "Config file: ${COLOR_CYAN}$config_file${COLOR_RESET}"
        echo ""

        # Show all config variables with their current values
        local line_num=0
        while IFS= read -r line || [[ -n "$line" ]]; do
            ((line_num++))
            local trimmed_line
            trimmed_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # Skip empty lines and comments
            [[ -z "$trimmed_line" ]] && continue
            [[ "$trimmed_line" =~ ^# ]] && continue

            # Check for include directive
            if [[ "$trimmed_line" =~ ^source[[:space:]]+ ]] || [[ "$trimmed_line" =~ ^\.[[:space:]]+ ]]; then
                local include_file
                include_file=$(echo "$trimmed_line" | sed -E 's/^(source|\.)[[:space:]]+["'\'']?([^"'\'']+)["'\'']?.*/\2/')
                printf "  ${COLOR_MAGENTA}%s${COLOR_RESET} ${COLOR_CYAN}(include: %s)${COLOR_RESET}\n" "$trimmed_line" "$include_file"
                continue
            fi

            # Extract variable name and value
            if [[ "$trimmed_line" =~ ^([A-Z_][A-Z0-9_]*(\[.*\])?)=(.*)$ ]]; then
                local var_name="${BASH_REMATCH[1]}"
                local var_value="${BASH_REMATCH[3]}"

                # Remove quotes if present
                var_value=$(echo "$var_value" | sed "s/^[\"']//;s/[\"']$//")

                # Get current value from environment (try to evaluate safely)
                local current_value="<not set>"
                if [[ "$var_name" =~ \[ ]]; then
                    # Array variable - show as-is
                    current_value="$var_value"
                else
                    # Regular variable - try to get from environment
                    local var_ref="${var_name}"
                    if [[ -n "${!var_ref:-}" ]]; then
                        current_value="${!var_ref}"
                    else
                        current_value="$var_value ${COLOR_MAGENTA}(from config, not yet loaded)${COLOR_RESET}"
                    fi
                fi

                printf "  ${COLOR_CYAN}%s${COLOR_RESET} = ${COLOR_GREEN}%s${COLOR_RESET}\n" "$var_name" "$current_value"
            fi
        done < "$config_file"

        echo ""
        echo "Use ${COLOR_GREEN}volume config validate${COLOR_RESET} to check config syntax."
        echo "Use ${COLOR_GREEN}volume config docs${COLOR_RESET} to see all configurable variables."
    }

    validate_config() {
        local config_file
        config_file=$(get_config_file)

        if [[ ! -f "$config_file" ]]; then
            echo "${COLOR_YELLOW}No configuration file found.${COLOR_RESET}"
            echo "Config file location: ${COLOR_CYAN}$config_file${COLOR_RESET}"
            return 0
        fi

        echo "${COLOR_YELLOW}Validating configuration file:${COLOR_RESET} ${COLOR_CYAN}$config_file${COLOR_RESET}"
        echo ""

        local errors=0
        local line_num=0

        while IFS= read -r line || [[ -n "$line" ]]; do
            ((line_num++))
            local trimmed_line
            trimmed_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # Skip empty lines and comments
            [[ -z "$trimmed_line" ]] && continue
            [[ "$trimmed_line" =~ ^# ]] && continue

            # Check for include directive
            if [[ "$trimmed_line" =~ ^source[[:space:]]+ ]] || [[ "$trimmed_line" =~ ^\.[[:space:]]+ ]]; then
                local include_file
                include_file=$(echo "$trimmed_line" | sed -E 's/^(source|\.)[[:space:]]+["'\'']?([^"'\'']+)["'\'']?.*/\2/')
                if [[ ! -f "$include_file" ]]; then
                    # Try relative to config directory
                    local config_dir
                    config_dir=$(get_config_dir)
                    if [[ ! -f "$config_dir/$include_file" ]]; then
                        echo "${COLOR_RED}Error on line $line_num:${COLOR_RESET} Include file not found: ${COLOR_CYAN}$include_file${COLOR_RESET}"
                        ((errors++))
                    fi
                fi
                continue
            fi

            # Check for valid variable assignment
            if [[ ! "$trimmed_line" =~ ^[A-Z_][A-Z0-9_]*= ]]; then
                # Check if it's an array assignment
                if [[ "$trimmed_line" =~ ^[A-Z_][A-Z0-9_]*\[.*\]= ]]; then
                    # Valid array assignment
                    continue
                else
                    echo "${COLOR_RED}Error on line $line_num:${COLOR_RESET} Invalid syntax: ${COLOR_CYAN}$trimmed_line${COLOR_RESET}"
                    echo "  Expected format: VARIABLE_NAME=value or VARIABLE_NAME[key]=value"
                    ((errors++))
                fi
            fi
        done < "$config_file"

        # Try to source the config to check for syntax errors
        if (( errors == 0 )); then
            # Use a subshell to avoid affecting current environment
            if ! (bash -n "$config_file" 2>&1); then
                echo "${COLOR_RED}Syntax errors found when parsing config file:${COLOR_RESET}"
                bash -n "$config_file" 2>&1 | while IFS= read -r err_line; do
                    echo "  $err_line"
                done
                ((errors++))
            fi
        fi

        if (( errors == 0 )); then
            echo "${COLOR_GREEN}âœ“ Configuration file is valid${COLOR_RESET}"
            return 0
        else
            echo ""
            echo "${COLOR_RED}âœ— Found $errors error(s)${COLOR_RESET}"
            return 1
        fi
    }

    show_config_docs() {
        cat <<- EOF
${COLOR_YELLOW}i3-volume Configuration Variables${COLOR_RESET}

Configuration file location: ${COLOR_CYAN}~/.config/i3-volume/config${COLOR_RESET} or ${COLOR_CYAN}\$XDG_CONFIG_HOME/i3-volume/config${COLOR_RESET}

${COLOR_YELLOW}Notification Settings:${COLOR_RESET}
  ${COLOR_CYAN}NOTIFICATION_METHOD${COLOR_RESET}
    Notification method to use (default: libnotify)
    Options: libnotify, dunst, xosd, herbe, volnoti, kosd

  ${COLOR_CYAN}DISPLAY_NOTIFICATIONS${COLOR_RESET}
    Enable/disable notifications (default: false)
    Values: true, false

  ${COLOR_CYAN}USE_DUNSTIFY${COLOR_RESET}
    Use dunstify instead of notify-send (default: false)
    Values: true, false

  ${COLOR_CYAN}USE_FULLCOLOR_ICONS${COLOR_RESET}
    Use full-color icons instead of symbolic (default: false)
    Values: true, false

  ${COLOR_CYAN}SHOW_VOLUME_PROGRESS${COLOR_RESET}
    Show progress bar in notifications (default: false)
    Values: true, false

  ${COLOR_CYAN}PROGRESS_PLACEMENT${COLOR_RESET}
    Where to place progress bar (default: summary)
    Options: summary, body

  ${COLOR_CYAN}EXPIRES${COLOR_RESET}
    Notification expiration time in milliseconds (default: 1500)
    Values: integer (milliseconds)

  ${COLOR_CYAN}SYMBOLIC_ICON_SUFFIX${COLOR_RESET}
    Suffix to add to symbolic icon names
    Values: string

  ${COLOR_CYAN}NOTIFICATION_GROUP${COLOR_RESET}
    Group volume change notifications (dunst only) (default: false)
    Values: true, false

${COLOR_YELLOW}Volume Control Settings:${COLOR_RESET}
  ${COLOR_CYAN}DEFAULT_STEP${COLOR_RESET}
    Default step size for volume changes (default: 5)
    Values: integer (percentage)

  ${COLOR_CYAN}MAX_VOL${COLOR_RESET}
    Maximum volume limit (optional)
    Values: integer (percentage, 0-200)

${COLOR_YELLOW}Per-Sink Configuration:${COLOR_RESET}
  Per-sink settings allow you to configure different values for different audio devices.
  Settings can be keyed by sink ID, name, or nick. Per-sink settings take precedence
  over global settings.

  ${COLOR_CYAN}SINK_MAX_VOL[sink_identifier]${COLOR_RESET}
    Per-sink maximum volume limit
    Examples:
      SINK_MAX_VOL[alsa_output.pci-0000_00_1f.3.analog-stereo]=100
      SINK_MAX_VOL[USB Audio]=120
      SINK_MAX_VOL[headphones]=150

  ${COLOR_CYAN}SINK_DEFAULT_STEP[sink_identifier]${COLOR_RESET}
    Per-sink default step size for volume changes
    Examples:
      SINK_DEFAULT_STEP[alsa_output.pci-0000_00_1f.3.analog-stereo]=5
      SINK_DEFAULT_STEP[USB Audio]=10
      SINK_DEFAULT_STEP[headphones]=2

  ${COLOR_CYAN}SINK_DISPLAY_NOTIFICATIONS[sink_identifier]${COLOR_RESET}
    Per-sink notification display preference
    Examples:
      SINK_DISPLAY_NOTIFICATIONS[headphones]=true
      SINK_DISPLAY_NOTIFICATIONS[speakers]=false

  Note: Per-sink settings are automatically applied when the sink changes.

  ${COLOR_CYAN}FADE_DURATION${COLOR_RESET}
    Fade duration in milliseconds for volume changes (optional)
    Values: integer (milliseconds)

${COLOR_YELLOW}Status Bar Settings:${COLOR_RESET}
  ${COLOR_CYAN}STATUSLINE${COLOR_RESET}
    Status bar process name (e.g., i3blocks)
    Values: string

  ${COLOR_CYAN}SIGNAL${COLOR_RESET}
    Signal to send to status bar (requires STATUSLINE)
    Values: string (e.g., SIGRTMIN+10)

${COLOR_YELLOW}Audio Device Settings:${COLOR_RESET}
  ${COLOR_CYAN}NODE_NAME${COLOR_RESET}
    Default sink name (optional)
    Values: string

  ${COLOR_CYAN}SOURCE_NAME${COLOR_RESET}
    Default source name (optional)
    Values: string

  ${COLOR_CYAN}NODE_ALIASES${COLOR_RESET}
    Aliases for node names (associative array)
    Example: NODE_ALIASES[ALC287 Analog]="Speakers"

  ${COLOR_CYAN}PORT_ALIASES${COLOR_RESET}
    Aliases for port names (associative array)
    Example: PORT_ALIASES[analog-output-speaker]="Speaker"

${COLOR_YELLOW}Sound Settings:${COLOR_RESET}
  ${COLOR_CYAN}PLAY_SOUND${COLOR_RESET}
    Play sound for volume changes (default: false)
    Values: true, false

  ${COLOR_CYAN}USE_CANBERRA${COLOR_RESET}
    Use libcanberra for sound playback (default: false)
    Values: true, false

${COLOR_YELLOW}Other Settings:${COLOR_RESET}
  ${COLOR_CYAN}ALL_SINKS${COLOR_RESET}
    Operate on all sinks (default: false)
    Values: true, false

  ${COLOR_CYAN}VERBOSE${COLOR_RESET}
    Enable verbose mode (default: false)
    Values: true, false

${COLOR_YELLOW}Config File Includes:${COLOR_RESET}
  You can include other config files using:
    source /path/to/other/config
    . /path/to/other/config

  Paths can be relative to the config directory or absolute.

${COLOR_YELLOW}Example Configuration:${COLOR_RESET}
  See example configs in: ${COLOR_CYAN}~/.config/i3-volume/examples/${COLOR_RESET}

EOF
    }

    config() {
        local -r subcommand=${1:-}
        local -r target=${2:-}

        case "$subcommand" in
            show|list|"")
                show_config
                ;;
            validate|check)
                validate_config
                ;;
            docs|help|variables)
                show_config_docs
                ;;
            *)
                error "Unknown config subcommand: $subcommand"
                echo "Valid subcommands:"
                echo "  ${COLOR_GREEN}config${COLOR_RESET}              - show current configuration"
                echo "  ${COLOR_GREEN}config validate${COLOR_RESET}    - validate config file syntax"
                echo "  ${COLOR_GREEN}config docs${COLOR_RESET}         - show all configurable variables"
                EXITCODE=$EX_USAGE
                return 1
                ;;
        esac
    }

    get_all_sinks() {
        # Returns array of sink IDs
        local sinks
        readarray -t sinks < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | .id' 2>/dev/null)
        echo "${sinks[@]}"
    }

    get_all_sources() {
        # Returns array of source IDs
        local sources
        readarray -t sources < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Source") | .id' 2>/dev/null)
        echo "${sources[@]}"
    }

    set_volume_all() {
        local -r vol=$1
        local -r op=${2:-}
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error_with_suggestion "No audio sinks found." \
                "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
                "Ensure audio devices are connected and recognized by the system."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        local sink_id
        for sink_id in "${all_sinks[@]}"; do
            local target_vol current_vol
            local effective_max_vol
            effective_max_vol=$(get_effective_max_vol "$sink_id")

            if not_empty "$effective_max_vol"; then
                case "$op" in
                    +)  # Increase volume
                        current_vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
                        if (( current_vol + vol > effective_max_vol )); then
                            local -r step=$( max "0" "$(( effective_max_vol - current_vol ))" )
                            if not_empty "$FADE_DURATION"; then
                                fade_volume "$effective_max_vol" "$FADE_DURATION" "$sink_id"
                            else
                                wpctl set-volume "$sink_id" "$step%+"
                            fi
                            continue
                        fi
                        ;;
                    *)  # Set absolute volume
                        if (( vol > effective_max_vol )); then
                            continue
                        fi
                        ;;
                esac
            fi

            # Handle fade if requested
            if not_empty "$FADE_DURATION"; then
                case "$op" in
                    +)
                        current_vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
                        target_vol=$(( current_vol + vol ))
                        fade_volume "$target_vol" "$FADE_DURATION" "$sink_id"
                        ;;
                    -)
                        current_vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
                        target_vol=$(( current_vol - vol ))
                        fade_volume "$target_vol" "$FADE_DURATION" "$sink_id"
                        ;;
                    *)
                        fade_volume "$vol" "$FADE_DURATION" "$sink_id"
                        ;;
                esac
            else
                case "$op" in
                    +) wpctl set-volume "$sink_id" "${vol}%+" ;;
                    -) wpctl set-volume "$sink_id" "${vol}%-" ;;
                    *) wpctl set-volume "$sink_id" "${vol}%" ;;
                esac
            fi
        done

        invalidate_cache
    }

    toggle_mute_all() {
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error_with_suggestion "No audio sinks found." \
                "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
                "Ensure audio devices are connected and recognized by the system."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        local sink_id
        for sink_id in "${all_sinks[@]}"; do
            local is_muted
            is_muted=$(wpctl get-volume "$sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)

            if not_empty "$FADE_DURATION"; then
                if $is_muted; then
                    # Fade in (unmute)
                    wpctl set-mute "$sink_id" 0
                    local current_vol
                    current_vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
                    if (( current_vol == 0 )); then
                        fade_volume "${DEFAULT_VOL:-50}" "$FADE_DURATION" "$sink_id"
                    else
                        wpctl set-volume "$sink_id" "0%"
                        fade_volume "$current_vol" "$FADE_DURATION" "$sink_id"
                    fi
                else
                    # Fade out (mute)
                    wpctl set-mute "$sink_id" 0 &>/dev/null
                    local current_vol
                    current_vol=$(wpctl get-volume "$sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
                    fade_volume 0 "$FADE_DURATION" "$sink_id" "$current_vol"
                    wpctl set-volume "$sink_id" "0%" &>/dev/null
                    wpctl set-mute "$sink_id" 1
                    wpctl set-volume "$sink_id" "0%" &>/dev/null
                fi
            else
                wpctl set-mute "$sink_id" toggle
            fi
        done

        invalidate_cache
    }

    sync_volume() {
        # Get volume from default sink and sync to all other sinks
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error_with_suggestion "No audio sinks found." \
                "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
                "Ensure audio devices are connected and recognized by the system."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        if [[ ${#all_sinks[@]} -eq 1 ]]; then
            echo "Only one sink available. Nothing to sync."
            return 0
        fi

        # Get volume and mute status from default sink
        local default_sink_id
        default_sink_id=$(get_default_sink_id)

        if empty "$default_sink_id"; then
            error_with_suggestion "Could not determine default sink." \
                "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
                "Use 'volume list sinks' to see available sinks." \
                "Set a default sink manually if needed."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        local target_vol target_muted
        target_vol=$(wpctl get-volume "$default_sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
        target_muted=$(wpctl get-volume "$default_sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)

        # Sync to all sinks
        local sink_id synced_count=0
        for sink_id in "${all_sinks[@]}"; do
            # Skip the default sink (already at target)
            if [[ "$sink_id" == "$default_sink_id" ]]; then
                continue
            fi

            # Set volume
            if not_empty "$FADE_DURATION"; then
                fade_volume "$target_vol" "$FADE_DURATION" "$sink_id"
            else
                wpctl set-volume "$sink_id" "${target_vol}%"
            fi

            # Set mute status
            local current_muted
            current_muted=$(wpctl get-volume "$sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)
            if [[ "$target_muted" == "true" && "$current_muted" != "true" ]]; then
                wpctl set-mute "$sink_id" 1
            elif [[ "$target_muted" != "true" && "$current_muted" == "true" ]]; then
                wpctl set-mute "$sink_id" 0
            fi

            ((synced_count++))
        done

        invalidate_cache

        if (( synced_count > 0 )); then
            local mute_text=""
            if $target_muted; then
                mute_text=" (MUTED)"
            fi
            echo "Synced volume to $synced_count sink(s): ${target_vol}%${mute_text}"
        else
            echo "All sinks already synchronized."
        fi
    }

    get_default_sink_id() {
        # Returns the ID of the current default sink
        local default_sink_name
        default_sink_name=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
        pw_dump | jq -r --arg name "$default_sink_name" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == $name) | .id' 2>/dev/null
    }

    get_sink_display_name_by_id() {
        local -r sink_id=$1
        local sink_name sink_nick display_name

        sink_name=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
        sink_nick=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.nick" // "N/A"' 2>/dev/null)

        # Apply alias if available
        display_name="$sink_nick"
        if isset NODE_ALIASES["$sink_id"]; then
            display_name="${NODE_ALIASES[$sink_id]}"
        elif isset NODE_ALIASES["$sink_name"]; then
            display_name="${NODE_ALIASES[$sink_name]}"
        elif isset NODE_ALIASES["$sink_nick"]; then
            display_name="${NODE_ALIASES[$sink_nick]}"
        fi

        echo "$display_name"
    }

    find_sink_by_name_or_id() {
        # Find sink by ID, name, nick, or alias
        local -r search=$1
        local sink_id sink_name sink_nick

        # Try as ID first
        sink_id=$(pw_dump | jq -r --argjson id "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .id == ($id | tonumber? // empty)) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as name
        sink_id=$(pw_dump | jq -r --arg name "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.name" == $name) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as nick
        sink_id=$(pw_dump | jq -r --arg nick "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and .info.props."node.nick" == $nick) | .id' 2>/dev/null)

        if not_empty "$sink_id"; then
            echo "$sink_id"
            return 0
        fi

        # Try as alias
        local alias_key
        for alias_key in "${!NODE_ALIASES[@]}"; do
            if [[ "${NODE_ALIASES[$alias_key]}" == "$search" ]]; then
                # Found alias, now find the sink
                sink_id=$(pw_dump | jq -r --arg key "$alias_key" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink" and (.id == ($key | tonumber? // empty) or .info.props."node.name" == $key or .info.props."node.nick" == $key)) | .id' 2>/dev/null)
                if not_empty "$sink_id"; then
                    echo "$sink_id"
                    return 0
                fi
            fi
        done

        return 1
    }

    switch_sink() {
        local target_sink_id target_sink_name
        local -r target=${1:-}

        # Get all available sinks
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -eq 0 ]]; then
            error_with_suggestion "No audio sinks found." \
                "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
                "Ensure audio devices are connected and recognized by the system."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                local diag
                diag=$(get_pipewire_diagnostics)
                if not_empty "$diag"; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
                fi
            fi
            return 1
        fi

        if [[ ${#all_sinks[@]} -eq 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        # If no target specified, cycle to next sink
        if empty "$target"; then
            local current_sink_id
            current_sink_id=$(get_default_sink_id)

            if empty "$current_sink_id"; then
                error "Could not determine current default sink."
                return 1
            fi

            # Find current sink index
            local idx=0
            local found=false
            for sink in "${all_sinks[@]}"; do
                if [[ "$sink" == "$current_sink_id" ]]; then
                    found=true
                    break
                fi
                ((idx++))
            done

            if ! $found; then
                error "Current sink not found in available sinks."
                return 1
            fi

            # Move to next sink (wrap around)
            idx=$(( (idx + 1) % ${#all_sinks[@]} ))
            target_sink_id="${all_sinks[$idx]}"
        else
            # Find sink by name, ID, or alias
            target_sink_id=$(find_sink_by_name_or_id "$target")

            if empty "$target_sink_id"; then
                error_with_suggestion "Sink not found: $target" \
                    "Use 'volume list sinks' to see available sinks." \
                    "You can use sink ID, name, or nick to switch sinks."
                if [[ "${VERBOSE:-false}" == "true" ]]; then
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET} Searched for: $target" >&2
                    local available_sinks
                    available_sinks=$(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | "\(.id)|\(.info.props."node.name")|\(.info.props."node.nick" // "N/A")"' 2>/dev/null | head -5)
                    if not_empty "$available_sinks"; then
                        echo "${COLOR_CYAN}[verbose]${COLOR_RESET} Available sinks:" >&2
                        echo "$available_sinks" | while IFS='|' read -r id name nick; do
                            echo "${COLOR_CYAN}[verbose]${COLOR_RESET}   ID: $id, Name: $name, Nick: $nick" >&2
                        done
                    fi
                fi
                return 1
            fi

            # Check if it's already the default
            local current_sink_id
            current_sink_id=$(get_default_sink_id)
            if [[ "$target_sink_id" == "$current_sink_id" ]]; then
                echo "Sink is already the default."
                return 0
            fi
        fi

        # Switch to the target sink
        local switch_output
        if ! switch_output=$(wpctl set-default "$target_sink_id" 2>&1); then
            error_with_suggestion "Failed to switch to sink ID $target_sink_id" \
                "The sink may not be available or accessible." \
                "Use 'volume list sinks' to verify the sink exists."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                echo "${COLOR_CYAN}[verbose]${COLOR_RESET} wpctl output: $switch_output" >&2
            fi
            return 1
        fi

        # Get display name and volume for notification
        target_sink_name=$(get_sink_display_name_by_id "$target_sink_id")
        local target_vol target_muted
        target_vol=$(wpctl get-volume "$target_sink_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}')
        target_muted=$(wpctl get-volume "$target_sink_id" 2>/dev/null | grep -q '\[MUTED\]' && echo true || echo false)

        # Invalidate cache and reinitialize audio
        invalidate_cache

        # Update NODE_ID and NODE_NAME to the new sink for potential future use
        NODE_ID="$target_sink_id"
        NODE_NAME=$(pw_dump | jq -r --argjson id "$target_sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)

        # Show notification if enabled
        if $DISPLAY_NOTIFICATIONS; then
            local icon summary body=""

            # Get port information if available
            local port_info=""
            local port_desc
            port_desc=$(get_active_port_description 2>/dev/null || echo "")
            if not_empty "$port_desc"; then
                port_info=" - $port_desc"
            fi

            if $target_muted; then
                icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
                printf -v summary "Switched to: %s (MUTED)%s" "$target_sink_name" "$port_info"
            else
                icon=$(get_volume_icon "$target_vol")
                printf -v summary "Switched to: %s (%s%%)%s" "$target_sink_name" "$target_vol" "$port_info"
            fi

            case "$NOTIFICATION_METHOD" in
                xosd    ) notify_volume_xosd "$target_vol" "$summary" ;;
                herbe   ) notify_volume_herbe "$summary" ;;
                volnoti ) notify_volume_volnoti "$target_vol" ;;
                kosd    ) notify_volume_kosd "$target_vol" ;;
                *       ) notify_volume_libnotify "$target_vol" "$icon" "$summary" "$body" ;;
            esac
        else
            if $target_muted; then
                echo "Switched to: $target_sink_name (MUTED, ${target_vol}%)"
            else
                echo "Switched to: $target_sink_name (${target_vol}%)"
            fi
        fi

        # Update statusbar if configured
        update_statusbar || true
    }

    next_sink() { switch_sink; }
    prev_sink() {
        local -a all_sinks
        readarray -t all_sinks < <(get_all_sinks)

        if [[ ${#all_sinks[@]} -le 1 ]]; then
            error "Only one sink available. Nothing to switch to."
            return 1
        fi

        local current_sink_id
        current_sink_id=$(get_default_sink_id)

        if empty "$current_sink_id"; then
            error "Could not determine current default sink."
            return 1
        fi

        # Find current sink index
        local idx=0
        local found=false
        for sink in "${all_sinks[@]}"; do
            if [[ "$sink" == "$current_sink_id" ]]; then
                found=true
                break
            fi
            ((idx++))
        done

        if ! $found; then
            error "Current sink not found in available sinks."
            return 1
        fi

        # Move to previous sink (wrap around)
        idx=$(( (idx - 1 + ${#all_sinks[@]}) % ${#all_sinks[@]} ))
        local target_sink_id="${all_sinks[$idx]}"

        # Switch using the main function
        switch_sink "$target_sink_id"
    }

    list_apps() {
        # List all applications with active audio streams
        local streams
        readarray -t streams < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Stream/Output/Audio") | "\(.id)|\(.info.props."application.name" // .info.props."media.name" // .info.props."application.process.binary" // "Unknown")|\(.info.props."node.name" // "N/A")"' 2>/dev/null)

        if [[ ${#streams[@]} -eq 0 ]]; then
            echo "${COLOR_YELLOW}No active audio streams found.${COLOR_RESET}"
            echo "Start an application that plays audio to see it here."
            return 0
        fi

        echo "${COLOR_YELLOW}Active Audio Applications:${COLOR_RESET}"
        echo

        local stream_id app_name stream_name vol muted
        for stream in "${streams[@]}"; do
            IFS='|' read -r stream_id app_name stream_name <<< "$stream"

            # Get volume and mute status
            vol=$(wpctl get-volume "$stream_id" 2>/dev/null | awk '{printf "%.0f", $2 * 100}' || echo "0")
            muted=$(wpctl get-volume "$stream_id" 2>/dev/null | grep -q '\[MUTED\]' && echo "MUTED" || echo "")

            printf "  ${COLOR_CYAN}%3s${COLOR_RESET}  ${COLOR_GREEN}%s${COLOR_RESET}" "$stream_id" "$app_name"
            if not_empty "$muted"; then
                printf "  ${COLOR_RED}[MUTED]${COLOR_RESET}  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            else
                printf "  ${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            if [[ "$stream_name" != "N/A" && "$stream_name" != "$app_name" ]]; then
                echo "  ${COLOR_MAGENTA}($stream_name)${COLOR_RESET}"
            else
                echo
            fi
        done
        echo
    }

    find_app_stream() {
        # Find stream ID by application name (case-insensitive partial match)
        local -r search=$1
        local stream_id app_name

        # Try exact match first
        stream_id=$(pw_dump | jq -r --arg search "$search" '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Stream/Output/Audio" and (.info.props."application.name" == $search or .info.props."media.name" == $search or .info.props."application.process.binary" == $search)) | .id' 2>/dev/null | head -n1)

        if not_empty "$stream_id"; then
            echo "$stream_id"
            return 0
        fi

        # Try case-insensitive partial match
        # Get all streams and match in bash for better compatibility
        local streams
        readarray -t streams < <(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Stream/Output/Audio") | "\(.id)|\(.info.props."application.name" // .info.props."media.name" // .info.props."application.process.binary" // "")"' 2>/dev/null)

        local stream_id_match app_name search_lower app_lower
        search_lower=$(echo "$search" | tr '[:upper:]' '[:lower:]')
        for stream in "${streams[@]}"; do
            IFS='|' read -r stream_id_match app_name <<< "$stream"
            if not_empty "$app_name"; then
                app_lower=$(echo "$app_name" | tr '[:upper:]' '[:lower:]')
                if [[ "$app_lower" == *"$search_lower"* ]]; then
                    echo "$stream_id_match"
                    return 0
                fi
            fi
        done

        return 1
    }

    get_app_volume() {
        local -r stream_id=$1
        wpctl get-volume "$stream_id" 2>/dev/null | awk '{print $2 * 100}'
    }

    is_app_muted() {
        local -r stream_id=$1
        wpctl get-volume "$stream_id" 2>/dev/null | grep -q '\[MUTED\]'
    }

    set_app_volume() {
        local -r app_name=${1:?$(error 'Application name is required')}
        local -r vol=${2:?$(error 'Volume is required')}
        local -r op=${3:-}

        # Find the stream
        local stream_id
        stream_id=$(find_app_stream "$app_name")

        if empty "$stream_id"; then
            error_with_suggestion "Application not found: $app_name" \
                "Use 'volume app list' to see available applications." \
                "Application names are case-sensitive."
            return 1
        fi

        invalidate_cache

        local result
        case "$op" in
            +)
                if ! result=$(wpctl set-volume "$stream_id" "${vol}%+" 2>&1); then
                    error_with_suggestion "Failed to set volume for application: $app_name" \
                        "The application may have closed or the stream may be unavailable." \
                        "Use 'volume app list' to see currently available applications."
                    if [[ "${VERBOSE:-false}" == "true" ]] && not_empty "$result"; then
                        echo "${COLOR_CYAN}[verbose]${COLOR_RESET} wpctl output: $result" >&2
                    fi
                    return 1
                fi
                ;;
            -)
                if ! result=$(wpctl set-volume "$stream_id" "${vol}%-" 2>&1); then
                    error_with_suggestion "Failed to set volume for application: $app_name" \
                        "The application may have closed or the stream may be unavailable." \
                        "Use 'volume app list' to see currently available applications."
                    if [[ "${VERBOSE:-false}" == "true" ]] && not_empty "$result"; then
                        echo "${COLOR_CYAN}[verbose]${COLOR_RESET} wpctl output: $result" >&2
                    fi
                    return 1
                fi
                ;;
            *)
                if ! result=$(wpctl set-volume "$stream_id" "${vol}%" 2>&1); then
                    error_with_suggestion "Failed to set volume for application: $app_name" \
                        "The application may have closed or the stream may be unavailable." \
                        "Use 'volume app list' to see currently available applications."
                    if [[ "${VERBOSE:-false}" == "true" ]] && not_empty "$result"; then
                        echo "${COLOR_CYAN}[verbose]${COLOR_RESET} wpctl output: $result" >&2
                    fi
                    return 1
                fi
                # Small delay to ensure volume change takes effect
                sleep 0.05
                ;;
        esac
    }

    increase_app_volume() {
        local -r app_name=${1:?$(error 'Application name is required')}
        local step=${2:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_app_volume "$app_name" "$step" "+"
    }

    decrease_app_volume() {
        local -r app_name=${1:?$(error 'Application name is required')}
        local step=${2:-}
        if empty "$step"; then
            step=${DEFAULT_STEP:-5}
        fi
        set_app_volume "$app_name" "$step" "-"
    }

    toggle_app_mute() {
        local -r app_name=${1:?$(error 'Application name is required')}

        # Find the stream
        local stream_id
        stream_id=$(find_app_stream "$app_name")

        if empty "$stream_id"; then
            error_with_suggestion "Application not found: $app_name" \
                "Use 'volume app list' to see available applications." \
                "Application names are case-sensitive."
            return 1
        fi

        invalidate_cache
        wpctl set-mute "$stream_id" toggle
    }

    notify_app_volume() {
        local -r app_name=$1
        local -r stream_id=$2
        local -r vol=$(get_app_volume "$stream_id")
        local icon summary body=""

        if is_app_muted "$stream_id"; then
            printf -v summary "%s: muted" "$app_name"
            icon=$($USE_FULLCOLOR_ICONS && echo "${ICONS[0]}" || echo "${ICONS_SYMBOLIC[0]}")
        else
            printf -v summary "%s: %3s%%" "$app_name" "$vol"
            icon=$(get_volume_icon "$vol")

            if $SHOW_VOLUME_PROGRESS; then
                local -r progress=$(progress_bar "$vol")
                if has_capability body && [[ $PROGRESS_PLACEMENT == body ]]; then body="$progress"
                else summary="$summary $progress"; fi
            fi
        fi

        case "$NOTIFICATION_METHOD" in
            xosd    ) notify_volume_xosd "$vol" "$summary $body" ;;
            herbe   ) notify_volume_herbe "$summary $body" ;;
            volnoti ) notify_volume_volnoti "$vol" ;;
            kosd    ) notify_volume_kosd "$vol" ;;
            libnotify|dunst|notify-osd|*)
                # Check if it's a plugin
                if is_notification_plugin_available "$NOTIFICATION_METHOD"; then
                    call_notification_plugin "$NOTIFICATION_METHOD" "$vol" "$icon" "$summary" "$body" || notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                else
                    notify_volume_libnotify "$vol" "$icon" "$summary" "$body"
                fi
                ;;
        esac
    }

    show_app_notification() {
        local -r app_name=$1
        local stream_id

        $DISPLAY_NOTIFICATIONS || return

        # Find the stream
        stream_id=$(find_app_stream "$app_name")
        if empty "$stream_id"; then
            return 1
        fi

        if empty "$NOTIFICATION_METHOD"; then
            load_notify_server_info
            NOTIFICATION_METHOD=$NOTIFY_SERVER
        fi

        setup_notification_icons
        notify_app_volume "$app_name" "$stream_id"
    }

    get_active_app_name() {
        # Get the name of the most recently active application (stream with highest volume or most recent)
        # This is a simple heuristic - could be improved
        local app_name
        app_name=$(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Stream/Output/Audio") | .info.props."application.name" // .info.props."media.name" // .info.props."application.process.binary" // empty' 2>/dev/null | head -n1)

        not_empty "$app_name" && echo "$app_name"
    }

    get_balance() {
        # Get audio balance (left/right channel balance) from PipeWire
        # Returns balance as a value from -100 (left) to +100 (right), or 0 (centered)
        if empty "$NODE_ID"; then
            echo "0"
            return 0
        fi

        # Try to get channel volumes from pw-dump
        local left_vol right_vol
        left_vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "channelVolumes") | .value[0]? // empty' 2>/dev/null)
        right_vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "channelVolumes") | .value[1]? // empty' 2>/dev/null)

        # If we can't get channel volumes from pw-dump, default to centered
        if empty "$left_vol" || empty "$right_vol"; then
            echo "0"
            return 0
        fi

        # Calculate balance: positive = right, negative = left
        # Convert volumes to numeric values and calculate difference
        local left_num right_num balance
        left_num=$(printf "%.2f" "$left_vol" 2>/dev/null || echo "0")
        right_num=$(printf "%.2f" "$right_vol" 2>/dev/null || echo "0")

        # If volumes are equal, balance is 0
        if [[ "$left_num" == "$right_num" ]]; then
            echo "0"
            return 0
        fi

        # Calculate balance using awk for floating point arithmetic
        balance=$(awk -v left="$left_num" -v right="$right_num" 'BEGIN {
            diff = right - left
            # Normalize to -100..100 range (assuming volumes are 0.0-1.0)
            balance = diff * 100
            if (balance > 100) balance = 100
            if (balance < -100) balance = -100
            printf "%.0f", balance
        }' 2>/dev/null || echo "0")

        echo "$balance"
    }

    get_volume_color_code() {
        # Get ANSI color code for volume level
        # Returns terminal color escape sequence
        local -ir vol=${1:-$(get_volume)}
        if has_color; then
            if is_muted 2>/dev/null; then
                echo "$COLOR_RED"
            else
                volume_color "$vol"
            fi
        else
            echo ""
        fi
    }

    app() {
        local -r subcommand=${1:-}
        local -r app_name=${2:-}
        local -r value=${3:-}

        case "$subcommand" in
            list)
                list_apps
                ;;
            "")
                error "App subcommand required. Use: app list|app <name> <cmd>"
                echo "  ${COLOR_GREEN}app list${COLOR_RESET}              - list all applications with audio streams"
                echo "  ${COLOR_GREEN}app <name> up [value]${COLOR_RESET}   - increase application volume"
                echo "  ${COLOR_GREEN}app <name> down [value]${COLOR_RESET} - decrease application volume"
                echo "  ${COLOR_GREEN}app <name> set <value>${COLOR_RESET} - set application volume"
                echo "  ${COLOR_GREEN}app <name> mute${COLOR_RESET}        - toggle application mute"
                EXITCODE=$EX_USAGE
                return 1
                ;;
            *)
                # subcommand is app name, app_name is the volume command
                if empty "$app_name"; then
                    error "Command required. Use: app <name> <cmd>"
                    echo "Valid commands: up, down, set, mute"
                    echo "Use 'volume app list' to see available applications."
                    EXITCODE=$EX_USAGE
                    return 1
                fi

                case "$app_name" in
                    up|raise|increase)
                        if empty "$value"; then
                            increase_app_volume "$subcommand"
                        else
                            increase_app_volume "$subcommand" "$value"
                        fi
                        show_app_notification "$subcommand"
                        ;;
                    down|lower|decrease)
                        if empty "$value"; then
                            decrease_app_volume "$subcommand"
                        else
                            decrease_app_volume "$subcommand" "$value"
                        fi
                        show_app_notification "$subcommand"
                        ;;
                    set)
                        if empty "$value"; then
                            error "Volume value required. Use: app <name> set <value>"
                            EXITCODE=$EX_USAGE
                            return 1
                        fi
                        case "$value" in
                            +*) increase_app_volume "$subcommand" "${value:1}" ;;
                            -*) decrease_app_volume "$subcommand" "${value:1}" ;;
                            *) set_app_volume "$subcommand" "$value" ;;
                        esac
                        show_app_notification "$subcommand"
                        ;;
                    mute)
                        toggle_app_mute "$subcommand"
                        show_app_notification "$subcommand"
                        ;;
                    *)
                        error "Unknown app command: $app_name"
                        echo "Valid commands: up, down, set, mute"
                        EXITCODE=$EX_USAGE
                        return 1
                        ;;
                esac
                ;;
        esac
    }

    usage() {
        cat <<- EOF 1>&2
${COLOR_YELLOW}Usage:${COLOR_RESET} $0 [<options>] <command> [<args>]
Control volume and related notifications.

${COLOR_YELLOW}Commands:${COLOR_RESET}
  ${COLOR_GREEN}up [value]${COLOR_RESET}                  increase volume (uses default step if value omitted)
  ${COLOR_GREEN}down [value]${COLOR_RESET}                decrease volume (uses default step if value omitted)
  ${COLOR_GREEN}set <value>${COLOR_RESET}                 set volume
  ${COLOR_GREEN}wheel <delta>${COLOR_RESET}               mouse wheel volume control (accumulates small changes)
                              examples:
                                  wheel 2.0  - scroll up (positive delta)
                                  wheel -2.0 - scroll down (negative delta)
                              note: accumulates changes until reaching DEFAULT_STEP threshold
  ${COLOR_GREEN}mute${COLOR_RESET}                        toggle mute
  ${COLOR_GREEN}fade <from> <to> [duration_ms]${COLOR_RESET} fade volume smoothly
                              examples:
                                  fade 0 100       - fade from 0% to 100% (500ms)
                                  fade 0 100 2000  - fade from 0% to 100% over 2 seconds
  ${COLOR_GREEN}mic <cmd> [value]${COLOR_RESET}           control microphone
                              commands:
                                  up <value>    - increase microphone volume
                                  down <value>  - decrease microphone volume
                                  set <value>   - set microphone volume
                                  mute          - toggle microphone mute
  ${COLOR_GREEN}listen [options] [output_format]${COLOR_RESET} monitor volume changes
                              options:
                                  -a, --all          - monitor all sinks
                                  -I, --input        - monitor input sources
                                  --watch            - show real-time updates in terminal
                                  --volume-only      - only show volume change events
                                  --mute-only        - only show mute change events
                              examples:
                                  listen                    - monitor default sink
                                  listen -a                 - monitor all sinks
                                  listen -I                 - monitor all input sources
                                  listen --watch            - show terminal output
                                  listen -a --watch         - monitor all sinks with terminal output
                                  listen --volume-only      - only volume changes
                                  listen i3blocks           - output in i3blocks format
  ${COLOR_GREEN}list <type>${COLOR_RESET}                 list sinks, sources, or ports
                              types:
                                  sinks   - list all audio output sinks
                                  sources - list all audio input sources
                                  ports   - list ports for current sink (BETA: shows availability status)
  ${COLOR_GREEN}switch [sink]${COLOR_RESET}               switch to next sink or specified sink
  ${COLOR_GREEN}next${COLOR_RESET}                        switch to next sink
  ${COLOR_GREEN}prev${COLOR_RESET}                        switch to previous sink
  ${COLOR_GREEN}port <cmd> [port]${COLOR_RESET}           control audio ports (BETA/EXPERIMENTAL)
                              commands:
                                  list        - list available ports with availability status
                                  set <port>  - set active port
                              note: Port features are experimental and may not work on all devices
  ${COLOR_GREEN}profile <cmd> [name]${COLOR_RESET}       manage volume profiles
                              commands:
                                  save <name>   - save current settings as profile
                                  load <name>   - load a saved profile
                                  list          - list all saved profiles
                                  delete <name> - delete a profile
                              quick access:
                                  profile <name> - load profile (shortcut for load)
  ${COLOR_GREEN}boost <amount> [timeout]${COLOR_RESET}   temporarily boost volume
                              examples:
                                  boost 20       - boost by 20% for 30s (default)
                                  boost 20 60    - boost by 20% for 60s
                                  boost off      - cancel active boost
  ${COLOR_GREEN}sync${COLOR_RESET}                        sync volume across all active sinks
  ${COLOR_GREEN}app <cmd> [args]${COLOR_RESET}            control per-application volume
                              commands:
                                  list                    - list all applications with audio streams
                                  <name> up [value]       - increase application volume
                                  <name> down [value]     - decrease application volume
                                  <name> set <value>      - set application volume
                                  <name> mute             - toggle application mute
                              examples:
                                  app list                - show all active applications
                                  app firefox up 5        - increase Firefox volume by 5%
                                  app mpv mute            - mute/unmute mpv
  ${COLOR_GREEN}output <format>${COLOR_RESET}             display volume in a custom format
                              special formats:
                                  json                        - JSON output with all volume information
                              format placeholders:
                                  %v = volume
                                  %s = sink name
                                  %p = volume progress bar
                                  %i = volume icon/emoji
                                  %P = active port description (BETA: includes availability status when available)
                                  %m = microphone volume
                                  %a = active application name
                                  %b = balance (L=left, R=right, C=center)
                                  %c = color codes (ANSI terminal colors)
                                  %n = node display name/alias
                                  %d = node id

                              conditional formatting:
                                  %v{>50:high:low}  - if volume > 50, show "high", else "low"
                                  %v{<30:quiet:normal} - if volume < 30, show "quiet", else "normal"
                                  %m{>80:loud:normal} - conditional on microphone volume
                                  %b{!=0:unbalanced:centered} - conditional on balance

                                  examples:
                                      output json              - JSON format for programmatic use
                                      "Volume is %v" = Volume is 50%
                                      "%i %v %p \n"  = ï©¿ 50% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
                                      "%c%v${COLOR_RESET}" = colored volume (if terminal supports)
                                      "%v{>50:high:low}" = "high" if volume > 50%, else "low"
  ${COLOR_GREEN}outputs${COLOR_RESET}                     show supported output formats
  ${COLOR_GREEN}notifications${COLOR_RESET}               list notification methods
  ${COLOR_GREEN}config <cmd>${COLOR_RESET}                manage configuration
                              commands:
                                  show        - show current configuration
                                  validate    - validate config file syntax
                                  docs        - show all configurable variables
  ${COLOR_GREEN}help${COLOR_RESET}                        show help

${COLOR_YELLOW}Options:${COLOR_RESET}
  ${COLOR_GREEN}-n${COLOR_RESET}                          enable notifications
  ${COLOR_GREEN}-q${COLOR_RESET}, ${COLOR_GREEN}--no-notify${COLOR_RESET}          disable notifications (quiet mode)
  ${COLOR_GREEN}-C${COLOR_RESET}                          play event sounds using libcanberra
  ${COLOR_GREEN}-P${COLOR_RESET}                          play sound for volume changes
  ${COLOR_GREEN}-j <muted,high,low,medium>${COLOR_RESET}  custom volume emojis
  ${COLOR_GREEN}-s <sink>${COLOR_RESET}                   specify sink (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SINK@${COLOR_RESET})
  ${COLOR_GREEN}-I <source>${COLOR_RESET}                 specify input source (${COLOR_MAGENTA}default: @DEFAULT_AUDIO_SOURCE@${COLOR_RESET})
  ${COLOR_GREEN}-a${COLOR_RESET}                          operate on all sinks (${COLOR_MAGENTA}for up/down/set/mute${COLOR_RESET})
  ${COLOR_GREEN}-t <process_name>${COLOR_RESET}           status bar process name (${COLOR_MAGENTA}requires -u${COLOR_RESET})
  ${COLOR_GREEN}-A <node.nick:alias>${COLOR_RESET}        alias a node nick (e.g., -A "ALC287 Analog:Speakers")
  ${COLOR_GREEN}-u <signal>${COLOR_RESET}                 signal to update status bar (${COLOR_MAGENTA}requires -t${COLOR_RESET})
  ${COLOR_GREEN}-D <value>${COLOR_RESET}                  set default step size (${COLOR_MAGENTA}default: 5${COLOR_RESET})
  ${COLOR_GREEN}-f <duration_ms>${COLOR_RESET}            fade duration in milliseconds (${COLOR_MAGENTA}for set/up/down/mute${COLOR_RESET})
  ${COLOR_GREEN}-x <value>${COLOR_RESET}                  set maximum volume
  ${COLOR_GREEN}-v${COLOR_RESET}                          verbose mode (detailed error information)
  ${COLOR_GREEN}--exit-code${COLOR_RESET}                 show detailed exit code information
  ${COLOR_GREEN}-h${COLOR_RESET}                          show help

${COLOR_YELLOW}Notification Options:${COLOR_RESET}
  ${COLOR_GREEN}-N <method>${COLOR_RESET}                 notification method (${COLOR_MAGENTA}default: libnotify${COLOR_RESET})
  ${COLOR_GREEN}-p${COLOR_RESET}                          enable progress bar in notifications
  ${COLOR_GREEN}-L <placement>${COLOR_RESET}              progress bar placement (${COLOR_MAGENTA}default: summary${COLOR_RESET}; ${COLOR_MAGENTA}requires -p${COLOR_RESET})
                              placements:
                                  body
                                  summary
  ${COLOR_GREEN}-e <ms>${COLOR_RESET}                     notification expiration time
  ${COLOR_GREEN}-l${COLOR_RESET}                          use full-color icons
  ${COLOR_GREEN}-S <suffix>${COLOR_RESET}                 add suffix to symbolic icon names
  ${COLOR_GREEN}-y${COLOR_RESET}                          use dunstify (${COLOR_MAGENTA}default: notify-send${COLOR_RESET})

${COLOR_YELLOW}Notification Features:${COLOR_RESET}
  Notifications show sink name when multiple sinks are available
  Port information is displayed in notifications when available (BETA/EXPERIMENTAL)
  Port change detection shows when active port changes (BETA/EXPERIMENTAL)
  Auto-suggestions for newly available ports (BETA/EXPERIMENTAL)
  Sink and port changes trigger enhanced notifications
  Set ${COLOR_CYAN}NOTIFICATION_GROUP=true${COLOR_RESET} in config to group volume change notifications

${COLOR_YELLOW}Environment Variables:${COLOR_RESET}
  ${COLOR_CYAN}XOSD_PATH${COLOR_RESET}                   path to osd_cat
  ${COLOR_CYAN}HERBE_PATH${COLOR_RESET}                  path to herbe
  ${COLOR_CYAN}VOLNOTI_PATH${COLOR_RESET}                path to volnoti-show
  ${COLOR_CYAN}CANBERRA_PATH${COLOR_RESET}               path to canberra-gtk-play
  ${COLOR_CYAN}NOTIFY_PATH${COLOR_RESET}                 path to command that sends notifications
  ${COLOR_CYAN}NO_NOTIFY_COLOR${COLOR_RESET}             flag to disable colors in notifications
  ${COLOR_CYAN}USE_NOTIFY_SEND_PY${COLOR_RESET}          flag to use notify-send.py instead of notify-send
  ${COLOR_CYAN}NOTIFICATION_GROUP${COLOR_RESET}          set to "true" to group volume change notifications (dunst only)

${COLOR_YELLOW}Exit Codes:${COLOR_RESET}
  ${COLOR_GREEN}0${COLOR_RESET}   Success - command executed successfully
  ${COLOR_GREEN}33${COLOR_RESET}  Urgent - volume exceeds maximum limit (MAX_VOL)
  ${COLOR_GREEN}64${COLOR_RESET}  Usage error - invalid command, option, or argument
  ${COLOR_GREEN}69${COLOR_RESET}  Unavailable - required tool or feature not available

  Use ${COLOR_GREEN}--exit-code${COLOR_RESET} to display detailed exit code information.
EOF
        exit "$EX_USAGE"
    }

    show_exit_codes() {
        cat <<- EOF
${COLOR_YELLOW}Exit Codes:${COLOR_RESET}

${COLOR_GREEN}0${COLOR_RESET}   ${COLOR_CYAN}EX_OK${COLOR_RESET}
        Success - command executed successfully
        All operations completed without errors

${COLOR_GREEN}33${COLOR_RESET}  ${COLOR_CYAN}EX_URGENT${COLOR_RESET}
        Urgent - volume exceeds maximum limit
        Returned when volume is set above MAX_VOL threshold
        Indicates potential audio distortion or hardware limits

${COLOR_GREEN}64${COLOR_RESET}  ${COLOR_CYAN}EX_USAGE${COLOR_RESET}
        Usage error - invalid command, option, or argument
        Common causes:
          - Invalid command name
          - Missing required arguments
          - Invalid option values
          - Incorrect command syntax
        Check command usage with: ${COLOR_GREEN}$0 help${COLOR_RESET}

${COLOR_GREEN}69${COLOR_RESET}  ${COLOR_CYAN}EX_UNAVAILABLE${COLOR_RESET}
        Unavailable - required tool or feature not available
        Common causes:
          - Required notification tool not found (notify-send, dunstify, etc.)
          - Audio system not available (PipeWire/PulseAudio)
          - Required external command missing
        Check verbose mode with: ${COLOR_GREEN}$0 -v <command>${COLOR_RESET}

${COLOR_YELLOW}Usage in Scripts:${COLOR_RESET}
  Check exit codes in your scripts:
    if ! $0 up 5; then
        case \$? in
            64) echo "Usage error" ;;
            69) echo "Tool unavailable" ;;
            33) echo "Volume limit exceeded" ;;
        esac
    fi

EOF
    }
}

get_volume() { wpctl get-volume "$NODE_ID" | awk '{print $2 * 100}'; }
is_muted() { wpctl get-volume "$NODE_ID" | grep -q '\[MUTED\]'; }

get_mic_volume() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | awk '{print $2 * 100}'
}

is_mic_muted() {
    if empty "$SOURCE_ID"; then
        init_source
    fi
    wpctl get-volume "$SOURCE_ID" 2>/dev/null | grep -q '\[MUTED\]'
}

get_volume_icon() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if $USE_FULLCOLOR_ICONS; then
        if (( vol >= 70 )); then icon=${ICONS[1]}
        elif (( vol >= 40 )); then icon=${ICONS[3]}
        elif (( vol > 0 )); then icon=${ICONS[2]}
        else icon=${ICONS[2]}
        fi
    else
        # Get overamplified icon if available, otherwise default to high volume icon
        if (( vol > 100 )); then icon=${ICONS_SYMBOLIC[4]:-${ICONS_SYMBOLIC[1]}}
        elif (( vol >= 70 )); then icon=${ICONS_SYMBOLIC[1]}
        elif (( vol >= 40 )); then icon=${ICONS_SYMBOLIC[3]}
        elif (( vol > 0 )); then icon=${ICONS_SYMBOLIC[2]}
        else icon=${ICONS_SYMBOLIC[2]}
        fi
    fi

    echo "$icon"
}

get_volume_emoji() {
    local -r vol=${1:?$(error 'Volume is required')}
    local icon

    if is_muted; then icon=${ICONS_EMOJI[0]}
    else
        if (( vol >= 70 )); then icon=${ICONS_EMOJI[1]}
        elif (( vol >= 40 )); then icon=${ICONS_EMOJI[3]}
        elif (( vol > 0 )); then icon=${ICONS_EMOJI[2]}
        else icon=${ICONS_EMOJI[2]}
        fi
    fi
    echo "$icon"
}

update_statusline() {
    local signal=${1:?$(error 'Signal is required')}
    local proc=${2:?$(error 'Process name is required')}
    pkill "-$signal" "$proc"
}

progress_bar() {
    local percent=${1:?$(error 'Percentage is required')}
    local -i max_percent=${2:-100}
    local -i bar_length=${3:-20}

    # Clamp the percentage to be within 0 and max_percent
    (( percent = percent < 0 ? 0 : (percent > max_percent ? max_percent : percent) ))

    local filled_blocks=$(( percent * bar_length / max_percent ))
    local empty_blocks=$(( bar_length - filled_blocks ))
    local bar; printf -v bar "%${filled_blocks}s" ''
    local empty; printf -v empty "%${empty_blocks}s" ''

    echo "${bar// /â–ˆ}${empty// /â–‘}"
}

apply_symbolic_icon_suffix() { for i in "${!ICONS_SYMBOLIC[@]}"; do ICONS_SYMBOLIC[i]="${ICONS_SYMBOLIC[i]}${SYMBOLIC_ICON_SUFFIX}"; done; }

volume_color() {
    local -ir vol=${1:?$(error 'A volume is required')}
    local effective_max_vol
    effective_max_vol=$(get_effective_max_vol)
    if (( vol >= MIN_VOL && vol < DEFAULT_VOL )); then echo "$COLOR_MIN_TO_DEFAULT";
    elif (( vol == 100 )); then echo "$COLOR_FULL";
    elif (( vol > 100 && vol <= effective_max_vol )); then echo "$COLOR_FULL_TO_MAX";
    else echo "$COLOR_OTHER";
    fi
}

# Returns
#   0 when both signal and statusline are set
#   1 when one of signal or statusline are set but not both
update_statusbar() {
    if not_empty "$SIGNAL" && empty "$STATUSLINE"; then return 1; fi
    if not_empty "$SIGNAL"; then update_statusline "$SIGNAL" "$STATUSLINE";
    elif not_empty "$STATUSLINE"; then return 1; fi
    return 0
}

init_audio() {
    # Check if PipeWire is running
    if ! check_pipewire_running; then
        error_with_suggestion "PipeWire is not running or not accessible." \
            "Check if PipeWire is running: systemctl --user status pipewire pipewire-pulse" \
            "Start PipeWire if needed: systemctl --user start pipewire pipewire-pulse"
        if [[ "${VERBOSE:-false}" == "true" ]]; then
            local diag
            diag=$(get_pipewire_diagnostics)
            if not_empty "$diag"; then
                echo "${COLOR_CYAN}[verbose]${COLOR_RESET} $diag" >&2
            fi
        fi
        exit "$EX_UNAVAILABLE"
    fi

    # Check if wpctl is available
    if ! check_wpctl_available; then
        error_with_suggestion "wpctl command not found." \
            "Install WirePlumber package for your distribution."
        exit "$EX_UNAVAILABLE"
    fi

    if empty "$NODE_NAME"; then
        local default_sink_output
        if ! default_sink_output=$(wpctl inspect @DEFAULT_AUDIO_SINK@ 2>&1); then
            error_with_suggestion "Cannot access default audio sink." \
                "PipeWire may not be fully initialized. Try: systemctl --user restart pipewire pipewire-pulse" \
                "Use 'volume list sinks' to see available sinks."
            if [[ "${VERBOSE:-false}" == "true" ]]; then
                echo "${COLOR_CYAN}[verbose]${COLOR_RESET} wpctl output: $default_sink_output" >&2
            fi
            exit "$EX_UNAVAILABLE"
        fi
        NODE_NAME=$(echo "$default_sink_output" | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi

    NODE_ID=$(get_node_id)

    if empty "$NODE_ID"; then
        error_with_suggestion "Sink not found: $NODE_NAME" \
            "Use 'volume list sinks' to see available sinks." \
            "Specify a different sink with: volume -s <sink_name> <command>"
        if [[ "${VERBOSE:-false}" == "true" ]]; then
            echo "${COLOR_CYAN}[verbose]${COLOR_RESET} Attempted to find sink: $NODE_NAME" >&2
            local available_sinks
            available_sinks=$(pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."media.class" == "Audio/Sink") | .info.props."node.name"' 2>/dev/null | head -5)
            if not_empty "$available_sinks"; then
                echo "${COLOR_CYAN}[verbose]${COLOR_RESET} Available sinks:" >&2
                echo "$available_sinks" | while read -r sink; do
                    echo "${COLOR_CYAN}[verbose]${COLOR_RESET}   - $sink" >&2
                done
            fi
        fi
        exit "$EX_UNAVAILABLE"
    fi

    NODE_NICK=$(get_node_nick)
    DEFAULT_VOL=$(get_default_volume)
    MIN_VOL=$(get_min_volume)
    MAX_VOL=$(get_max_volume)
}

init_source() {
    if empty "$SOURCE_NAME"; then
        SOURCE_NAME=$(wpctl inspect @DEFAULT_AUDIO_SOURCE@ 2>/dev/null | awk '/[ \*]+node\.name/{gsub(/"/, "", $4); print $4}')
    fi
    SOURCE_ID=$(get_source_id)
    # shellcheck disable=SC2034  # SOURCE_NICK may be used in future features
    SOURCE_NICK=$(get_source_nick)
}

get_node_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$NODE_NAME"'") | .id'; }
get_node_nick() { pw_dump | jq -r '.[] | select(.id == '"$NODE_ID"') | .info.props."node.nick"'; }

get_source_id() { pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$SOURCE_NAME"'") | .id'; }
get_source_nick() { pw_dump | jq -r '.[] | select(.id == '"$SOURCE_ID"') | .info.props."node.nick"'; }

get_node_display_name() {
    if isset NODE_ALIASES["$NODE_ID"]; then echo "${NODE_ALIASES[$NODE_ID]}"
    elif isset NODE_ALIASES["$NODE_NAME"]; then echo "${NODE_ALIASES[$NODE_NAME]}"
    elif isset NODE_ALIASES["$NODE_NICK"]; then echo "${NODE_ALIASES[$NODE_NICK]}"
    else get_node_nick
    fi
}

# get_node_name_by_id() {
#     local -r id=${1:?$(error 'Node ID is required')}
#     wpctl inspect "$id" | jq -r '.info.props."node.name"'
# }

# dump_node() {
#     local -r name=${1:?$(error 'Node name is required')}
#     pw_dump | jq -r '.[] | select(.type == "PipeWire:Interface:Node" and .info.props."node.name" == "'"$name"'")'
# }

pw_dump() {
    if [[ $COMMAND == "listen" ]] || empty "$PW_DUMP"; then PW_DUMP=$(pw-dump); fi
    echo "$PW_DUMP"
}

invalidate_cache() { PW_DUMP=""; }

# Listens for PipeWire events
#
# Arguments:
#   Options and output format (optional)
#   -a, --all          Monitor all sinks
#   -I, --input        Monitor input sources
#   --watch            Show real-time updates in terminal
#   --volume-only      Only show volume change events
#   --mute-only        Only show mute change events
#   Output format      (optional) An output mode. When set, outputs volume in the output mode format.
listen() {
    local watch_mode=false
    local listen_all_sinks=false
    local input_sources=false
    local volume_only=false
    local mute_only=false
    local output=""
    local node_ids=()
    local node_type="sink"

    # Check if global -a flag was set (for operating on all sinks)
    if [[ "${ALL_SINKS:-false}" == "true" ]]; then
        listen_all_sinks=true
    fi

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--all)
                listen_all_sinks=true
                shift
                ;;
            -I|--input)
                input_sources=true
                node_type="source"
                shift
                ;;
            --watch)
                watch_mode=true
                shift
                ;;
            --volume-only)
                volume_only=true
                shift
                ;;
            --mute-only)
                mute_only=true
                shift
                ;;
            -*)
                # Unknown option, might be output format or other option
                # If it doesn't start with --, treat as output format
                if [[ "$1" != --* ]]; then
                    output="$*"
                    break
                else
                    error "Unknown option: $1"
                    EXITCODE=$EX_USAGE
                    return 1
                fi
                ;;
            *)
                # Treat as output format
                output="$*"
                break
                ;;
        esac
    done

    # Build list of node IDs to monitor
    if [[ "$input_sources" == true ]]; then
        # Monitor input sources
        if [[ "$listen_all_sinks" == true ]] || empty "$SOURCE_ID"; then
            # Get all sources
            local sources
            readarray -t sources < <(get_all_sources)
            if [[ ${#sources[@]} -eq 0 ]]; then
                error "No audio sources found."
                EXITCODE=$EX_UNAVAILABLE
                return 1
            fi
            node_ids=("${sources[@]}")
        else
            # Monitor specific source
            node_ids=("$SOURCE_ID")
        fi
    else
        # Monitor sinks
        if [[ "$listen_all_sinks" == true ]] || empty "$NODE_ID"; then
            # Get all sinks
            local sinks
            readarray -t sinks < <(get_all_sinks)
            if [[ ${#sinks[@]} -eq 0 ]]; then
                error "No audio sinks found."
                EXITCODE=$EX_UNAVAILABLE
                return 1
            fi
            node_ids=("${sinks[@]}")
        else
            # Monitor specific sink
            node_ids=("$NODE_ID")
        fi
    fi

    # Build grep pattern for filtering node IDs
    local grep_pattern=""
    for node_id in "${node_ids[@]}"; do
        if empty "$grep_pattern"; then
            grep_pattern="object.id = $node_id"
        else
            grep_pattern="$grep_pattern|object.id = $node_id"
        fi
    done

    # Output initial volume so status bars have something to display
    if not_empty "$output"; then
        output_volume "$output"
    fi

    # Show watch mode header
    if [[ "$watch_mode" == true ]]; then
        echo "${COLOR_YELLOW}Monitoring ${node_type}s:${COLOR_RESET}"
        for node_id in "${node_ids[@]}"; do
            local display_name
            if [[ "$input_sources" == true ]]; then
                display_name=$(pw_dump | jq -r --argjson id "$node_id" '.[] | select(.id == $id) | .info.props."node.nick" // .info.props."node.name" // "Unknown"' 2>/dev/null)
            else
                # Temporarily set NODE_ID to get display name
                local old_node_id="$NODE_ID"
                NODE_ID="$node_id"
                display_name=$(get_node_display_name)
                NODE_ID="$old_node_id"
            fi
            echo "  ${COLOR_CYAN}$node_id${COLOR_RESET}: ${COLOR_GREEN}$display_name${COLOR_RESET}"
        done
        echo ""
        if [[ "$volume_only" == true ]]; then
            echo "${COLOR_YELLOW}Filter: Volume changes only${COLOR_RESET}"
        elif [[ "$mute_only" == true ]]; then
            echo "${COLOR_YELLOW}Filter: Mute changes only${COLOR_RESET}"
        fi
        echo ""
    fi

    # Helper function to process each event
    process_listen_event() {
        local -r event_node_id="$1"
        local -r event_type="$2"  # "volume" or "mute" or "change"

        # Apply filters
        if [[ "$volume_only" == true ]] && [[ "$event_type" != "volume" ]]; then
            return 0
        fi
        if [[ "$mute_only" == true ]] && [[ "$event_type" != "mute" ]]; then
            return 0
        fi

        # Update NODE_ID or SOURCE_ID for the event
        if [[ "$input_sources" == true ]]; then
            SOURCE_ID="$event_node_id"
            # Update SOURCE_NAME
            SOURCE_NAME=$(pw_dump | jq -r --argjson id "$event_node_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
        else
            NODE_ID="$event_node_id"
            # Update NODE_NAME and NODE_NICK
            NODE_NAME=$(pw_dump | jq -r --argjson id "$event_node_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
            NODE_NICK=$(pw_dump | jq -r --argjson id "$event_node_id" '.[] | select(.id == $id) | .info.props."node.nick" // "N/A"' 2>/dev/null)
        fi

        # Show watch mode output
        if [[ "$watch_mode" == true ]]; then
            local display_name
            local vol
            local muted

            if [[ "$input_sources" == true ]]; then
                display_name=$(pw_dump | jq -r --argjson id "$event_node_id" '.[] | select(.id == $id) | .info.props."node.nick" // .info.props."node.name" // "Unknown"' 2>/dev/null)
                vol=$(get_mic_volume 2>/dev/null || echo "N/A")
                muted=$(is_mic_muted 2>/dev/null && echo "MUTED" || echo "")
            else
                display_name=$(get_node_display_name)
                vol=$(get_volume 2>/dev/null || echo "N/A")
                muted=$(is_muted 2>/dev/null && echo "MUTED" || echo "")
            fi

            local timestamp
            timestamp=$(date '+%H:%M:%S')
            printf "[%s] %s %s: " "$timestamp" "${COLOR_CYAN}$event_node_id${COLOR_RESET}" "${COLOR_GREEN}$display_name${COLOR_RESET}"
            if [[ -n "$muted" ]]; then
                printf "%s" "${COLOR_RED}[MUTED]${COLOR_RESET}"
            else
                printf "${COLOR_YELLOW}%3s%%${COLOR_RESET}" "$vol"
            fi
            printf " (%s%s%s)\n" "${COLOR_MAGENTA}" "$event_type" "${COLOR_RESET}"
        fi

        # Show notifications and update status bar (only for sinks, not sources in watch mode)
        if [[ "$input_sources" != true ]]; then
            show_volume_notification
            update_statusbar
            play_volume_changed
        elif [[ "$watch_mode" != true ]]; then
            # For sources, show mic notification if not in watch mode
            show_mic_notification
        fi

        # Output volume in specified format
        if not_empty "$output"; then
            if [[ "$input_sources" == true ]]; then
                # For sources, we'd need a mic output format - for now skip
                :
            else
                output_volume "$output"
            fi
        fi
    }

    # Store previous states for each node to detect changes
    declare -A prev_volumes
    declare -A prev_muted

    # Initialize previous states
    for node_id in "${node_ids[@]}"; do
        if [[ "$input_sources" == true ]]; then
            local old_source_id="$SOURCE_ID"
            SOURCE_ID="$node_id"
            prev_volumes["$node_id"]=$(get_mic_volume 2>/dev/null || echo "0")
            prev_muted["$node_id"]=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
            SOURCE_ID="$old_source_id"
        else
            local old_node_id="$NODE_ID"
            NODE_ID="$node_id"
            prev_volumes["$node_id"]=$(get_volume 2>/dev/null || echo "0")
            prev_muted["$node_id"]=$(is_muted 2>/dev/null && echo "true" || echo "false")
            NODE_ID="$old_node_id"
        fi
    done

    # Build node ID filter for pw-mon
    local node_filter=""
    for node_id in "${node_ids[@]}"; do
        if empty "$node_filter"; then
            node_filter="$node_id"
        else
            node_filter="$node_filter|$node_id"
        fi
    done

    # Use efficient polling to detect volume/mute changes
    # Poll every 100ms which is responsive enough for volume changes
    while true; do
        for node_id in "${node_ids[@]}"; do
            local current_vol current_muted
            local is_volume_event=false
            local is_mute_event=false

            # Get current state
            if [[ "$input_sources" == true ]]; then
                local old_source_id="$SOURCE_ID"
                SOURCE_ID="$node_id"
                current_vol=$(get_mic_volume 2>/dev/null || echo "0")
                current_muted=$(is_mic_muted 2>/dev/null && echo "true" || echo "false")
                SOURCE_ID="$old_source_id"
            else
                local old_node_id="$NODE_ID"
                NODE_ID="$node_id"
                current_vol=$(get_volume 2>/dev/null || echo "0")
                current_muted=$(is_muted 2>/dev/null && echo "true" || echo "false")
                NODE_ID="$old_node_id"
            fi

            # Check for volume change
            if [[ "${prev_volumes[$node_id]}" != "$current_vol" ]]; then
                is_volume_event=true
            fi

            # Check for mute change
            if [[ "${prev_muted[$node_id]}" != "$current_muted" ]]; then
                is_mute_event=true
            fi

            # Process event if there's a change
            if [[ "$is_volume_event" == true ]] || [[ "$is_mute_event" == true ]]; then
                local event_type="change"
                if [[ "$is_volume_event" == true ]] && [[ "$is_mute_event" == true ]]; then
                    event_type="volume+mute"
                elif [[ "$is_volume_event" == true ]]; then
                    event_type="volume"
                elif [[ "$is_mute_event" == true ]]; then
                    event_type="mute"
                fi

                # Process the event
                process_listen_event "$node_id" "$event_type"

                # Update previous states
                prev_volumes["$node_id"]="$current_vol"
                prev_muted["$node_id"]="$current_muted"
            fi
        done

        # Sleep for 100ms before next poll
        sleep 0.1
    done
}

pw_play() {
    command_exists pw-play || { error "pw-play is not installed or not in \$PATH"; return 1; }
    pw-play --target "$NODE_ID" "$1" &
}

get_volume_info() {
    local -r type=${1:?$(error 'Volume type (default/min/max) is required')}
    local vol
    vol=$(pw_dump | jq -r --argjson node_id "$NODE_ID" '.[] | select(.id == $node_id) | .info.params.PropInfo[]? | select(.id == "volume") | .type.'"$type"'' 2>/dev/null)

    empty "$vol" && { echo "Error: $type volume information not found for NODE_ID=$NODE_ID" >&2; return 1; }
    echo "$vol" | awk '{print $1 * 100}'
}

get_default_volume() { get_volume_info "default"; }
get_min_volume() { get_volume_info "min"; }
get_max_volume() { get_volume_info "max"; }

# Get effective MAX_VOL for a specific sink (per-sink or global)
# If sink_id is provided, uses that sink; otherwise uses current sink
get_effective_max_vol() {
    local sink_id=${1:-$NODE_ID}
    local sink_name sink_nick

    if empty "$sink_id"; then
        echo "${MAX_VOL:-100}"
        return 0
    fi

    # Get sink name and nick for this sink
    sink_name=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.name"' 2>/dev/null)
    sink_nick=$(pw_dump | jq -r --argjson id "$sink_id" '.[] | select(.id == $id) | .info.props."node.nick" // ""' 2>/dev/null)

    # Check by ID first
    if isset "SINK_MAX_VOL[$sink_id]"; then
        echo "${SINK_MAX_VOL[$sink_id]}"
        return 0
    fi

    # Check by name
    if not_empty "$sink_name" && isset "SINK_MAX_VOL[$sink_name]"; then
        echo "${SINK_MAX_VOL[$sink_name]}"
        return 0
    fi

    # Check by nick
    if not_empty "$sink_nick" && isset "SINK_MAX_VOL[$sink_nick]"; then
        echo "${SINK_MAX_VOL[$sink_nick]}"
        return 0
    fi

    # Fall back to global value
    echo "${MAX_VOL:-100}"
}

# Get effective DEFAULT_STEP for current sink (per-sink or global)
get_effective_default_step() {
    if empty "$NODE_ID" || empty "$NODE_NAME"; then
        echo "${DEFAULT_STEP:-5}"
        return 0
    fi

    # Check by ID first
    if isset "SINK_DEFAULT_STEP[$NODE_ID]"; then
        echo "${SINK_DEFAULT_STEP[$NODE_ID]}"
        return 0
    fi

    # Check by name
    if isset "SINK_DEFAULT_STEP[$NODE_NAME]"; then
        echo "${SINK_DEFAULT_STEP[$NODE_NAME]}"
        return 0
    fi

    # Check by nick
    if not_empty "$NODE_NICK" && isset "SINK_DEFAULT_STEP[$NODE_NICK]"; then
        echo "${SINK_DEFAULT_STEP[$NODE_NICK]}"
        return 0
    fi

    # Fall back to global value
    echo "${DEFAULT_STEP:-5}"
}

# Get effective DISPLAY_NOTIFICATIONS for current sink (per-sink or global)
# shellcheck disable=SC2317  # Function is used indirectly via config
get_effective_display_notifications() {
    if empty "$NODE_ID" || empty "$NODE_NAME"; then
        echo "${DISPLAY_NOTIFICATIONS:-false}"
        return 0
    fi

    local value=""

    # Check by ID first
    if isset "SINK_DISPLAY_NOTIFICATIONS[$NODE_ID]"; then
        value="${SINK_DISPLAY_NOTIFICATIONS[$NODE_ID]}"
    # Check by name
    elif isset "SINK_DISPLAY_NOTIFICATIONS[$NODE_NAME]"; then
        value="${SINK_DISPLAY_NOTIFICATIONS[$NODE_NAME]}"
    # Check by nick
    elif not_empty "$NODE_NICK" && isset "SINK_DISPLAY_NOTIFICATIONS[$NODE_NICK]"; then
        value="${SINK_DISPLAY_NOTIFICATIONS[$NODE_NICK]}"
    # Fall back to global value
    else
        value="${DISPLAY_NOTIFICATIONS:-false}"
    fi

    # Convert to boolean string if needed
    if [[ "$value" == "true" ]] || [[ "$value" == "1" ]]; then
        echo "true"
    else
        echo "false"
    fi
}

init_color() {
    has_color && {
        COLOR_RESET=$'\033[0m'
        COLOR_RED=$'\033[0;31m'
        COLOR_GREEN=$'\033[0;32m'
        COLOR_YELLOW=$'\033[0;33m'
        COLOR_MAGENTA=$'\033[0;35m'
        COLOR_CYAN=$'\033[0;36m'
    }
}

load_config() {
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    local config_dir
    config_dir=$(dirname "$config")

    if [[ ! -f "$config" ]]; then
        # Set defaults if no config file
        : "${NOTIFICATION_METHOD:=libnotify}"
        return 0
    fi

    # Process config file line by line to handle includes
    local processed_includes=()
    process_config_file() {
        local file_to_process=$1
        local file_dir
        file_dir=$(dirname "$file_to_process")

        # Prevent infinite loops from circular includes
        local file_abs
        file_abs=$(readlink -f "$file_to_process" 2>/dev/null || echo "$file_to_process")
        if [[ " ${processed_includes[*]} " =~ ${file_abs} ]]; then
            error "Circular include detected: $file_to_process"
            return 1
        fi
        processed_includes+=("$file_abs")

        while IFS= read -r line || [[ -n "$line" ]]; do
            local trimmed_line
            trimmed_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # Skip empty lines and comments
            [[ -z "$trimmed_line" ]] && continue
            [[ "$trimmed_line" =~ ^# ]] && continue

            # Check for include directive
            if [[ "$trimmed_line" =~ ^source[[:space:]]+ ]] || [[ "$trimmed_line" =~ ^\.[[:space:]]+ ]]; then
                local include_file
                include_file=$(echo "$trimmed_line" | sed -E 's/^(source|\.)[[:space:]]+["'\'']?([^"'\'']+)["'\'']?.*/\2/')

                # Try relative to current file's directory first, then config directory
                local resolved_include=""
                if [[ -f "$file_dir/$include_file" ]]; then
                    resolved_include="$file_dir/$include_file"
                elif [[ -f "$config_dir/$include_file" ]]; then
                    resolved_include="$config_dir/$include_file"
                elif [[ -f "$include_file" ]]; then
                    resolved_include="$include_file"
                fi

                if [[ -n "$resolved_include" ]]; then
                    process_config_file "$resolved_include" || return 1
                else
                    error "Include file not found: $include_file"
                    return 1
                fi
            else
                # Regular config line - evaluate it
                eval "$line" 2>/dev/null || {
                    error "Error processing config line: $line"
                    return 1
                }
            fi
        done < "$file_to_process"
    }

    # Process main config file
    process_config_file "$config" || {
        error "Failed to load config file: $config"
        return 1
    }

    # Set defaults if not defined in config
    : "${NOTIFICATION_METHOD:=libnotify}"
}

save_config_value() {
    local -r key=$1
    local -r value=$2
    local -r config=${XDG_CONFIG_HOME:-$HOME/.config}/i3-volume/config
    local config_dir
    config_dir=$(dirname "$config")

    # Create config directory if it doesn't exist
    mkdir -p "$config_dir" || {
        error "Failed to create config directory: $config_dir"
        return 1
    }

    # If config file exists, update or add the key
    if [[ -f $config ]]; then
        # Check if key already exists
        if grep -q "^[[:space:]]*${key}=" "$config" 2>/dev/null; then
            # Update existing key (handle both quoted and unquoted values)
            if [[ "$value" =~ ^[0-9]+$ ]]; then
                # Numeric value - no quotes needed
                sed -i "s|^[[:space:]]*${key}=.*|${key}=${value}|" "$config"
            else
                # String value - add quotes if not already quoted
                sed -i "s|^[[:space:]]*${key}=.*|${key}=\"${value}\"|" "$config"
            fi
        else
            # Add new key at the end
            if [[ "$value" =~ ^[0-9]+$ ]]; then
                echo "${key}=${value}" >> "$config"
            else
                echo "${key}=\"${value}\"" >> "$config"
            fi
        fi
    else
        # Create new config file
        if [[ "$value" =~ ^[0-9]+$ ]]; then
            echo "${key}=${value}" > "$config"
        else
            echo "${key}=\"${value}\"" > "$config"
        fi
    fi
}

# Rearrange all options to place flags first
# Author: greycat
# URL: https://mywiki.wooledge.org/ComplexOptionParsing
arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            --no-notify)
                flags+=("-q")
                ;;
            --exit-code)
                # Handle this in main() before command execution
                flags+=("--exit-code")
                ;;
            --watch|--all|--input|--volume-only|--mute-only)
                # These are listen command options, not global flags
                # Pass them through as command arguments
                args+=("$1")
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=:A:Ce:af:hj:lL:nN:pPs:S:t:u:vyI:D:q

    arrange_opts "$optstring" "$@"
    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            A    ) IFS=: read -r node alias <<< "$OPTARG"
                   NODE_ALIASES[$node]=$alias ;;
            C    ) USE_CANBERRA=true ;;
            e    ) EXPIRES=$OPTARG ;;
            a    ) ALL_SINKS=true ;;
            f    ) FADE_DURATION=$OPTARG ;;
            j    ) IFS=, read -ra ICONS_EMOJI <<< "$OPTARG" ;;
            l    ) USE_FULLCOLOR_ICONS=true ;;
            L    ) PROGRESS_PLACEMENT=$OPTARG ;;
            n    ) DISPLAY_NOTIFICATIONS=true ;;
            N    ) NOTIFICATION_METHOD=$OPTARG ;;
            p    ) SHOW_VOLUME_PROGRESS=true ;;
            P    ) PLAY_SOUND=true ;;
            s    ) NODE_NAME=$OPTARG ;;
            S    ) SYMBOLIC_ICON_SUFFIX=$OPTARG ;;
            t    ) STATUSLINE=$OPTARG ;;
            u    ) SIGNAL=$OPTARG ;;
            v    ) VERBOSE=true ;;
            I    ) SOURCE_NAME=$OPTARG ;;
            D    ) DEFAULT_STEP=$OPTARG
                   save_config_value "DEFAULT_STEP" "$OPTARG" ;;
            y    ) USE_DUNSTIFY=true ;;
            q    ) DISPLAY_NOTIFICATIONS=false ;;
            h | *) usage ;;
        esac
    done

    read -ra CMDARGS <<< "${OPTARR[@]:$((OPTIND-1))}"
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    case "$COMMAND" in
        up|raise|increase)
            case "$#" in
                0) increase_volume ;;
                1) increase_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        down|lower|decrease)
            case "$#" in
                0) decrease_volume ;;
                1) decrease_volume "$1" ;;
                *) usage ;;
            esac
            ;;
        set)
            case "$#" in 1) ;; *) usage ;; esac
            case "$1" in
                +*) increase_volume "${1:1}" ;;
                -*) decrease_volume "${1:1}" ;;
                *) set_volume "$1" ;;
            esac
            ;;
        wheel)
            case "$#" in
                0)
                    error "Wheel delta required. Use: wheel <delta>"
                    echo "  ${COLOR_GREEN}wheel 2.0${COLOR_RESET}   - scroll up (positive delta)"
                    echo "  ${COLOR_GREEN}wheel -2.0${COLOR_RESET}  - scroll down (negative delta)"
                    EXITCODE=$EX_USAGE
                    return 1
                    ;;
                1)
                    wheel_volume "$1"
                    ;;
                *)
                    usage
                    ;;
            esac
            ;;
        mute) toggle_mute ;;
        fade)
            case "$#" in
                2)
                    # fade <from> <to> - uses default duration (500ms)
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" 500 "$NODE_ID"
                    ;;
                3)
                    # fade <from> <to> <duration_ms>
                    local -r from_vol=$1
                    local -r to_vol=$2
                    local -r duration=$3
                    local current_vol
                    current_vol=$(get_volume)
                    # Set to from_vol first if needed
                    if (( current_vol != from_vol )); then
                        wpctl set-volume "$NODE_ID" "${from_vol}%" &>/dev/null
                        invalidate_cache
                    fi
                    fade_volume "$to_vol" "$duration" "$NODE_ID"
                    ;;
                *)
                    error "Usage: fade <from> <to> [duration_ms]"
                    echo "  ${COLOR_GREEN}fade 0 100${COLOR_RESET}        - fade from 0% to 100% (default 500ms)"
                    echo "  ${COLOR_GREEN}fade 0 100 2000${COLOR_RESET}  - fade from 0% to 100% over 2000ms"
                    EXITCODE=$EX_USAGE
                    return 1
                    ;;
            esac
            ;;
        mic)
            case "$#" in
                0) usage ;;
                1)
                    case "$1" in
                        mute) toggle_mic_mute ;;
                        up|raise|increase) increase_mic_volume ;;
                        down|lower|decrease) decrease_mic_volume ;;
                        *) usage ;;
                    esac
                    ;;
                2)
                    case "$1" in
                        up|raise|increase) increase_mic_volume "$2" ;;
                        down|lower|decrease) decrease_mic_volume "$2" ;;
                        set)
                            case "$2" in
                                +*) increase_mic_volume "${2:1}" ;;
                                -*) decrease_mic_volume "${2:1}" ;;
                                *) set_mic_volume "$2" ;;
                            esac
                            ;;
                        *) usage ;;
                    esac
                    ;;
                *) usage ;;
            esac
            ;;
        listen) listen "$*" ;;
        list)
            case "$#" in
                0) list "" ;;
                1) list "$1" ;;
                *) usage ;;
            esac
            ;;
        switch)
            case "$#" in
                0) switch_sink ;;
                1) switch_sink "$1" ;;
                *) usage ;;
            esac
            ;;
        next) next_sink ;;
        prev|previous) prev_sink ;;
        port)
            case "$#" in
                0) port "" ;;
                1) port "$1" ;;
                2) port "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        profile)
            case "$#" in
                0) profile "" ;;
                1) profile "$1" ;;
                2) profile "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        boost)
            case "$#" in
                0) boost "" ;;
                1) boost "$1" ;;
                2) boost "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        sync)
            case "$#" in
                0) sync_volume ;;
                *) usage ;;
            esac
            ;;
        app)
            case "$#" in
                0) app "" ;;
                1) app "$1" ;;
                2) app "$1" "$2" ;;
                3) app "$1" "$2" "$3" ;;
                4) app "$1" "$2" "$3" "$4" ;;
                *) usage ;;
            esac
            ;;
        output)
            case "$#" in 0) usage ;; esac
            output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        outputs) list_output_formats ;;
        notifications) list_notification_methods ;;
        config)
            case "$#" in
                0) config "" ;;
                1) config "$1" ;;
                2) config "$1" "$2" ;;
                *) usage ;;
            esac
            ;;
        *) usage ;;
    esac
}

play_volume_changed() {
    $PLAY_SOUND || return

    # Sound can be handled by the notification method
    if $DISPLAY_NOTIFICATIONS && has_capability sound; then return; fi

    if $USE_CANBERRA; then ca_play "$SOUND_VOLUME_CHANGED" "Volume Changed"
    else pw_play "$SOUND_VOLUME_CHANGED"; fi
}

ca_play() {
    local -r file=$1 desc=$2
    local executable="${CANBERRA_PATH:+${CANBERRA_PATH%/}/}canberra-gtk-play"

    command_exists "$executable" || { error "$executable not found. Please install it or set CANBERRA_PATH to the correct path."; return 1; }

    if [[ -f $file ]]; then "$executable" -f "$file" -d "$desc"
    else "$executable" -i "audio-volume-change" -d "$desc"
    fi
}

post_command_hook() {
    if is_command_hookable "$COMMAND"; then
        # Check if this was a mic command
        if [[ $COMMAND == "mic" ]]; then
            show_mic_notification
            play_volume_changed
            update_statusbar || usage
        else
            show_volume_notification
            play_volume_changed
            update_statusbar || usage
        fi
    fi
}

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Commands which will not use post_command_hook(), usually because
    # they handle notifications and/or statusbar updates manually
    declare -a POST_HOOK_EXEMPT_COMMANDS=(
        listen
        notifications
        outputs
        list
        switch
        next
        prev
        port
        profile
        sync
        app
        config
    )

    # Exit codes
    declare -ir EX_OK=0 EX_URGENT=33 EX_USAGE=64 EX_UNAVAILABLE=69

    # Main program exit code
    declare -i EXITCODE=$EX_OK

    # Standard notification icons. Usually full color
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS=(
        audio-volume-muted
        audio-volume-high
        audio-volume-low
        audio-volume-medium
    )

    # Symbolic notification icons. Usually low color or monochrome
    #   Note: order matters; muted, high, low, medium, and optionally overamplified
    declare -a ICONS_SYMBOLIC=(
        audio-volume-muted-symbolic
        audio-volume-high-symbolic
        audio-volume-low-symbolic
        audio-volume-medium-symbolic
        ## Only exists in some icon sets
        # audio-volume-overamplified-symbolic
    )

    # Emoji-based icons.
    declare -a ICONS_EMOJI=( ï± ï©½ ï©¾ ï©¿ )

    # Volume changed sound.
    declare SOUND_VOLUME_CHANGED=${SOUND_VOLUME_CHANGED:-/usr/share/sounds/freedesktop/stereo/audio-volume-change.oga}

    # DBUS constants
    declare -r \
        DBUS_NAME=org.freedesktop.Notifications \
        DBUS_PATH=/org/freedesktop/Notifications \
        DBUS_IFAC_FDN=org.freedesktop.Notifications

    # Notification server information
    declare \
        NOTIFY_SERVER
        # NOTIFY_VENDOR \
        # NOTIFY_VERSION \
        # NOTIFY_SPEC_VERSION

    # Notification capabilities
    declare -a NOTIFY_CAPS=()

    # PipeWire node aliases
    declare -gA NODE_ALIASES=()

    # Per-sink configuration arrays
    # These can be keyed by sink ID, name, or nick
    declare -gA SINK_MAX_VOL=()
    declare -gA SINK_DEFAULT_STEP=()
    declare -gA SINK_DISPLAY_NOTIFICATIONS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_NOTIFICATION_METHOD=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_USE_DUNSTIFY=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_USE_FULLCOLOR_ICONS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_SHOW_VOLUME_PROGRESS=()
    # shellcheck disable=SC2034  # Reserved for future per-sink notification preferences
    declare -gA SINK_EXPIRES=()

    declare -i DEFAULT_VOL=100 MIN_VOL=0 MAX_VOL=100
    declare -i DEFAULT_STEP=${DEFAULT_STEP:-5}

    # Cached output of `pw-dump`; so we don't have to call it each time we need it
    declare PW_DUMP=""

    # Colors
    declare -r \
        COLOR_MUTED=${COLOR_MUTED:-#FFFF00} \
        COLOR_MIN_TO_DEFAULT=${COLOR_MIN_TO_DEFAULT:-#00FF00} \
        COLOR_FULL=${COLOR_FULL:-#FFFF00} \
        COLOR_FULL_TO_MAX=${COLOR_FULL_TO_MAX:-#FF0000} \
        COLOR_OTHER=${COLOR_OTHER:-#FFFFFF} \
        COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-#222222} \
        COLOR_TEXT=${COLOR_TEXT:-#FFFF00}

    declare COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_MAGENTA COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################
    declare NOTIFICATION_METHOD=""

    declare \
        COMMAND="" \
        DISPLAY_NOTIFICATIONS=false \
        SHOW_VOLUME_PROGRESS=false \
        USE_DUNSTIFY=false \
        USE_FULLCOLOR_ICONS=false \
        PROGRESS_PLACEMENT=summary \
        SIGNAL="" \
        NODE_NAME="" \
        NODE_ID="" \
        SOURCE_NAME="" \
        SOURCE_ID="" \
        STATUSLINE="" \
        SYMBOLIC_ICON_SUFFIX="" \
        PLAY_SOUND=false \
        USE_CANBERRA=false \
        FADE_DURATION="" \
        ALL_SINKS=false \
        VERBOSE=false

    declare -i EXPIRES=1500

    define_helpers
    define_notify
    define_output_formats
    define_commands

    init_color

    load_config

    # Handle --exit-code option before parsing (to avoid triggering usage())
    for arg in "$@"; do
        if [[ "$arg" == "--exit-code" ]]; then
            show_exit_codes
            exit "$EX_OK"
        fi
    done

    parse_opts "$@"

    # Remove --exit-code from CMDARGS if it somehow ended up there
    local temp=()
    for arg in "${CMDARGS[@]}"; do
        [[ "$arg" != "--exit-code" ]] && temp+=("$arg")
    done
    CMDARGS=("${temp[@]}")

    # Requires options to be parsed first
    init_audio
    init_source

    # Handle i3blocks mouse wheel events automatically
    # When i3blocks calls with BLOCK_BUTTON set and output i3blocks command,
    # handle wheel events before executing the output command
    if not_empty "${BLOCK_BUTTON:-}" && [[ "${CMDARGS[0]:-}" == "output" ]] && [[ "${CMDARGS[1]:-}" == "i3blocks" ]]; then
        local step
        step=$(get_effective_default_step)

        case "$BLOCK_BUTTON" in
            4)  # Scroll up
                exec_command "wheel $step"
                post_command_hook
                # Continue to output after handling wheel event
                ;;
            5)  # Scroll down
                exec_command "wheel -$step"
                post_command_hook
                # Continue to output after handling wheel event
                ;;
        esac
    fi

    exec_command "${CMDARGS[*]}" && post_command_hook

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
